000005CC Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 22/08/2022 10:03:50 PM

00000000                             1  *************************************************************
00000000                             2  *                                                           *
00000000                             3  *     Enhanced BASIC for the Motorola MC680xx               *
00000000                             4  *                                                           *
00000000                             5  * Derived from EhBASIC for the 6502 and adapted by:         *
00000000                             6  * Lee Davison                                               *
00000000                             7  *                                                           *
00000000                             8  * mail : leeedavison@lycos.co.uk                            *
00000000                             9  *                                                           *
00000000                            10  * This is the generic version with I/O and LOAD/SAVE        *
00000000                            11  * example code for the EASy68k editor/simulator. 2002/3.    *
00000000                            12  *                                                           *
00000000                            13  *************************************************************
00000000                            14  *     Copyright (C) 2002/3 by Lee Davison. This program     *
00000000                            15  *     may be freely distributed for personal use only.      *
00000000                            16  *     All commercial rights are reserved.                   *
00000000                            17  *************************************************************
00000000                            18  *                                                           *
00000000                            19  *     The choice of memory areas in this code is set to     *
00000000                            20  *     reflect the actual memory present on a 68008 SBC      *
00000000                            21  *     that I have.                                          *
00000000                            22  *                                                           *
00000000                            23  *     Memory map:                                           *
00000000                            24  *                                                           *
00000000                            25  *     ROM   $000000 - $00FFFF                               *
00000000                            26  *     RAM   $040000 - $048000 ($050000 optional)            *
00000000                            27  *                                                           *
00000000                            28  *************************************************************
00000000                            29  
00000000                            30  * Ver 1.10
00000000                            31  
00000000                            32      opt cre
00000400                            33      org $000400         * past the vectors in a real system
00000400                            34  
00000400                            35  * the following code is simulator specific, change to suit your system
00000400                            36  
00000400                            37  * output character to the console from register d0
00000400                            38  
00000400                            39  vec_out
00000400  48E7 C000                 40      movem.l d0-d1,-(sp)     * save d0, d1
00000404  1200                      41      move.b  d0,d1           * copy character
00000406  7006                      42      moveq   #6,d0           * character out
00000408  4E4F                      43      trap    #15         * do i/o function
0000040A  4CDF 0003                 44      movem.l (sp)+,d0-d1     * restore d0, d1
0000040E  4E75                      45      rts
00000410                            46  
00000410                            47  * input a character from the console into register d0
00000410                            48  * else return Cb=0 if there's no character available
00000410                            49  
00000410                            50  vec_in
00000410  2F01                      51      move.l  d1,-(sp)        * save d1
00000412  7007                      52      moveq   #7,d0           * get status
00000414  4E4F                      53      trap    #15         * do i/o function
00000416  1001                      54      move.b  d1,d0           * copy status
00000418  6608                      55      bne.s   retchr          * branch if character waiting
0000041A                            56  
0000041A  221F                      57      move.l  (sp)+,d1        * restore d1
0000041C  0000 0000                 58      ori.b   #$00,d0         * set z flag
00000420                            59  *   andi.b  #$fe,ccr        * clear carry, flag we not got byte (done by ORI.b)
00000420  4E75                      60      rts
00000422                            61  
00000422                            62  retchr
00000422  7005                      63      moveq   #5,d0           * get byte
00000424  4E4F                      64      trap    #15         * do i/o function
00000426  1001                      65      move.b  d1,d0           * copy byte
00000428  221F                      66      move.l  (sp)+,d1        * restore d1
0000042A  0000 0000                 67      ori.b   #$00,d0         * set z flag on received byte
0000042E  003C 0001                 68      ori.b   #1,ccr          * set carry, flag we got a byte
00000432  4E75                      69      rts
00000434                            70  
00000434                            71  * LOAD routine for the Easy68k simulator
00000434                            72  
00000434                            73  vec_ld
00000434  534D                      74      subq.w  #1,a5           * decrement execute pointer
00000436  6100 106E                 75      bsr lab_gval        * get value from line
0000043A                            76  
0000043A  6100 19CA                 77      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
0000043E  6700 0384                 78      beq lab_fcer        * if null do function call error, then warm start
00000442                            79  
00000442  2248                      80      movea.l a0,a1           * copy filename pointer
00000444  D0C0                      81      adda.w  d0,a0           * add length to find end of string
00000446  1F10                      82      move.b  (a0),-(sp)      * save byte
00000448  2F08                      83      move.l  a0,-(sp)        * save address
0000044A  7000                      84      moveq   #0,d0           * set for null
0000044C  1080                      85      move.b  d0,(a0)         * null terminate string
0000044E  303C 0033                 86      move    #51,d0          * open existing file
00000452  4E4F                      87      trap    #15
00000454  4A40                      88      tst.w   d0          * test load result
00000456  6600 0040                 89      bne load_exit       * if error clear up and exit
0000045A                            90  
0000045A  23C1 000405F6             91      move.l  d1,file_id      * save file ID
00000460  227C 000405F4             92      movea.l #file_byte,a1       * point to byte buffer
00000466  7401                      93      moveq   #1,d2           * set byte count
00000468  7035                      94      moveq   #53,d0          * read first byte from file
0000046A  4E4F                      95      trap    #15
0000046C                            96  
0000046C  4A40                      97      tst.w   d0          * test status
0000046E  6600 0024                 98      bne load_close      * if error close files & exit
00000472                            99  
00000472  7400                     100      moveq   #0,d2           * file position
00000474  7037                     101      moveq   #55,d0          * reset file position
00000476  4E4F                     102      trap    #15
00000478                           103  
00000478  1011                     104      move.b  (a1),d0         * get first file byte
0000047A  6600 0028                105      bne load_ascii      * if first byte not $00 go do ASCII load
0000047E                           106  
0000047E                           107                      * do binary load
0000047E  2279 00040432            108      movea.l smeml,a1        * get start of program memory
00000484  343C 7FFF                109      move.w  #$7fff,d2       * set to $7FFF (max read length)
00000488  7035                     110      moveq   #53,d0          * read from file
0000048A  4E4F                     111      trap    #15
0000048C                           112  
0000048C  D489                     113      add.l   a1,d2           * add start of memory to loaded program length
0000048E  23C2 00040436            114      move.l  d2,sfncl        * save end of program
00000494                           115  
00000494                           116  load_close
00000494  7032                     117      moveq   #50,d0          * close all files
00000496  4E4F                     118      trap    #15
00000498                           119  
00000498                           120  load_exit
00000498  205F                     121      movea.l (sp)+,a0        * get string end back
0000049A  109F                     122      move.b  (sp)+,(a0)      * put byte back
0000049C  6100 05CE                123      bsr lab_147a        * go do "CLEAR"
000004A0  6000 035E                124      bra lab_1274        * BASIC warm start entry, go wait for Basic command
000004A4                           125  
000004A4                           126  * is ASCII file so just change the input vector
000004A4                           127  
000004A4                           128  load_ascii
000004A4  43FA 0010                129      lea (load_in,pc),a1     * get byte from file vector
000004A8  23C9 0004040E            130      move.l  a1,v_inptv      * set input vector
000004AE  205F                     131      movea.l (sp)+,a0        * get string end back
000004B0  109F                     132      move.b  (sp)+,(a0)      * put byte back
000004B2  6000 0354                133      bra lab_127d        * now we just wait for Basic command (no "Ready")
000004B6                           134  
000004B6                           135  * input character to register d0 from file
000004B6                           136  
000004B6                           137  load_in
000004B6  48E7 6040                138      movem.l d1-d2/a1,-(sp)      * save d1, d2 & a1
000004BA  2239 000405F6            139      move.l  file_id,d1      * get file ID back
000004C0  227C 000405F4            140      movea.l #file_byte,a1       * point to byte buffer
000004C6  7401                     141      moveq   #1,d2           * set count for one byte
000004C8  7035                     142      moveq   #53,d0          * read from file
000004CA  4E4F                     143      trap    #15
000004CC                           144  
000004CC  4A40                     145      tst.w   d0          * test status
000004CE  6600 000E                146      bne load_eof        * branch if byte read failed
000004D2                           147  
000004D2  1011                     148      move.b  (a1),d0         * get byte
000004D4  4CDF 0206                149      movem.l (sp)+,d1-d2/a1      * restore d1, d2 & a1
000004D8  003C 0001                150      ori.b   #1,ccr          * set carry, flag we got a byte
000004DC  4E75                     151      rts
000004DE                           152                      * got an error on read so restore vector and tidy up
000004DE                           153  load_eof
000004DE  7032                     154      moveq   #50,d0          * close all files
000004E0  4E4F                     155      trap    #15
000004E2                           156  
000004E2  43FA FF2C                157      lea (vec_in,pc),a1      * get byte from input device vector
000004E6  23C9 0004040E            158      move.l  a1,v_inptv      * set input vector
000004EC  7000                     159      moveq   #0,d0           * clear byte
000004EE  4CDF 0206                160      movem.l (sp)+,d1-d2/a1      * restore d1, d2 & a1
000004F2  6100 0578                161      bsr lab_147a        * do CLEAR (erase variables/functions & flush stacks)
000004F6  6000 0308                162      bra lab_1274        * BASIC warm start entry, go wait for Basic command
000004FA                           163  
000004FA                           164  * SAVE routine for the Easy68k simulator
000004FA                           165  
000004FA                           166  vec_sv
000004FA  534D                     167      subq.w  #1,a5           * decrement execute pointer
000004FC  6100 0FA8                168      bsr lab_gval        * get value from line
00000500  6100 0E28                169      bsr lab_ctst        * check if source is string, else do type mismatch
00000504                           170  
00000504  6100 0FFE                171      bsr lab_gbyt        * get next BASIC byte
00000508  6700 0062                172      beq save_bas        * branch if no following
0000050C                           173  
0000050C  B03C 002C                174      cmp.b   #',',d0         * compare with ","
00000510  6600 02BE                175      bne lab_sner        * not "," so go do syntax error/warm start
00000514                           176  
00000514  6100 0FEC                177      bsr lab_igby        * increment & scan memory
00000518  0000 0020                178      ori.b   #$20,d0         * ensure lower case
0000051C  B03C 0061                179      cmp.b   #'a',d0         * compare with "a"
00000520  6600 02AE                180      bne lab_sner        * not "a" so go do syntax error/warm start
00000524                           181  
00000524  6100 18E0                182      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
00000528  6700 029A                183      beq lab_fcer        * if null do function call error, then warm start
0000052C                           184  
0000052C  2248                     185      movea.l a0,a1           * copy filename pointer
0000052E  D0C0                     186      adda.w  d0,a0           * add length to find end of string
00000530  1F10                     187      move.b  (a0),-(sp)      * save byte
00000532  2F08                     188      move.l  a0,-(sp)        * save address
00000534  7000                     189      moveq   #0,d0           * set for null
00000536  1080                     190      move.b  d0,(a0)         * null terminate string
00000538  303C 0034                191      move    #52,d0          * open new file
0000053C  4E4F                     192      trap    #15
0000053E  4A40                     193      tst.w   d0          * test save result
00000540  6600 0060                194      bne save_exit       * if error clear up and exit
00000544                           195  
00000544  23C1 000405F6            196      move.l  d1,file_id      * save file ID
0000054A                           197  
0000054A  2F39 00040414            198      move.l  v_outpv,-(sp)       * save the output vector
00000550  43FA 005C                199      lea (save_out,pc),a1    * send byte to file vector
00000554  23C9 00040414            200      move.l  a1,v_outpv      * change output vector
0000055A                           201  
0000055A  6100 0FA6                202      bsr lab_igby        * increment & scan memory
0000055E  6100 055C                203      bsr lab_list        * go do list (line numbers applicable)
00000562                           204  
00000562  23DF 00040414            205      move.l  (sp)+,v_outpv       * restore the output vector
00000568  6000 0034                206      bra save_close
0000056C                           207  
0000056C                           208  save_bas
0000056C  6100 1898                209      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
00000570  6700 0252                210      beq lab_fcer        * if null do function call error, then warm start
00000574                           211  
00000574  2248                     212      movea.l a0,a1           * copy filename pointer
00000576  D0C0                     213      adda.w  d0,a0           * add length to find end of string
00000578  1F10                     214      move.b  (a0),-(sp)      * save byte
0000057A  2F08                     215      move.l  a0,-(sp)        * save address
0000057C  7000                     216      moveq   #0,d0           * set for null
0000057E  1080                     217      move.b  d0,(a0)         * null terminate string
00000580  303C 0034                218      move    #52,d0          * open new file
00000584  4E4F                     219      trap    #15
00000586  4A40                     220      tst.w   d0          * test save result
00000588  6600 0018                221      bne save_exit       * if error clear up and exit
0000058C                           222  
0000058C  2279 00040432            223      movea.l smeml,a1        * get start of program
00000592  2439 00040436            224      move.l  sfncl,d2        * get end of program
00000598  9489                     225      sub.l   a1,d2           * subtract start of program (= length)
0000059A                           226  
0000059A  7036                     227      moveq   #54,d0          * write to file
0000059C  4E4F                     228      trap    #15
0000059E                           229  
0000059E                           230  save_close
0000059E  7032                     231      moveq   #50,d0          * close all files
000005A0  4E4F                     232      trap    #15
000005A2                           233  
000005A2                           234  save_exit
000005A2  205F                     235      movea.l (sp)+,a0        * get string end back
000005A4  109F                     236      move.b  (sp)+,(a0)      * put byte back
000005A6  4A40                     237      tst.w   d0          * test save result
000005A8  6600 021A                238      bne lab_fcer        * if error do function call error, then warm start
000005AC                           239  
000005AC  4E75                     240      rts
000005AE                           241  
000005AE                           242  * output character to file from register d0
000005AE                           243  
000005AE                           244  save_out
000005AE  48E7 E040                245      movem.l d0-d2/a1,-(sp)      * save d0, d1, d2 & a1
000005B2  2239 000405F6            246      move.l  file_id,d1      * get file ID back
000005B8  227C 000405F4            247      movea.l #file_byte,a1       * point to byte buffer
000005BE  1280                     248      move.b  d0,(a1)         * save byte
000005C0  7401                     249      moveq   #1,d2           * set byte count
000005C2  7036                     250      moveq   #54,d0          * write to file
000005C4  4E4F                     251      trap    #15
000005C6  4CDF 0207                252      movem.l (sp)+,d0-d2/a1      * restore d0, d1, d2 & a1
000005CA  4E75                     253      rts
000005CC                           254  
000005CC                           255  ****************************************************************************************
000005CC                           256  ****************************************************************************************
000005CC                           257  ****************************************************************************************
000005CC                           258  ****************************************************************************************
000005CC                           259  *
000005CC                           260  * Register use :- (must improve this !!)
000005CC                           261  *
000005CC                           262  *     a6 -  temp Bpntr          * temporary BASIC execute pointer
000005CC                           263  *     a5 -  Bpntr           * BASIC execute (get byte) pointer
000005CC                           264  *     a4 -  des_sk          * descriptor stack pointer
000005CC                           265  *     a3 -
000005CC                           266  *     a2 -
000005CC                           267  *     a1 -
000005CC                           268  *     a0 -
000005CC                           269  *
000005CC                           270  *     d7 -  FAC1 mantissa       * to do
000005CC                           271  *     d6 -  FAC1 sign & exponent    * to do
000005CC                           272  *     d5 -  FAC2 mantissa       * to do
000005CC                           273  *     d4 -  FAC2 sign & exponent    * to do
000005CC                           274  *     d3 -  BASIC got byte      * to do
000005CC                           275  *     d2 -
000005CC                           276  *     d1 -  general purpose
000005CC                           277  *     d0 -  general purpose
000005CC                           278  *
000005CC                           279  *
000005CC                           280  
000005CC                           281  * turn off simulator key echo
000005CC                           282  
000005CC                           283  code_start
000005CC  700C                     284      moveq   #12,d0          * keyboard echo
000005CE  7200                     285      moveq   #0,d1           * turn off echo
000005D0  4E4F                     286      trap    #15         * do i/o function
000005D2                           287  
000005D2                           288  * end of simulator specific code
000005D2                           289  
000005D2                           290  * BASIC cold start entry point
000005D2                           291  
000005D2                           292  lab_cold
000005D2  2E7C 00040400            293      move.l  #ram_base,sp        * set simulator stack for this prog
000005D8  303C 4EF9                294      move.w  #$4ef9,d0       * JMP opcode
000005DC  204F                     295      movea.l sp,a0           * point to start of vector table
000005DE                           296  
000005DE  30C0                     297      move.w  d0,(a0)+        * LAB_WARM
000005E0  43FA FFF0                298      lea (lab_cold,pc),a1    * initial warm start vector
000005E4  20C9                     299      move.l  a1,(a0)+        * set vector
000005E6                           300  
000005E6  30C0                     301      move.w  d0,(a0)+        * Usrjmp
000005E8  43FA 01DA                302      lea (lab_fcer,pc),a1    * initial user function vector
000005EC                           303                      * "Function call" error
000005EC  20C9                     304      move.l  a1,(a0)+        * set vector
000005EE                           305  
000005EE  30C0                     306      move.w  d0,(a0)+        * V_INPT JMP opcode
000005F0  43FA FE1E                307      lea (vec_in,pc),a1      * get byte from input device vector
000005F4  20C9                     308      move.l  a1,(a0)+        * set vector
000005F6                           309  
000005F6  30C0                     310      move.w  d0,(a0)+        * V_OUTP JMP opcode
000005F8  43FA FE06                311      lea (vec_out,pc),a1     * send byte to output device vector
000005FC  20C9                     312      move.l  a1,(a0)+        * set vector
000005FE                           313  
000005FE  30C0                     314      move.w  d0,(a0)+        * V_LOAD JMP opcode
00000600  43FA FE32                315      lea (vec_ld,pc),a1      * load BASIC program vector
00000604  20C9                     316      move.l  a1,(a0)+        * set vector
00000606                           317  
00000606  30C0                     318      move.w  d0,(a0)+        * V_SAVE JMP opcode
00000608  43FA FEF0                319      lea (vec_sv,pc),a1      * save BASIC program vector
0000060C  20C9                     320      move.l  a1,(a0)+        * set vector
0000060E                           321  
0000060E  30C0                     322      move.w  d0,(a0)+        * V_CTLC JMP opcode
00000610  43FA 281C                323      lea (vec_cc,pc),a1      * save CTRL-C check vector
00000614  20C9                     324      move.l  a1,(a0)+        * set vector
00000616                           325  
00000616  208F                     326      move.l  sp,(a0)         * save entry stack value
00000618                           327  
00000618                           328  * set-up start values
00000618                           329  
00000618                           330  lab_gmem
00000618  7000                     331      moveq   #$00,d0         * clear d0
0000061A  13C0 000405ED            332      move.b  d0,nullct       * default NULL count
00000620  13C0 000405EE            333      move.b  d0,tpos         * clear terminal position
00000626  13C0 000405F1            334      move.b  d0,ccflag       * allow CTRL-C check
0000062C  33C0 000405FA            335      move.w  d0,prg_strt-2       * clear start word
00000632  33C0 000405DE            336      move.w  d0,bhsend       * clear value to string end word
00000638                           337  
00000638  13FC 0050 000405EF       338      move.b  #$50,twidth     * default terminal width byte for simulator
00000640                           339  *   move.b  d0,twidth       * default terminal width byte
00000640                           340  
00000640  13FC 000E 000405EA       341      move.b  #$0e,tabsiz     * save default tab size = 14
00000648                           342  
00000648  13FC 0038 000405F0       343      move.b  #$38,iclim      * default limit for TAB = 14 for simulator
00000650                           344  *   move.b  #$f2,iclim      * default limit for TAB = 14
00000650                           345  
00000650  287C 00040492            346      movea.l #des_sk,a4      * set descriptor stack start
00000656                           347  
00000656  6100 09CA                348      bsr lab_crlf        * print CR/LF
0000065A  41FA 36AD                349      lea (lab_mszm,pc),a0    * point to memory size message
0000065E  6100 0A24                350      bsr lab_18c3        * print null terminated string from memory
00000662  6100 029E                351      bsr lab_inln        * print "? " and get BASIC input
00000666                           352                      * return a0 pointing to the buffer start
00000666  2A48                     353      movea.l a0,a5           * set BASIC execute pointer to buffer
00000668  6100 0E9A                354      bsr lab_gbyt        * scan memory
0000066C  6628                     355      bne.s   lab_2daa        * branch if not null (user typed something)
0000066E                           356  
0000066E                           357                      * character was null so get memory size the hard way
0000066E                           358  
0000066E  207C 000405FC            359      movea.l #prg_strt,a0        * get start of program RAM
00000674  243C 00048000            360      move.l  #ram_top,d2     * remember top of ram+1
0000067A  303C 5555                361      move.w  #$5555,d0       * test pattern 1
0000067E  323C AAAA                362      move.w  #$aaaa,d1       * test pattern 2
00000682                           363  
00000682                           364  lab_2d93
00000682  B1C2                     365      cmpa.l  d2,a0           * compare with top of RAM+1
00000684  6746                     366      beq.s   lab_2db6        * branch if match (end of user RAM)
00000686                           367  
00000686  3080                     368      move.w  d0,(a0)         * set test word
00000688  B050                     369      cmp.w   (a0),d0         * compare it
0000068A  6640                     370      bne.s   lab_2db6        * branch if fail
0000068C                           371  
0000068C  3081                     372      move.w  d1,(a0)         * set new test word
0000068E  B258                     373      cmp.w   (a0)+,d1        * compare it
00000690  67F0                     374      beq.s   lab_2d93        * if ok go do next word
00000692                           375  
00000692  5548                     376      subq.w  #2,a0           * decrement pointer
00000694  6036                     377      bra.s   lab_2db6        * and branch if fail
00000696                           378  
00000696                           379  lab_2daa
00000696  6100 29C0                380      bsr lab_2887        * get FAC1 from string
0000069A  1239 00040598            381      move.b  fac1_e,d1       * get FAC1 exponent
000006A0  B23C 0081                382      cmp.b   #$81,d1         * compare with min
000006A4  6500 FF72                383      bcs lab_gmem        * if <1 go get again
000006A8                           384  
000006A8  B23C 00A0                385      cmp.b   #$a0,d1         * compare maximum integer range exponent
000006AC  6614                     386      bne.s   lab_2dab        * if not $A0 go test is less
000006AE                           387  
000006AE  4A39 00040599            388      tst.b   fac1_s          * test FAC1 sign
000006B4  6A10                     389      bpl.s   lab_2dad        * branch if FAC1 +ve
000006B6                           390  
000006B6                           391                      * FAC1 was -ve and exponent is $A0
000006B6  0CB9 80000000 00040594   392      cmpi.l  #$80000000,fac1_m   * compare with max -ve
000006C0  6704                     393      beq.s   lab_2dad        * branch if max -ve
000006C2                           394  
000006C2                           395  lab_2dab
000006C2  6400 FF54                396      bcc lab_gmem        * get again if too big
000006C6                           397  
000006C6                           398  lab_2dad
000006C6  6100 1F2C                399      bsr lab_2831        * convert FAC1 floating-to-fixed
000006CA                           400                      * result in d0 and Itemp
000006CA  2040                     401      movea.l d0,a0           * copy result to address reg
000006CC                           402  
000006CC                           403  lab_2db6
000006CC  B1FC 000406FC            404      cmpa.l  #(prg_strt+$100),a0 * compare with start of RAM+$100
000006D2  6500 FF44                405      bcs lab_gmem        * if too small go try again
000006D6                           406  
000006D6                           407  * uncomment these lines if you want to check on the high limit of memory. Note if
000006D6                           408  * Ram_top is set too low then this will fail. default is ignore it and assume the
000006D6                           409  * users know what they're doing!
000006D6                           410  *
000006D6                           411  *   cmpa.l  #ram_top,a0     * compare with end of RAM+1
000006D6                           412  *   bhi.s   lab_gmem        * if too large go try again
000006D6                           413  
000006D6  23C8 0004044E            414      move.l  a0,ememl        * set end of mem
000006DC  23C8 0004044A            415      move.l  a0,sstorl       * set bottom of string space
000006E2                           416  
000006E2  7000                     417      moveq   #0,d0           * longword clear
000006E4  207C 000405FC            418      movea.l #prg_strt,a0        * get start of mem
000006EA  2080                     419      move.l  d0,(a0)         * clear first longword
000006EC  23C8 00040432            420      move.l  a0,smeml        * save start of mem
000006F2                           421  
000006F2  6100 0360                422      bsr lab_1463        * do "NEW" and "CLEAR"
000006F6  6100 092A                423      bsr lab_crlf        * print CR/LF
000006FA  2039 0004044E            424      move.l  ememl,d0        * get end of mem
00000700  90B9 00040432            425      sub.l   smeml,d0        * subtract start of mem
00000706                           426  
00000706  6100 1F72                427      bsr lab_295e        * print d0 as unsigned integer (bytes free)
0000070A  41FA 360C                428      lea (lab_smsg,pc),a0    * point to start message
0000070E  6100 0974                429      bsr lab_18c3        * print null terminated string from memory
00000712                           430  
00000712  207C 000032B6            431      movea.l #lab_rsed,a0        * point to value
00000718  6100 1DAE                432      bsr lab_ufac        * unpack memory (a0) into FAC1
0000071C                           433  
0000071C  23FC 00000800 00040402   434      move.l  #lab_1274,wrmjpv    * warm start vector
00000726  6100 23C2                435      bsr lab_rnd         * initialise
0000072A  4EF9 00040400            436      jmp lab_warm        * go do warm start
00000730                           437  
00000730                           438  * search the stack for FOR, GOSUB or DO activity
00000730                           439  * exit with z=1 if FOR, else exit with z=0
00000730                           440  * return modified stack in a2
00000730                           441  
00000730                           442  lab_11a1
00000730  244F                     443      movea.l sp,a2           * copy stack pointer
00000732  504A                     444      addq.w  #8,a2           * back past two levels of return address
00000734                           445  lab_11a6
00000734  3012                     446      move.w  (a2),d0         * get token
00000736  B07C 0081                447      cmp.w   #tk_for,d0      * is FOR token on stack?
0000073A  661A                     448      bne.s   rts_002         * exit if not
0000073C                           449  
0000073C                           450                      * was FOR token
0000073C  206A 0002                451      movea.l 2(a2),a0        * get stacked FOR variable pointer
00000740  2279 00040476            452      movea.l frnxtl,a1       * get variable pointer for FOR/NEXT
00000746  B3FC 00000000            453      cmpa.l  #0,a1           * set the flags
0000074C  660A                     454      bne.s   lab_11bb        * branch if not null
0000074E                           455  
0000074E  23C8 00040476            456      move.l  a0,frnxtl       * save var pointer for FOR/NEXT
00000754  B040                     457      cmp.w   d0,d0           * set z for ok exit
00000756                           458  rts_002
00000756  4E75                     459      rts
00000758                           460  
00000758                           461  lab_11bb
00000758  B1C9                     462      cmpa.l  a1,a0           * compare var pointer with stacked var pointer
0000075A  670C                     463      beq.s   rts_003         * exit if match found
0000075C                           464  
0000075C  D4FC 001A                465      adda.w  #$1a,a2         * add FOR stack use size
00000760  B5F9 00040400            466      cmpa.l  ram_base,a2     * compare with stack top
00000766  65CC                     467      bcs.s   lab_11a6        * loop if not at start of stack
00000768                           468  
00000768                           469  rts_003
00000768  4E75                     470      rts
0000076A                           471  
0000076A                           472  * check room on stack for d0 bytes
0000076A                           473  
0000076A                           474  *LAB_1212
0000076A                           475  *   add.l   #ram_strt,d0        * add start of ram to value to check
0000076A                           476  *   cmp.l   sp,d0           * compare new "limit" with stack pointer
0000076A                           477  *   bcc.s   lab_omer        * if sp<limit do "Out of memory" error/warm start
0000076A                           478  
0000076A                           479  *   rts
0000076A                           480  
0000076A                           481  * check available memory, "Out of memory" error if no room
0000076A                           482  * addr to check is in a0
0000076A                           483  
0000076A                           484  lab_121f
0000076A  B1F9 0004044A            485      cmpa.l  sstorl,a0       * compare with bottom of string memory
00000770  650C                     486      bcs.s   rts_004         * if less then exit (is ok)
00000772                           487  
00000772  6100 1534                488      bsr lab_garb        * garbage collection routine
00000776  B1F9 0004044A            489      cmpa.l  sstorl,a0       * compare with bottom of string memory
0000077C  633E                     490      bls.s   lab_omer        * if Sstorl <= a0 do "Out of memory" error/warm start
0000077E                           491  
0000077E                           492  rts_004                 * ok exit, carry set
0000077E  4E75                     493      rts
00000780                           494  
00000780                           495  ** do internal error
00000780                           496  *
00000780                           497  *lab_iter
00000780                           498  *   moveq   #$58,d0         * error code $58 "Internal" error
00000780                           499  *   bra.s   lab_xerr        * do error #d0, then warm start
00000780                           500  
00000780                           501  * do address error
00000780                           502  
00000780                           503  lab_ader
00000780  7054                     504      moveq   #$54,d0         * error code $54 "Address" error
00000782  6052                     505      bra.s   lab_xerr        * do error #d0, then warm start
00000784                           506  
00000784                           507  * do wrong dimensions error
00000784                           508  
00000784                           509  lab_wder
00000784  7050                     510      moveq   #$50,d0         * error code $50 "Wrong dimensions" error
00000786  604E                     511      bra.s   lab_xerr        * do error #d0, then warm start
00000788                           512  
00000788                           513  * do undimensioned array error
00000788                           514  
00000788                           515  lab_uder
00000788  704C                     516      moveq   #$4c,d0         * error code $4C "undimensioned array" error
0000078A  604A                     517      bra.s   lab_xerr        * do error #d0, then warm start
0000078C                           518  
0000078C                           519  * do undefined variable error
0000078C                           520  
0000078C                           521  lab_uver
0000078C  7048                     522      moveq   #$48,d0         * error code $24*2 "undefined variable" error
0000078E  6046                     523      bra.s   lab_xerr        * do error #X then warm start
00000790                           524  
00000790                           525  * if you want undefined variables to return 0 (or "") then comment out the above
00000790                           526  * two lines and uncomment these two
00000790                           527  *
00000790                           528  * value returned by this is either numeric zero (exponent byte is $00) or null string
00000790                           529  * (string pointer is $00). in fact a pointer to any $00 longword would have done.
00000790                           530  *
00000790                           531  *   lea (lab_1d96,pc),a0    * else return dummy null pointer
00000790                           532  *   rts
00000790                           533  
00000790                           534  * do loop without do error
00000790                           535  
00000790                           536  lab_lder
00000790  7044                     537      moveq   #$44,d0         * error code $22*2 "LOOP without DO" error
00000792  6042                     538      bra.s   lab_xerr        * do error #d0, then warm start
00000794                           539  
00000794                           540  * do undefined function error
00000794                           541  
00000794                           542  lab_ufer
00000794  7040                     543      moveq   #$40,d0         * error code $20*2 "Undefined function" error
00000796  603E                     544      bra.s   lab_xerr        * do error #d0, then warm start
00000798                           545  
00000798                           546  * do can't continue error
00000798                           547  
00000798                           548  lab_ccer
00000798  703C                     549      moveq   #$3c,d0         * error code $1E*2 "Can't continue" error
0000079A  603A                     550      bra.s   lab_xerr        * do error #d0, then warm start
0000079C                           551  
0000079C                           552  * do string too complex error
0000079C                           553  
0000079C                           554  lab_scer
0000079C  7038                     555      moveq   #$38,d0         * error code $1C*2 "String too complex" error
0000079E  6036                     556      bra.s   lab_xerr        * do error #d0, then warm start
000007A0                           557  
000007A0                           558  * do string too long error
000007A0                           559  
000007A0                           560  lab_sler
000007A0  7034                     561      moveq   #$34,d0         * error code $1A*2 "String too long" error
000007A2  6032                     562      bra.s   lab_xerr        * do error #d0, then warm start
000007A4                           563  
000007A4                           564  * do type missmatch error
000007A4                           565  
000007A4                           566  lab_tmer
000007A4  7030                     567      moveq   #$30,d0         * error code $18*2 "Type mismatch" error
000007A6  602E                     568      bra.s   lab_xerr        * do error #d0, then warm start
000007A8                           569  
000007A8                           570  * do illegal direct error
000007A8                           571  
000007A8                           572  lab_ider
000007A8  702C                     573      moveq   #$2c,d0         * error code $16*2 "Illegal direct" error
000007AA  602A                     574      bra.s   lab_xerr        * do error #d0, then warm start
000007AC                           575  
000007AC                           576  * do divide by zero error
000007AC                           577  
000007AC                           578  lab_dzer
000007AC  7028                     579      moveq   #$28,d0         * error code $14*2 "Divide by zero" error
000007AE  6026                     580      bra.s   lab_xerr        * do error #d0, then warm start
000007B0                           581  
000007B0                           582  * do double dimension error
000007B0                           583  
000007B0                           584  lab_dder
000007B0  7024                     585      moveq   #$24,d0         * set error $12*2 "Double dimension" error
000007B2  6022                     586      bra.s   lab_xerr        * do error #d0, then warm start
000007B4                           587  
000007B4                           588  * do array bounds error
000007B4                           589  
000007B4                           590  lab_aber
000007B4  7020                     591      moveq   #$20,d0         * error code $10*2 "Array bounds" error
000007B6  601E                     592      bra.s   lab_xerr        * do error #d0, then warm start
000007B8                           593  
000007B8                           594  * do undefine satement error
000007B8                           595  
000007B8                           596  lab_user
000007B8  701C                     597      moveq   #$1c,d0         * error code $0E*2 "Undefined statement" error
000007BA  601A                     598      bra.s   lab_xerr        * do error #d0, then warm start
000007BC                           599  
000007BC                           600  * do out of memory error
000007BC                           601  
000007BC                           602  lab_omer
000007BC  7018                     603      moveq   #$18,d0         * error code $0C*2 "Out of memory" error
000007BE  6016                     604      bra.s   lab_xerr        * do error #d0, then warm start
000007C0                           605  
000007C0                           606  * do overflow error
000007C0                           607  
000007C0                           608  lab_ofer
000007C0  7014                     609      moveq   #$14,d0         * error code $0A*2 "Overflow" error
000007C2  6012                     610      bra.s   lab_xerr        * do error #d0, then warm start
000007C4                           611  
000007C4                           612  * do function call error
000007C4                           613  
000007C4                           614  lab_fcer
000007C4  7010                     615      moveq   #$10,d0         * error code $08*2 "Function call" error
000007C6  600E                     616      bra.s   lab_xerr        * do error #d0, then warm start
000007C8                           617  
000007C8                           618  * do out of data error
000007C8                           619  
000007C8                           620  lab_oder
000007C8  700C                     621      moveq   #$0c,d0         * error code $06*2 "Out of DATA" error
000007CA  600A                     622      bra.s   lab_xerr        * do error #d0, then warm start
000007CC                           623  
000007CC                           624  * do return without gosub error
000007CC                           625  
000007CC                           626  lab_rger
000007CC  7008                     627      moveq   #$08,d0         * error code $04*2 "RETURN without GOSUB" error
000007CE  6006                     628      bra.s   lab_xerr        * do error #d0, then warm start
000007D0                           629  
000007D0                           630  * do syntax error
000007D0                           631  
000007D0                           632  lab_sner
000007D0  7004                     633      moveq   #$04,d0         * error code $02*2 "Syntax" error
000007D2  6002                     634      bra.s   lab_xerr        * do error #d0, then warm start
000007D4                           635  
000007D4                           636  * do next without for error
000007D4                           637  
000007D4                           638  lab_nfer
000007D4  7000                     639      moveq   #$00,d0         * else set error $00 "NEXT without FOR" error
000007D6                           640  
000007D6                           641  * do error #d0, then warm start
000007D6                           642  
000007D6                           643  lab_xerr
000007D6  3E00                     644      move.w  d0,d7           * copy word
000007D8  6100 02BE                645      bsr lab_1491        * flush stack & clear continue flag
000007DC  6100 0844                646      bsr lab_crlf        * print CR/LF
000007E0  43FA 31C2                647      lea (lab_baer,pc),a1    * start of error message pointer table
000007E4  2071 7000                648      movea.l (a1,d7.w),a0        * get error message address
000007E8  6100 089A                649      bsr lab_18c3        * print null terminated string from memory
000007EC  41FA 34DE                650      lea (lab_emsg,pc),a0    * point to " Error" message
000007F0                           651  lab_1269
000007F0  6100 0892                652      bsr lab_18c3        * print null terminated string from memory
000007F4  2039 00040456            653      move.l  clinel,d0       * get current line
000007FA  6B04                     654      bmi.s   lab_1274        * go do warm start if -ve # (was immediate mode)
000007FC                           655  
000007FC                           656                      * else print line number
000007FC  6100 1E6E                657      bsr lab_2953        * print " in line [LINE #]"
00000800                           658  
00000800                           659  * BASIC warm start entry point, wait for Basic command
00000800                           660  
00000800                           661  lab_1274
00000800  41FA 34FD                662      lea (lab_rmsg,pc),a0    * point to "Ready" message
00000804  6100 087E                663      bsr lab_18c3        * go do print string
00000808                           664  
00000808                           665  * wait for Basic command (no "Ready")
00000808                           666  
00000808                           667  lab_127d
00000808  72FF                     668      moveq   #-1,d1          * set  to -1
0000080A  23C1 00040456            669      move.l  d1,clinel       * set current line #
00000810  13C1 000405E4            670      move.b  d1,breakf       * set break flag
00000816  2A7C 00040494            671      move.l  #ibuffs,a5      * set basic execute pointer ready for new line
0000081C                           672  lab_127e
0000081C  6100 00EE                673      bsr lab_1357        * call for BASIC input
00000820  6100 0CE2                674      bsr lab_gbyt        * scan memory
00000824  67F6                     675      beq.s   lab_127e        * loop while null
00000826                           676  
00000826                           677  * got to interpret input line now ....
00000826                           678  
00000826  650A                     679      bcs.s   lab_1295        * branch if numeric character (handle new BASIC line)
00000828                           680  
00000828                           681                      * no line number, immediate mode, a5 is buffer start
00000828  6100 0128                682      bsr lab_13a6        * crunch keywords into Basic tokens
0000082C                           683                      * crunch from (a5), output to (a0)
0000082C                           684                      * returns ..
0000082C                           685                      * d2 is length, d1 trashed, d0 trashed, a1 trashed
0000082C                           686  
0000082C  C14D                     687      exg a0,a5           * set execute pointer to buffer
0000082E  6000 03D2                688      bra lab_15f6        * go scan & interpret code
00000832                           689  
00000832                           690  * handle new BASIC line
00000832                           691  
00000832                           692  lab_1295
00000832  6100 0640                693      bsr lab_gfpn        * get fixed-point number into temp integer
00000836  6100 011A                694      bsr lab_13a6        * crunch keywords into Basic tokens
0000083A                           695                      * crunch from (a5), output to (a0)
0000083A                           696                      * returns ..
0000083A                           697                      * d2 is length, d1 trashed, d0 trashed, a1 trashed
0000083A  6100 01F4                698      bsr lab_ssln        * search BASIC for temp integer line number
0000083E                           699                      * returns pointer in a0
0000083E  6534                     700      bcs.s   lab_12e6        * branch if not found
00000840                           701  
00000840                           702                      * aroooogah! line # already exists! delete it
00000840  2250                     703      movea.l (a0),a1         * get start of block (next line pointer)
00000842  2039 00040436            704      move.l  sfncl,d0        * get end of block (start of functions)
00000848  9089                     705      sub.l   a1,d0           * subtract start of block ( = bytes to move)
0000084A  E288                     706      lsr.l   #1,d0           * /2 (word move)
0000084C  5340                     707      subq.w  #1,d0           * adjust for DBF loop
0000084E  2448                     708      movea.l a0,a2           * copy destination
00000850                           709  lab_12b0
00000850  34D9                     710      move.w  (a1)+,(a2)+     * copy word
00000852  51C8 FFFC                711      dbf d0,lab_12b0     * loop until done
00000856                           712  
00000856  23CA 00040436            713      move.l  a2,sfncl        * start of functions
0000085C  23CA 0004043A            714      move.l  a2,svarl        * save start of variables
00000862  23CA 0004043E            715      move.l  a2,sstrl        * start of strings
00000868  23CA 00040442            716      move.l  a2,sarryl       * save start of arrays
0000086E  23CA 00040446            717      move.l  a2,earryl       * save end of arrays
00000874                           718  
00000874                           719                      * got new line in buffer and no existing same #
00000874                           720  lab_12e6
00000874  1039 00040494            721      move.b  ibuffs,d0       * get byte from start of input buffer
0000087A  6770                     722      beq.s   lab_1325        * if null line go do line chaining
0000087C                           723  
0000087C                           724                      * got new line and it isn't empty line
0000087C  2279 00040436            725      movea.l sfncl,a1        * get start of functions (end of block to move)
00000882  2449                     726      move.l  a1,a2           * copy it
00000884  D4C2                     727      adda.w  d2,a2           * add offset to destination (line length)
00000886  504A                     728      addq.w  #8,a2           * add room for pointer and line #
00000888                           729  
00000888  23CA 00040436            730      move.l  a2,sfncl        * start of functions
0000088E  23CA 0004043A            731      move.l  a2,svarl        * save start of variables
00000894  23CA 0004043E            732      move.l  a2,sstrl        * start of strings
0000089A  23CA 00040442            733      move.l  a2,sarryl       * save start of arrays
000008A0  23CA 00040446            734      move.l  a2,earryl       * save end of arrays
000008A6  23F9 0004044E 0004044A   735      move.l  ememl,sstorl        * copy end of mem to start of strings (clear strings)
000008B0                           736  
000008B0  2209                     737      move.l  a1,d1           * copy end of block to move
000008B2  9288                     738      sub.l   a0,d1           * subtract start of block to move
000008B4  E289                     739      lsr.l   #1,d1           * /2 (word copy)
000008B6  5381                     740      subq.l  #1,d1           * correct for loop end on -1
000008B8                           741  lab_1301
000008B8  3521                     742      move.w  -(a1),-(a2)     * decrement pointers and copy word
000008BA  51C9 FFFC                743      dbf d1,lab_1301     * decrement & loop
000008BE                           744  
000008BE  227C 00040494            745      movea.l #ibuffs,a1      * source is input buffer
000008C4  2448                     746      movea.l a0,a2           * copy destination
000008C6  72FF                     747      moveq   #-1,d1          * set to allow re-chaining
000008C8  24C1                     748      move.l  d1,(a2)+        * set next line pointer (allow re-chaining)
000008CA  24F9 0004042E            749      move.l  itemp,(a2)+     * save line number
000008D0  E24A                     750      lsr.w   #1,d2           * /2 (word copy)
000008D2  5342                     751      subq.w  #1,d2           * correct for loop end on -1
000008D4                           752  lab_1303
000008D4  34D9                     753      move.w  (a1)+,(a2)+     * copy word
000008D6  51CA FFFC                754      dbf d2,lab_1303     * decrement & loop
000008DA                           755  
000008DA  6010                     756      bra.s   lab_1325        * go test for end of prog
000008DC                           757  
000008DC                           758  * rebuild chaining of Basic lines
000008DC                           759  
000008DC                           760  lab_132e
000008DC  5048                     761      addq.w  #8,a0           * point to first code byte of line, there is always
000008DE                           762                      * 1 byte + [EOL] as null entries are deleted
000008DE                           763  lab_1330
000008DE  4A18                     764      tst.b   (a0)+           * test byte
000008E0  66FC                     765      bne.s   lab_1330        * loop if not [EOL]
000008E2                           766  
000008E2                           767                      * was [EOL] so get next line start
000008E2  3208                     768      move.w  a0,d1           * past pad byte(s)
000008E4  0241 0001                769      andi.w  #1,d1           * mask odd bit
000008E8  D0C1                     770      add.w   d1,a0           * add back to ensure even
000008EA  2288                     771      move.l  a0,(a1)         * save next line pointer to current line
000008EC                           772  lab_1325
000008EC  2248                     773      movea.l a0,a1           * copy pointer for this line
000008EE  4A90                     774      tst.l   (a0)            * test pointer to next line
000008F0  66EA                     775      bne.s   lab_132e        * not end of program yet so we must
000008F2                           776                      * go and fix the pointers
000008F2                           777  
000008F2  6100 0170                778      bsr lab_1477        * reset execution to start, clear vars & flush stack
000008F6  6000 FF10                779      bra lab_127d        * now we just wait for Basic command (no "Ready")
000008FA                           780  
000008FA                           781  * receive line from keyboard
000008FA                           782                      * $08 as delete key (BACKSPACE on standard keyboard)
000008FA                           783  lab_134b
000008FA  6100 07A2                784      bsr lab_prna        * go print the character
000008FE  5341                     785      subq.w  #$01,d1         * decrement the buffer index (delete)
00000900  6012                     786      bra.s   lab_1359        * re-enter loop
00000902                           787  
00000902                           788  * print "? " and get BASIC input
00000902                           789  * return a0 pointing to the buffer start
00000902                           790  
00000902                           791  lab_inln
00000902  6100 0798                792      bsr lab_18e3        * print "?" character
00000906  7020                     793      moveq   #' ',d0         * load " "
00000908  6100 0794                794      bsr lab_prna        * go print
0000090C                           795  
0000090C                           796  * call for BASIC input (main entry point)
0000090C                           797  * return a0 pointing to the buffer start
0000090C                           798  
0000090C                           799  lab_1357
0000090C  7200                     800      moveq   #$00,d1         * clear buffer index
0000090E  207C 00040494            801      movea.l #ibuffs,a0      * set buffer base pointer
00000914                           802  lab_1359
00000914  4EB9 0004040C            803      jsr v_inpt          * call scan input device
0000091A  64F8                     804      bcc.s   lab_1359        * loop if no byte
0000091C                           805  
0000091C  67F6                     806      beq.s   lab_1359        * loop if null byte
0000091E                           807  
0000091E  B03C 0007                808      cmp.b   #$07,d0         * compare with [BELL]
00000922  6718                     809      beq.s   lab_1378        * branch if [BELL]
00000924                           810  
00000924  B03C 000D                811      cmp.b   #$0d,d0         * compare with [CR]
00000928  6700 06F2                812      beq lab_1866        * do CR/LF exit if [CR]
0000092C                           813  
0000092C  4A41                     814      tst.w   d1          * set flags on buffer index
0000092E  6606                     815      bne.s   lab_1374        * branch if not empty
00000930                           816  
00000930                           817                      * next two lines ignore any non print character
00000930                           818                      * & [SPACE] if the input buffer is empty
00000930  B03C 0021                819      cmp.b   #' '+1,d0       * compare with [SP]+1
00000934  65DE                     820      bcs.s   lab_1359        * if < ignore character
00000936                           821  
00000936                           822  lab_1374
00000936  B03C 0008                823      cmp.b   #$08,d0         * compare with [BACKSPACE] (delete last character)
0000093A  67BE                     824      beq.s   lab_134b        * go delete last character
0000093C                           825  
0000093C                           826  lab_1378
0000093C  B27C 00FF                827      cmp.w   #(ibuffe-ibuffs-1),d1   * compare character count with max-1
00000940  640C                     828      bcc.s   lab_138e        * skip store & do [BELL] if buffer full
00000942                           829  
00000942  1180 1000                830      move.b  d0,(a0,d1.w)        * else store in buffer
00000946  5241                     831      addq.w  #$01,d1         * increment index
00000948                           832  lab_137f
00000948  6100 0754                833      bsr lab_prna        * go print the character
0000094C  60C6                     834      bra.s   lab_1359        * always loop for next character
0000094E                           835  
0000094E                           836  * announce buffer full
0000094E                           837  
0000094E                           838  lab_138e
0000094E  7007                     839      moveq   #$07,d0         * [BELL] character into d0
00000950  60F6                     840      bra.s   lab_137f        * go print the [BELL] but ignore input character
00000952                           841  
00000952                           842  * crunch keywords into Basic tokens
00000952                           843  * crunch from (a5), output to (a0)
00000952                           844  * returns ..
00000952                           845  * d2 is length
00000952                           846  * d1 trashed
00000952                           847  * d0 trashed
00000952                           848  * a1 trashed
00000952                           849  
00000952                           850  * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
00000952                           851  * old list search
00000952                           852  
00000952                           853  lab_13a6
00000952  7200                     854      moveq   #$00,d1         * set read index
00000954  3401                     855      move.w  d1,d2           * set save index
00000956  13C1 000405E5            856      move.b  d1,oquote       * clear open quote/DATA flag
0000095C                           857  lab_13ac
0000095C  7000                     858      moveq   #0,d0           * clear word
0000095E  1035 1000                859      move.b  (a5,d1.w),d0        * get byte from input buffer
00000962  675E                     860      beq.s   lab_13ec        * if null save byte then continue crunching
00000964                           861  
00000964  B03C 005F                862      cmp.b   #'_',d0         * compare with "_"
00000968  6458                     863      bcc.s   lab_13ec        * if >= "_" save byte then continue crunching
0000096A                           864  
0000096A  B03C 003C                865      cmp.b   #'<',d0         * compare with "<"
0000096E  641A                     866      bcc.s   lab_13cc        * if >= "<" go crunch
00000970                           867  
00000970  B03C 0030                868      cmp.b   #'0',d0         * compare with "0"
00000974  644C                     869      bcc.s   lab_13ec        * if >= "0" save byte then continue crunching
00000976                           870  
00000976  13C0 000405E2            871      move.b  d0,asrch        * save buffer byte as search character
0000097C  B03C 0022                872      cmp.b   #$22,d0         * is it quote character?
00000980  6700 007A                873      beq lab_1410        * branch if so (copy quoted string)
00000984                           874  
00000984  B03C 002A                875      cmp.b   #'*',d0         * compare with "*"
00000988  6538                     876      bcs.s   lab_13ec        * if <= "*" save byte then continue crunching
0000098A                           877  
0000098A                           878                      * crunch rest
0000098A                           879  lab_13cc
0000098A  0839 0006 000405E5       880      btst.b  #6,oquote       * test open quote/DATA token flag
00000992  662E                     881      bne.s   lab_13ec        * branch if b6 of Oquote set (was DATA)
00000994                           882                      * go save byte then continue crunching
00000994                           883  
00000994  0400 002A                884      sub.b   #$2a,d0         * normalise byte
00000998  D040                     885      add.w   d0,d0           * *2 makes word offset (high byte=$00)
0000099A  43FA 2E16                886      lea (tab_chrt,pc),a1    * get keyword offset table address
0000099E  3031 0000                887      move.w  (a1,d0.w),d0        * get offset into keyword table
000009A2  6B74                     888      bmi.s   lab_141f        * branch if no keywords for character
000009A4                           889  
000009A4  43FA 31A7                890      lea (tab_star,pc),a1    * get keyword table address
000009A8  D2C0                     891      adda.w  d0,a1           * add keyword offset
000009AA  76FF                     892      moveq   #-1,d3          * clear index
000009AC  3801                     893      move.w  d1,d4           * copy read index
000009AE                           894  lab_13d6
000009AE  5243                     895      addq.w  #1,d3           * increment table index
000009B0  1031 3000                896      move.b  (a1,d3.w),d0        * get byte from table
000009B4                           897  lab_13d8
000009B4  6B0A                     898      bmi.s   lab_13ea        * branch if token (save token and continue crunching)
000009B6                           899  
000009B6  5244                     900      addq.w  #1,d4           * increment read index
000009B8  B035 4000                901      cmp.b   (a5,d4.w),d0        * compare byte from input buffer
000009BC  67F0                     902      beq.s   lab_13d6        * loop if character match
000009BE                           903  
000009BE  6046                     904      bra.s   lab_1417        * branch if no match
000009C0                           905  
000009C0                           906  lab_13ea
000009C0  3204                     907      move.w  d4,d1           * update read index
000009C2                           908  lab_13ec
000009C2  1180 2000                909      move.b  d0,(a0,d2.w)        * save byte to output
000009C6  5242                     910      addq.w  #1,d2           * increment buffer save index
000009C8  5241                     911      addq.w  #1,d1           * increment buffer read index
000009CA  4A00                     912      tst.b   d0          * set flags
000009CC  6750                     913      beq.s   lab_142a        * branch if was null [EOL]
000009CE                           914  
000009CE                           915                      * d0 holds token or byte here
000009CE  0400 003A                916      sub.b   #$3a,d0         * subtract ":"
000009D2  6706                     917      beq.s   lab_13ff        * branch if it was ":" (is now $00)
000009D4                           918  
000009D4                           919                      * d0 now holds token-$3A
000009D4  B03C 0049                920      cmp.b   #(tk_data-$3a),d0   * compare with DATA token - $3A
000009D8  6606                     921      bne.s   lab_1401        * branch if not DATA
000009DA                           922  
000009DA                           923                      * token was : or DATA
000009DA                           924  lab_13ff
000009DA  13C0 000405E5            925      move.b  d0,oquote       * save token-$3A ($00 for ":", TK_DATA-$3A for DATA)
000009E0                           926  lab_1401
000009E0  0400 0055                927      sub.b   #(tk_rem-$3a),d0    * subtract REM token offset
000009E4  6600 FF76                928      bne lab_13ac        * If wasn't REM then go crunch rest of line
000009E8                           929  
000009E8  13C0 000405E2            930      move.b  d0,asrch        * else was REM so set search for [EOL]
000009EE                           931  
000009EE                           932                      * loop for REM, "..." etc.
000009EE                           933  lab_1408
000009EE  1035 1000                934      move.b  (a5,d1.w),d0        * get byte from input buffer
000009F2  67CE                     935      beq.s   lab_13ec        * branch if null [EOL]
000009F4                           936  
000009F4  B039 000405E2            937      cmp.b   asrch,d0        * compare with stored character
000009FA  67C6                     938      beq.s   lab_13ec        * branch if match (end quote, REM, :, or DATA)
000009FC                           939  
000009FC                           940                      * entry for copy string in quotes, don't crunch
000009FC                           941  lab_1410
000009FC  1180 2000                942      move.b  d0,(a0,d2.w)        * save byte to output
00000A00  5242                     943      addq.w  #1,d2           * increment buffer save index
00000A02  5241                     944      addq.w  #1,d1           * increment buffer read index
00000A04  60E8                     945      bra.s   lab_1408        * loop
00000A06                           946  
00000A06                           947                      * not found keyword this go
00000A06                           948                      * so find the end of this word in the table
00000A06                           949  lab_1417
00000A06  3801                     950      move.w  d1,d4           * reset read pointer
00000A08                           951  lab_141b
00000A08  5243                     952      addq.w  #1,d3           * increment keyword table pointer (flag unchanged)
00000A0A  1031 3000                953      move.b  (a1,d3.w),d0        * get keyword table byte
00000A0E  6AF8                     954      bpl.s   lab_141b        * if not end of keyword go do next byte
00000A10                           955  
00000A10  5243                     956      addq.w  #1,d3           * increment keyword table pointer (flag unchanged)
00000A12  1031 3000                957      move.b  (a1,d3.w),d0        * get keyword table byte
00000A16  669C                     958      bne.s   lab_13d8        * go test next word if not zero byte (table end)
00000A18                           959  
00000A18                           960                      * reached end of table with no match
00000A18                           961  lab_141f
00000A18  1035 1000                962      move.b  (a5,d1.w),d0        * restore byte from input buffer
00000A1C  60A4                     963      bra.s   lab_13ec        * go save byte in output and continue crunching
00000A1E                           964  
00000A1E                           965                      * reached [EOL]
00000A1E                           966  lab_142a
00000A1E  7000                     967      moveq   #0,d0           * ensure longword clear
00000A20  0102                     968      btst    d0,d2           * test odd bit (fastest)
00000A22  6706                     969      beq.s   lab_142c        * branch if no bytes to fill
00000A24                           970  
00000A24  1180 2000                971      move.b  d0,(a0,d2.w)        * clear next byte
00000A28  5242                     972      addq.w  #1,d2           * increment buffer save index
00000A2A                           973  lab_142c
00000A2A  2180 2000                974      move.l  d0,(a0,d2.w)        * clear next line pointer (EOT in immediate mode)
00000A2E  4E75                     975      rts
00000A30                           976  
00000A30                           977  * search Basic for temp integer line number from start of mem
00000A30                           978  
00000A30                           979  lab_ssln
00000A30  2079 00040432            980      movea.l smeml,a0        * get start of program mem
00000A36                           981  
00000A36                           982  * search Basic for temp integer line number from a0
00000A36                           983  * returns Cb=0 if found
00000A36                           984  * returns a0 pointer to found or next higher (not found) line
00000A36                           985  
00000A36                           986  lab_shln
00000A36  2239 0004042E            987      move.l  itemp,d1        * get required line #
00000A3C  6002                     988      bra.s   lab_scln        * go search for required line from a0
00000A3E                           989  
00000A3E                           990  lab_145f
00000A3E  2040                     991      movea.l d0,a0           * copy next line pointer
00000A40                           992  lab_scln
00000A40  2018                     993      move.l  (a0)+,d0        * get next line pointer and point to line #
00000A42  6708                     994      beq.s   lab_145e        * is end marker so we're done, do 'no line' exit
00000A44                           995  
00000A44  B290                     996      cmp.l   (a0),d1         * compare this line # with required line #
00000A46  6EF6                     997      bgt.s   lab_145f        * loop if required # > this #
00000A48                           998  
00000A48  5948                     999      subq.w  #4,a0           * adjust pointer, flags not changed
00000A4A  4E75                    1000      rts
00000A4C                          1001  
00000A4C                          1002  lab_145e
00000A4C  5948                    1003      subq.w  #4,a0           * adjust pointer, flags not changed
00000A4E  5380                    1004      subq.l  #1,d0           * make end program found = -1, set carry
00000A50  4E75                    1005      rts
00000A52                          1006  
00000A52                          1007  * perform NEW
00000A52                          1008  
00000A52                          1009  lab_new
00000A52  6662                    1010      bne.s   rts_005         * exit if not end of statement (do syntax error)
00000A54                          1011  
00000A54                          1012  lab_1463
00000A54  2079 00040432           1013      movea.l smeml,a0        * point to start of program memory
00000A5A  7000                    1014      moveq   #0,d0           * clear longword
00000A5C  20C0                    1015      move.l  d0,(a0)+        * clear first line, next line pointer
00000A5E  23C8 00040436           1016      move.l  a0,sfncl        * set start of functions
00000A64                          1017  
00000A64                          1018  * reset execution to start, clear vars & flush stack
00000A64                          1019  
00000A64                          1020  lab_1477
00000A64  2A79 00040432           1021      movea.l smeml,a5        * reset BASIC execute pointer
00000A6A  534D                    1022      subq.w  #$01,a5         * -1 (as end of previous line)
00000A6C                          1023  
00000A6C                          1024  * "CLEAR" command gets here
00000A6C                          1025  
00000A6C                          1026  lab_147a
00000A6C  23F9 0004044E 0004044A  1027      move.l  ememl,sstorl        * save end of mem as bottom of string space
00000A76  2039 00040436           1028      move.l  sfncl,d0        * get start of functions
00000A7C  23C0 0004043A           1029      move.l  d0,svarl        * start of variables
00000A82  23C0 0004043E           1030      move.l  d0,sstrl        * start of strings
00000A88  23C0 00040442           1031      move.l  d0,sarryl       * set start of arrays
00000A8E  23C0 00040446           1032      move.l  d0,earryl       * set end of arrays
00000A94  6100 01F8               1033      bsr lab_161a        * perform RESTORE command
00000A98                          1034  
00000A98                          1035  * flush stack & clear continue flag
00000A98                          1036  
00000A98                          1037  lab_1491
00000A98  287C 00040492           1038      movea.l #des_sk,a4      * reset descriptor stack pointer
00000A9E                          1039  
00000A9E  201F                    1040      move.l  (sp)+,d0        * pull return address
00000AA0  2E79 0004042A           1041      movea.l entry_sp,sp     * flush stack
00000AA6  2F00                    1042      move.l  d0,-(sp)        * restore return address
00000AA8                          1043  
00000AA8  7000                    1044      moveq   #0,d0           * clear longword
00000AAA  23C0 0004045E           1045      move.l  d0,cpntrl       * clear continue pointer
00000AB0  13C0 000405E7           1046      move.b  d0,sufnxf       * clear subscript/FNX flag
00000AB6                          1047  rts_005
00000AB6  4E75                    1048      rts
00000AB8                          1049  
00000AB8                          1050  * perform CLEAR
00000AB8                          1051  
00000AB8                          1052  lab_clear
00000AB8  67B2                    1053      beq.s   lab_147a        * if no following byte go do "CLEAR"
00000ABA                          1054  
00000ABA  4E75                    1055      rts             * was following byte (go do syntax error)
00000ABC                          1056  
00000ABC                          1057  * perform LIST [n][-m]
00000ABC                          1058  
00000ABC                          1059  lab_list
00000ABC  6306                    1060      bls.s   lab_14bd        * branch if next character numeric (LIST n...)
00000ABE                          1061                      * or if next character [NULL] (LIST)
00000ABE                          1062  
00000ABE  B03C 00B2               1063      cmp.b   #tk_minus,d0        * compare with token for -
00000AC2  66F2                    1064      bne.s   rts_005         * exit if not - (LIST -m)
00000AC4                          1065  
00000AC4                          1066                      * LIST [[n][-m]]
00000AC4                          1067                      * this sets the n, if present, as the start & end
00000AC4                          1068  lab_14bd
00000AC4  6100 03AE               1069      bsr lab_gfpn        * get fixed-point number into temp integer
00000AC8  6100 FF66               1070      bsr lab_ssln        * search BASIC for temp integer line number
00000ACC                          1071                      * (pointer in a0)
00000ACC  6100 0A36               1072      bsr lab_gbyt        * scan memory
00000AD0  6718                    1073      beq.s   lab_14d4        * branch if no more characters
00000AD2                          1074  
00000AD2                          1075                      * this bit checks the - is present
00000AD2  B03C 00B2               1076      cmp.b   #tk_minus,d0        * compare with token for -
00000AD6  66DE                    1077      bne.s   rts_005         * return if not "-" (will be Syntax error)
00000AD8                          1078  
00000AD8                          1079                      * LIST [n]-m
00000AD8                          1080                      * the - was there so set m as the end value
00000AD8  6100 0A28               1081      bsr lab_igby        * increment & scan memory
00000ADC  6100 0396               1082      bsr lab_gfpn        * get fixed-point number into temp integer
00000AE0  6608                    1083      bne.s   lab_14d4        * branch if was not zero
00000AE2                          1084  
00000AE2  72FF                    1085      moveq   #-1,d1          * set end for $FFFFFFFF
00000AE4  23C1 0004042E           1086      move.l  d1,itemp        * save Itemp
00000AEA                          1087  lab_14d4
00000AEA  13FC 0000 000405E5      1088      move.b  #$00,oquote     * clear open quote flag
00000AF2  6100 052E               1089      bsr lab_crlf        * print CR/LF
00000AF6  2258                    1090      movea.l (a0)+,a1        * get next line pointer
00000AF8  2009                    1091      move.l  a1,d0           * copy to set the flags
00000AFA  67BA                    1092      beq.s   rts_005         * if null all done so exit
00000AFC                          1093  
00000AFC  6100 014C               1094      bsr lab_1629        * do CRTL-C check vector
00000B00                          1095  
00000B00  2018                    1096      move.l  (a0)+,d0        * get this line #
00000B02  2239 0004042E           1097      move.l  itemp,d1        * get end line #
00000B08  6704                    1098      beq.s   lab_14e2        * if end=0 list whole thing
00000B0A                          1099  
00000B0A  B280                    1100      cmp.l   d0,d1           * compare this line # with end line #
00000B0C  65A8                    1101      bcs.s   rts_005         * if greater all done so exit
00000B0E                          1102  
00000B0E                          1103  lab_14e2
00000B0E  48E7 78C0               1104      movem.l a0-a1/d1-d4,-(sp)   * save registers !! work out what's needed here !!
00000B12  6100 1B66               1105      bsr lab_295e        * print d0 as unsigned integer
00000B16  4CDF 031E               1106      movem.l (sp)+,a0-a1/d1-d4   * restore registers !! and here !!
00000B1A  7020                    1107      moveq   #$20,d0         * space is the next character
00000B1C                          1108  lab_150c
00000B1C  6100 0580               1109      bsr lab_prna        * go print the character
00000B20  B03C 0022               1110      cmp.b   #$22,d0         * was it " character
00000B24  6608                    1111      bne.s   lab_1519        * branch if not
00000B26                          1112  
00000B26                          1113                      * we're either entering or leaving quotes
00000B26  0A39 00FF 000405E5      1114      eor.b   #$ff,oquote     * toggle open quote flag
00000B2E                          1115  lab_1519
00000B2E  1018                    1116      move.b  (a0)+,d0        * get byte and increment pointer
00000B30  6608                    1117      bne.s   lab_152e        * branch if not [EOL] (go print)
00000B32                          1118  
00000B32                          1119                      * was [EOL]
00000B32  2049                    1120      movea.l a1,a0           * copy next line pointer
00000B34  2008                    1121      move.l  a0,d0           * copy to set flags
00000B36  66B2                    1122      bne.s   lab_14d4        * go do next line if not [EOT]
00000B38                          1123  
00000B38  4E75                    1124      rts
00000B3A                          1125  
00000B3A                          1126  lab_152e
00000B3A  6AE0                    1127      bpl.s   lab_150c        * just go print it if not token byte
00000B3C                          1128  
00000B3C                          1129                      * else was token byte so uncrunch it (maybe)
00000B3C  0839 0007 000405E5      1130      btst.b  #7,oquote       * test the open quote flag
00000B44  66D6                    1131      bne.s   lab_150c        * just go print character if open quote set
00000B46                          1132  
00000B46                          1133                      * else uncrunch BASIC token
00000B46  45FA 2CD4               1134      lea (lab_keyt,pc),a2    * get keyword table address
00000B4A  727F                    1135      moveq   #$7f,d1         * mask into d1
00000B4C  C200                    1136      and.b   d0,d1           * copy and mask token
00000B4E  E549                    1137      lsl.w   #2,d1           * *4
00000B50  45F2 1000               1138      lea (a2,d1.w),a2        * get keyword entry address
00000B54  101A                    1139      move.b  (a2)+,d0        * get byte from keyword table
00000B56  6100 0546               1140      bsr lab_prna        * go print the first character
00000B5A  7200                    1141      moveq   #0,d1           * clear d1
00000B5C  121A                    1142      move.b  (a2)+,d1        * get remaining length byte from keyword table
00000B5E  6BCE                    1143      bmi.s   lab_1519        * if -ve done so go get next byte
00000B60                          1144  
00000B60  3012                    1145      move.w  (a2),d0         * get offset to rest
00000B62  45FA 2FE9               1146      lea (tab_star,pc),a2    * get keyword table address
00000B66  45F2 0000               1147      lea (a2,d0.w),a2        * get address of rest
00000B6A                          1148  lab_1540
00000B6A  101A                    1149      move.b  (a2)+,d0        * get byte from keyword table
00000B6C  6100 0530               1150      bsr lab_prna        * go print the character
00000B70  51C9 FFF8               1151      dbf d1,lab_1540     * decrement and loop if more to do
00000B74                          1152  
00000B74  60B8                    1153      bra.s   lab_1519        * go get next byte
00000B76                          1154  
00000B76                          1155  * perform FOR
00000B76                          1156  
00000B76                          1157  lab_for
00000B76  6100 03AC               1158      bsr lab_let         * go do LET
00000B7A  6100 FBB4               1159      bsr lab_11a1        * search the stack for FOR or GOSUB activity
00000B7E                          1160                      * exit with z=1 if FOR else exit with z=0
00000B7E                          1161                      * return modified stack in a2
00000B7E  6604                    1162      bne.s   lab_1567        * branch if FOR (this variable) not found
00000B80                          1163  
00000B80                          1164                      * FOR (this variable) was found so first
00000B80                          1165                      * we dump the old one
00000B80  DEFC 0016               1166      adda.w  #22,sp          * reset stack (dump FOR structure (-4 bytes))
00000B84                          1167  lab_1567
00000B84  584F                    1168      addq.w  #4,sp           * dump return address
00000B86                          1169  *   moveq   #28,d0          * we need 28 bytes !
00000B86                          1170  *   bsr.s   lab_1212        * check room on stack for d0 bytes
00000B86  6100 0270               1171      bsr lab_snbs        * scan for next BASIC statement ([:] or [EOL])
00000B8A                          1172                      * returns a0 as pointer to [:] or [EOL]
00000B8A  2F08                    1173      move.l  a0,-(sp)        * push onto stack
00000B8C  2F39 00040456           1174      move.l  clinel,-(sp)        * push current line onto stack
00000B92                          1175  
00000B92  70A9                    1176      moveq   #tk_to-$100,d0      * set "TO" token
00000B94  6100 0966               1177      bsr lab_scca        * scan for CHR$(d0) , else syntax error/warm start
00000B98  6100 078C               1178      bsr lab_ctnm        * check if source is numeric, else type mismatch
00000B9C  1F39 000405BD           1179      move.b  dtypef,-(sp)        * push FOR variable data type onto stack
00000BA2  6100 0780               1180      bsr lab_evnm        * evaluate expression & check is numeric, else
00000BA6                          1181                      * do type mismatch
00000BA6                          1182  
00000BA6  2F39 00040594           1183      move.l  fac1_m,-(sp)        * push TO value mantissa
00000BAC  3F39 00040598           1184      move.w  fac1_e,-(sp)        * push TO value exponent and sign
00000BB2                          1185  
00000BB2  23FC 80000000 00040594  1186      move.l  #$80000000,fac1_m   * set default STEP size mantissa
00000BBC  33FC 8100 00040598      1187      move.w  #$8100,fac1_e       * set default STEP size exponent and sign
00000BC4                          1188  
00000BC4  6100 093E               1189      bsr lab_gbyt        * scan memory
00000BC8  B03C 00AE               1190      cmp.b   #tk_step,d0     * compare with STEP token
00000BCC  6608                    1191      bne.s   lab_15b3        * jump if not "STEP"
00000BCE                          1192  
00000BCE                          1193                      * was step so ....
00000BCE  6100 0932               1194      bsr lab_igby        * increment & scan memory
00000BD2  6100 0750               1195      bsr lab_evnm        * evaluate expression & check is numeric,
00000BD6                          1196                      * else do type mismatch
00000BD6                          1197  lab_15b3
00000BD6  2F39 00040594           1198      move.l  fac1_m,-(sp)        * push STEP value mantissa
00000BDC  3F39 00040598           1199      move.w  fac1_e,-(sp)        * push STEP value exponent and sign
00000BE2                          1200  
00000BE2  2F39 00040476           1201      move.l  frnxtl,-(sp)        * push variable pointer for FOR/NEXT
00000BE8  3F3C 0081               1202      move.w  #tk_for,-(sp)       * push FOR token on stack
00000BEC                          1203  
00000BEC  601A                    1204      bra.s   lab_15c2        * go do interpreter inner loop
00000BEE                          1205  
00000BEE                          1206  lab_15dc                * have reached [EOL]+1
00000BEE  300D                    1207      move.w  a5,d0           * copy BASIC execute pointer
00000BF0  C07C 0001               1208      and.w   #1,d0           * and make line start address even
00000BF4  DAC0                    1209      add.w   d0,a5           * add to BASIC execute pointer
00000BF6  201D                    1210      move.l  (a5)+,d0        * get next line pointer
00000BF8  6700 FC06               1211      beq lab_1274        * if null go to immediate mode, no "BREAK" message
00000BFC                          1212                      * (was immediate or [EOT] marker)
00000BFC                          1213  
00000BFC  23DD 00040456           1214      move.l  (a5)+,clinel        * save (new) current line #
00000C02                          1215  lab_15f6
00000C02  6100 0900               1216      bsr lab_gbyt        * get BASIC byte
00000C06  611E                    1217      bsr.s   lab_15ff        * go interpret BASIC code from (a5)
00000C08                          1218  
00000C08                          1219  * interpreter inner loop entry point
00000C08                          1220  
00000C08                          1221  lab_15c2
00000C08  6140                    1222      bsr.s   lab_1629        * do CRTL-C check vector
00000C0A  4A79 00040456           1223      tst.w   clinel          * test current line #, is -ve for immediate mode
00000C10  6B06                    1224      bmi.s   lab_15d1        * branch if immediate mode
00000C12                          1225  
00000C12  23CD 0004045E           1226      move.l  a5,cpntrl       * save BASIC execute pointer as continue pointer
00000C18                          1227  lab_15d1
00000C18  101D                    1228      move.b  (a5)+,d0        * get this byte & increment pointer
00000C1A  67D2                    1229      beq.s   lab_15dc        * loop if [EOL]
00000C1C                          1230  
00000C1C  B03C 003A               1231      cmp.b   #$3a,d0         * compare with ":"
00000C20  67E0                    1232      beq.s   lab_15f6        * loop if was statement separator
00000C22                          1233  
00000C22  6000 FBAC               1234      bra lab_sner        * else syntax error, then warm start
00000C26                          1235  
00000C26                          1236  * interpret BASIC code from (a5)
00000C26                          1237  
00000C26                          1238  lab_15ff
00000C26  6774                    1239      beq.s   rts_006         * exit if zero [EOL]
00000C28                          1240  
00000C28                          1241  lab_1602
00000C28  0A00 0080               1242      eori.b  #$80,d0         * normalise token
00000C2C  6B00 02F6               1243      bmi lab_let         * if not token, go do implied LET
00000C30                          1244  
00000C30  B03C 0028               1245      cmp.b   #(tk_tab-$80),d0    * compare normalised token with TAB
00000C34  6400 FB9A               1246      bcc lab_sner        * branch if d0>=TAB, syntax error/warm start
00000C38                          1247                      * only tokens before TAB can start a statement
00000C38                          1248  
00000C38  4880                    1249      ext.w   d0          * byte to word (clear high byte)
00000C3A  D040                    1250      add.w   d0,d0           * *2
00000C3C  D040                    1251      add.w   d0,d0           * *4 (offset to longword vector)
00000C3E  41FA 29CC               1252      lea (lab_ctbl,pc),a0    * get vector table base address
00000C42  2F30 0000               1253      move.l  (a0,d0.w),-(sp)     * push vector
00000C46  6000 08BA               1254      bra lab_igby        * get following byte & execute vector
00000C4A                          1255  
00000C4A                          1256  * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00000C4A                          1257  * key press is detected.
00000C4A                          1258  
00000C4A                          1259  lab_1629
00000C4A                          1260  *   cmpa.l  #des_sk,a4      * check discriptor stack is empty
00000C4A                          1261  *   bne lab_iter        * if not do internal error
00000C4A                          1262  
00000C4A  4EF9 00040424           1263      jmp v_ctlc          * ctrl c check vector
00000C50                          1264  
00000C50                          1265  * if there was a key press it gets back here .....
00000C50                          1266  
00000C50                          1267  lab_1636
00000C50  B03C 0003               1268      cmp.b   #$03,d0         * compare with CTRL-C
00000C54  6646                    1269      bne.s   rts_006         * return if wasn't CTRL-C
00000C56                          1270  
00000C56                          1271  * perform STOP
00000C56                          1272  
00000C56                          1273  lab_stop
00000C56  6408                    1274      bcc.s   lab_163b        * branch if token follows STOP
00000C58                          1275                      * else just END
00000C58                          1276  * perform END
00000C58                          1277  
00000C58                          1278  lab_end
00000C58  13FC 0000 000405E4      1279      move.b  #0,breakf       * clear break flag, indicate program end
00000C60                          1280  lab_163b
00000C60                          1281  
00000C60  BBFC 00040594           1282      cmpa.l  #ibuffe,a5      * compare execute address with buffer end
00000C66  6510                    1283      bcs.s   lab_164f        * branch if BASIC pointer is in buffer
00000C68                          1284                      * (can't continue in immediate mode)
00000C68                          1285  
00000C68                          1286                      * else...
00000C68  23CD 0004045E           1287      move.l  a5,cpntrl       * save BASIC execute pointer as continue pointer
00000C6E                          1288  lab_1647
00000C6E  23F9 00040456 0004045A  1289      move.l  clinel,blinel       * save break line
00000C78                          1290  lab_164f
00000C78  201F                    1291      move.l  (sp)+,d0        * pull return address, don't return to execute loop
00000C7A  1039 000405E4           1292      move.b  breakf,d0       * get break flag
00000C80  6700 FB7E               1293      beq lab_1274        * go do warm start if was program end
00000C84                          1294  
00000C84  41FA 303E               1295      lea (lab_bmsg,pc),a0    * point to "Break"
00000C88  6000 FB66               1296      bra lab_1269        * print "Break" and do warm start
00000C8C                          1297  
00000C8C                          1298  * perform RESTORE
00000C8C                          1299  
00000C8C                          1300  lab_restore
00000C8C  6610                    1301      bne.s   lab_resn        * branch if next character not null (RESTORE n)
00000C8E                          1302  
00000C8E                          1303  lab_161a
00000C8E  2079 00040432           1304      movea.l smeml,a0        * copy start of mem
00000C94                          1305  lab_1624
00000C94  5348                    1306      subq.w  #1,a0           * -1
00000C96  23C8 00040466           1307      move.l  a0,dptrl        * save DATA pointer
00000C9C                          1308  rts_006
00000C9C  4E75                    1309      rts
00000C9E                          1310                      * is RESTORE n
00000C9E                          1311  lab_resn
00000C9E  6100 01D4               1312      bsr lab_gfpn        * get fixed-point number into temp integer
00000CA2  B0B9 00040456           1313      cmp.l   clinel,d0       * compare current line # with required line #
00000CA8  6310                    1314      bls.s   lab_nsch        * branch if >= (start search from beginning)
00000CAA                          1315  
00000CAA  204D                    1316      movea.l a5,a0           * copy BASIC execute pointer
00000CAC                          1317  lab_ress
00000CAC  4A18                    1318      tst.b   (a0)+           * test next byte & increment pointer
00000CAE  66FC                    1319      bne.s   lab_ress        * loop if not EOL
00000CB0                          1320  
00000CB0  3208                    1321      move.w  a0,d1           * copy pointer
00000CB2  C27C 0001               1322      and.w   #1,d1           * mask odd bit
00000CB6  D0C1                    1323      add.w   d1,a0           * add pointer
00000CB8  6006                    1324      bra.s   lab_gsch        * go find
00000CBA                          1325  
00000CBA                          1326                      * search for line in Itemp from start of memory
00000CBA                          1327  lab_nsch
00000CBA  2079 00040432           1328      movea.l smeml,a0        * get start of mem
00000CC0                          1329  
00000CC0                          1330                      * search for line in Itemp from (a0)
00000CC0                          1331  lab_gsch
00000CC0  6100 FD74               1332      bsr lab_shln        * search for temp integer line number from a0
00000CC4                          1333                      * returns Cb=0 if found
00000CC4  6500 FAF2               1334      bcs lab_user        * go do "Undefined statement" error if not found
00000CC8                          1335  
00000CC8  60CA                    1336      bra.s   lab_1624        * else save DATA pointer & return
00000CCA                          1337  
00000CCA                          1338  * perform NULL
00000CCA                          1339  
00000CCA                          1340  lab_null
00000CCA  6100 1288               1341      bsr lab_gtby        * get byte parameter, result in d0 and Itemp
00000CCE  13C0 000405ED           1342      move.b  d0,nullct       * save new NULL count
00000CD4  4E75                    1343      rts
00000CD6                          1344  
00000CD6                          1345  * perform CONT
00000CD6                          1346  
00000CD6                          1347  lab_cont
00000CD6  6600 FAF8               1348      bne lab_sner        * if following byte exit to do syntax error
00000CDA                          1349  
00000CDA  2039 0004045E           1350      move.l  cpntrl,d0       * get continue pointer
00000CE0  6700 FAB6               1351      beq lab_ccer        * go do can't continue error if we can't
00000CE4                          1352  
00000CE4                          1353                      * we can continue so ...
00000CE4  2A40                    1354      movea.l d0,a5           * save continue pointer as BASIC execute pointer
00000CE6  23F9 0004045A 00040456  1355      move.l  blinel,clinel       * set break line as current line
00000CF0  4E75                    1356      rts
00000CF2                          1357  
00000CF2                          1358  * perform RUN
00000CF2                          1359  
00000CF2                          1360  lab_run
00000CF2  6600 0010               1361      bne lab_runn        * if following byte do RUN n
00000CF6                          1362  
00000CF6  6100 FD6C               1363      bsr lab_1477        * execution to start, clear vars & flush stack
00000CFA  23CD 0004045E           1364      move.l  a5,cpntrl       * save as continue pointer
00000D00  6000 FF06               1365      bra lab_15c2        * go do interpreter inner loop
00000D04                          1366                      * (can't RTS, we flushed the stack!)
00000D04                          1367  
00000D04                          1368  lab_runn
00000D04  6100 FD66               1369      bsr lab_147a        * go do "CLEAR"
00000D08  6020                    1370      bra.s   lab_16b0        * get n and do GOTO n
00000D0A                          1371  
00000D0A                          1372  * perform DO
00000D0A                          1373  
00000D0A                          1374  lab_do
00000D0A                          1375  *   move.l  #$05,d0         * need 5 bytes for DO ##
00000D0A                          1376  *   bsr.s   lab_1212        * check room on stack for A bytes
00000D0A  2F0D                    1377      move.l  a5,-(sp)        * push BASIC execute pointer on stack
00000D0C  2F39 00040456           1378      move.l  clinel,-(sp)        * push current line on stack
00000D12  3F3C 009C               1379      move.w  #tk_do,-(sp)        * push token for DO on stack
00000D16                          1380  doagain
00000D16  6100 07EC               1381      bsr lab_gbyt        * scan memory
00000D1A  6000 FEEC               1382      bra lab_15c2        * go do interpreter inner loop
00000D1E                          1383  
00000D1E                          1384  * perform GOSUB
00000D1E                          1385  
00000D1E                          1386  lab_gosub
00000D1E                          1387  *   move.l  #10,d0          * need 10 bytes for GOSUB ##
00000D1E                          1388  *   bsr.s   lab_1212        * check room on stack for d0 bytes
00000D1E  2F0D                    1389      move.l  a5,-(sp)        * push BASIC execute pointer
00000D20  2F39 00040456           1390      move.l  clinel,-(sp)        * push current line
00000D26  3F3C 008D               1391      move.w  #tk_gosub,-(sp)     * push token for GOSUB
00000D2A                          1392  lab_16b0
00000D2A  6100 07D8               1393      bsr lab_gbyt        * scan memory
00000D2E  610C                    1394      bsr.s   lab_goto        * perform GOTO n
00000D30  6000 FED6               1395      bra lab_15c2        * go do interpreter inner loop
00000D34                          1396                      * (can't RTS, we used the stack!)
00000D34                          1397  
00000D34                          1398  * tail of IF command
00000D34                          1399  
00000D34                          1400  lab_1754
00000D34  6100 07CE               1401      bsr lab_gbyt        * scan memory, Cb=1 if "0"-"9"
00000D38  6400 FEEC               1402      bcc lab_15ff        * if not numeric interpret BASIC code from (a5)
00000D3C                          1403  
00000D3C                          1404  **  bra lab_goto        * else do GOTO n (was numeric)
00000D3C                          1405  
00000D3C                          1406  * perform GOTO
00000D3C                          1407  
00000D3C                          1408  lab_goto
00000D3C  6100 0136               1409      bsr lab_gfpn        * get fixed-point number into temp integer
00000D40                          1410  
00000D40  204D                    1411      movea.l a5,a0           * copy BASIC execute pointer
00000D42                          1412  lab_gots
00000D42  4A18                    1413      tst.b   (a0)+           * test next byte & increment pointer
00000D44  66FC                    1414      bne.s   lab_gots        * loop if not EOL
00000D46                          1415  
00000D46  3208                    1416      move.w  a0,d1           * past pad byte(s)
00000D48  C27C 0001               1417      and.w   #1,d1           * mask odd bit
00000D4C  D0C1                    1418      add.w   d1,a0           * add to pointer
00000D4E                          1419  
00000D4E  2039 00040456           1420      move.l  clinel,d0       * get current line
00000D54  6B08                    1421      bmi.s   lab_16d0        * if immediate mode start search from beginning
00000D56                          1422  
00000D56  B0B9 0004042E           1423      cmp.l   itemp,d0        * compare wanted # with current #
00000D5C  6506                    1424      bcs.s   lab_16d4        * branch if current # < wanted #
00000D5E                          1425                      * (start search from here)
00000D5E                          1426  
00000D5E                          1427  * search for line # in temp (Itemp) from start of mem pointer (Smeml)
00000D5E                          1428  
00000D5E                          1429  lab_16d0
00000D5E  2079 00040432           1430      movea.l smeml,a0        * get start of memory
00000D64                          1431  
00000D64                          1432  * search for line # in Itemp from (a0)
00000D64                          1433  
00000D64                          1434  lab_16d4
00000D64  6100 FCD0               1435      bsr lab_shln        * search for temp integer line number from a0
00000D68                          1436                      * returns Cb=0 if found
00000D68  6500 FA4E               1437      bcs lab_user        * if carry set go do "Undefined statement" error
00000D6C                          1438  
00000D6C  2A48                    1439      movea.l a0,a5           * copy to basic execute pointer
00000D6E  534D                    1440      subq.w  #1,a5           * decrement pointer
00000D70  23CD 0004045E           1441      move.l  a5,cpntrl       * save as continue pointer
00000D76  4E75                    1442      rts
00000D78                          1443  
00000D78                          1444  * perform LOOP
00000D78                          1445  
00000D78                          1446  lab_loop
00000D78  7E00                    1447      moveq   #0,d7           * clear top 24 bits
00000D7A  1E00                    1448      move.b  d0,d7           * save following token (byte)
00000D7C  6100 F9B2               1449      bsr lab_11a1        * search the stack for FOR or GOSUB activity
00000D80                          1450                      * exit with Zb=1 if FOR else exit with Zb=0
00000D80                          1451                      * return modified stack in a2
00000D80                          1452  
00000D80  B07C 009C               1453      cmp.w   #tk_do,d0       * compare with DO token
00000D84  6600 FA0A               1454      bne lab_lder        * branch if no matching DO
00000D88                          1455  
00000D88  4A07                    1456      tst.b   d7          * test saved following token
00000D8A  6732                    1457      beq.s   loopalways      * if no following token loop forever
00000D8C                          1458                      * (stack pointer in a2)
00000D8C                          1459  
00000D8C  0407 00AF               1460      sub.b   #tk_until,d7        * subtract token for UNTIL
00000D90  6708                    1461      beq.s   dorest          * branch if was UNTIL
00000D92                          1462  
00000D92  5307                    1463      subq.b  #1,d7           * decrement result
00000D94  6600 FA3A               1464      bne lab_sner        * if not WHILE go do syntax error & warm start
00000D98                          1465                      * only if the token was WHILE will this fail
00000D98                          1466  
00000D98  5307                    1467      subq.b  #1,d7           * set invert result longword
00000D9A                          1468  dorest
00000D9A  6100 0766               1469      bsr lab_igby        * increment & scan memory
00000D9E  2F0A                    1470      move.l  a2,-(sp)        * save modified stack pointer
00000DA0  6100 05A2               1471      bsr lab_evex        * evaluate expression
00000DA4  245F                    1472      movea.l (sp)+,a2        * restore modified stack pointer
00000DA6  4A39 00040598           1473      tst.b   fac1_e          * test FAC1 exponent
00000DAC  6708                    1474      beq.s   docmp           * if =0 go do straight compare
00000DAE                          1475  
00000DAE  13FC 00FF 00040598      1476      move.b  #$ff,fac1_e     * else set all bits
00000DB6                          1477  docmp
00000DB6  BF39 00040598           1478      eor.b   d7,fac1_e       * EOR with invert byte
00000DBC  6612                    1479      bne.s   loopdone        * if <> 0 clear stack & back to interpreter loop
00000DBE                          1480  
00000DBE                          1481                      * loop condition wasn't met so do it again
00000DBE                          1482  loopalways
00000DBE  23EA 0002 00040456      1483      move.l  2(a2),clinel        * copy DO current line low byte
00000DC6  2A6A 0006               1484      move.l  6(a2),a5        * save BASIC execute pointer low byte
00000DCA  584F                    1485      addq.w  #4,sp           * dump call to this routine
00000DCC  6000 FF48               1486      bra doagain         * go do DO again
00000DD0                          1487  
00000DD0                          1488                      * clear stack & back to interpreter loop
00000DD0                          1489  loopdone
00000DD0  DEFC 000E               1490      adda.w  #14,sp          * dump structure and call from stack
00000DD4  601A                    1491      bra.s   lab_data        * go perform DATA (find : or [EOL])
00000DD6                          1492  
00000DD6                          1493  * perform RETURN
00000DD6                          1494  
00000DD6                          1495  lab_return
00000DD6  661E                    1496      bne.s   rts_007         * exit if following token (to allow syntax error)
00000DD8                          1497  
00000DD8  6100 F956               1498      bsr lab_11a1        * search the stack for FOR or GOSUB activity
00000DDC                          1499                      * exit with z=1 if FOR else exit with z=0
00000DDC                          1500                      * return modified stack in a2
00000DDC  B07C 008D               1501      cmp.w   #tk_gosub,d0        * compare with GOSUB token
00000DE0  6600 F9EA               1502      bne lab_rger        * branch if no matching GOSUB
00000DE4                          1503  
00000DE4  544A                    1504      addq.w  #2,a2           * adjust for token
00000DE6  2E4A                    1505      movea.l a2,sp           * dump calling addresses & token
00000DE8  23DF 00040456           1506      move.l  (sp)+,clinel        * pull current line
00000DEE  2A5F                    1507      move.l  (sp)+,a5        * pull BASIC execute pointer
00000DF0                          1508                      * now do perform "DATA" statement as we could be
00000DF0                          1509                      * returning into the middle of an ON <var> GOSUB
00000DF0                          1510                      * n,m,p,q line (the return address used by the
00000DF0                          1511                      * DATA statement is the one pushed before the
00000DF0                          1512                      * GOSUB was executed!)
00000DF0                          1513  
00000DF0                          1514  * perform DATA
00000DF0                          1515  
00000DF0                          1516  lab_data
00000DF0  6100 0006               1517      bsr lab_snbs        * scan for next BASIC statement ([:] or [EOL])
00000DF4                          1518                      * returns a0 as pointer to [:] or [EOL]
00000DF4  2A48                    1519      movea.l a0,a5           * skip rest of statement
00000DF6                          1520  rts_007
00000DF6  4E75                    1521      rts
00000DF8                          1522  
00000DF8                          1523  * scan for next BASIC statement ([:] or [EOL])
00000DF8                          1524  * returns a0 as pointer to [:] or [EOL]
00000DF8                          1525  
00000DF8                          1526  lab_snbs
00000DF8  204D                    1527      movea.l a5,a0           * copy BASIC execute pointer
00000DFA  7222                    1528      moveq   #$22,d1         * set string quote character
00000DFC  600A                    1529      bra.s   lab_172d        * go do search
00000DFE                          1530  
00000DFE                          1531  lab_172c
00000DFE  B03C 003A               1532      cmp.b   #$3a,d0         * compare with ":"
00000E02  6708                    1533      beq.s   rts_007a        * exit if found
00000E04                          1534  
00000E04  B001                    1535      cmp.b   d1,d0           * compare current character with string quote
00000E06  670C                    1536      beq.s   lab_1725        * if found go search for [EOL]
00000E08                          1537  
00000E08                          1538  lab_172d
00000E08  1018                    1539      move.b  (a0)+,d0        * get next byte
00000E0A  66F2                    1540      bne.s   lab_172c        * loop if not null [EOL]
00000E0C                          1541  
00000E0C                          1542  rts_007a
00000E0C  5348                    1543      subq.w  #1,a0           * correct pointer
00000E0E  4E75                    1544      rts
00000E10                          1545  
00000E10                          1546  lab_1723
00000E10  B001                    1547      cmp.b   d1,d0           * compare current character with string quote
00000E12  67F4                    1548      beq.s   lab_172d        * if found go search for ":" or [EOL]
00000E14                          1549  
00000E14                          1550  lab_1725
00000E14  1018                    1551      move.b  (a0)+,d0        * get next byte
00000E16  66F8                    1552      bne.s   lab_1723        * loop if not null [EOL]
00000E18                          1553  
00000E18  60F2                    1554      bra.s   rts_007a        * correct pointer & return
00000E1A                          1555  
00000E1A                          1556  * perform IF
00000E1A                          1557  
00000E1A                          1558  lab_if
00000E1A  6100 0528               1559      bsr lab_evex        * evaluate expression
00000E1E  6100 06E4               1560      bsr lab_gbyt        * scan memory
00000E22  B03C 0089               1561      cmp.b   #tk_goto,d0     * compare with "GOTO" token
00000E26  6706                    1562      beq.s   lab_174b        * jump if was "GOTO"
00000E28                          1563  
00000E28                          1564                      * wasn't IF ... GOTO so must be IF ... THEN
00000E28  70AC                    1565      moveq   #tk_then-$100,d0    * get THEN token
00000E2A  6100 06D0               1566      bsr lab_scca        * scan for CHR$(d0), else syntax error/warm start
00000E2E                          1567  lab_174b
00000E2E  1039 00040598           1568      move.b  fac1_e,d0       * get FAC1 exponent
00000E34  6600 FEFE               1569      bne lab_1754        * branch if result was non zero
00000E38                          1570                      * else ....
00000E38                          1571  * perform REM, skip (rest of) line
00000E38                          1572  
00000E38                          1573  lab_rem
00000E38  4A1D                    1574      tst.b   (a5)+           * test byte & increment pointer
00000E3A  66FC                    1575      bne.s   lab_rem         * loop if not EOL
00000E3C                          1576  
00000E3C  534D                    1577      subq.w  #1,a5           * correct pointer
00000E3E  4E75                    1578      rts
00000E40                          1579  
00000E40                          1580  * perform ON
00000E40                          1581  
00000E40                          1582  lab_on
00000E40  6100 1112               1583      bsr lab_gtby        * get byte parameter, result in d0 and Itemp
00000E44  1400                    1584      move.b  d0,d2           * copy byte
00000E46  6100 06BC               1585      bsr lab_gbyt        * restore BASIC byte
00000E4A  3F00                    1586      move.w  d0,-(sp)        * push GOTO/GOSUB token
00000E4C  B03C 008D               1587      cmp.b   #tk_gosub,d0        * compare with GOSUB token
00000E50  6708                    1588      beq.s   lab_176c        * branch if GOSUB
00000E52                          1589  
00000E52  B03C 0089               1590      cmp.b   #tk_goto,d0     * compare with GOTO token
00000E56  6600 F978               1591      bne lab_sner        * if not GOTO do syntax error, then warm start
00000E5A                          1592  
00000E5A                          1593  * next character was GOTO or GOSUB
00000E5A                          1594  
00000E5A                          1595  lab_176c
00000E5A  5302                    1596      subq.b  #1,d2           * decrement index (byte value)
00000E5C  6606                    1597      bne.s   lab_1773        * branch if not zero
00000E5E                          1598  
00000E5E  301F                    1599      move.w  (sp)+,d0        * pull GOTO/GOSUB token
00000E60  6000 FDC6               1600      bra lab_1602        * go execute it
00000E64                          1601  
00000E64                          1602  lab_1773
00000E64  6100 069C               1603      bsr lab_igby        * increment & scan memory
00000E68  610A                    1604      bsr.s   lab_gfpn        * get fixed-point number into temp integer
00000E6A                          1605                      * (skip this n)
00000E6A  B03C 002C               1606      cmp.b   #$2c,d0         * compare next character with ","
00000E6E  67EA                    1607      beq.s   lab_176c        * loop if ","
00000E70                          1608  
00000E70  301F                    1609      move.w  (sp)+,d0        * pull GOTO/GOSUB token (run out of options)
00000E72  4E75                    1610      rts             * and exit
00000E74                          1611  
00000E74                          1612  * get fixed-point number into temp integer
00000E74                          1613  * interpret number from (a5), leave (a5) pointing to byte after #
00000E74                          1614  
00000E74                          1615  lab_gfpn
00000E74  7200                    1616      moveq   #$00,d1         * clear integer register
00000E76  2001                    1617      move.l  d1,d0           * clear d0
00000E78  6100 068A               1618      bsr lab_gbyt        * scan memory, Cb=1 if "0"-"9", & get byte
00000E7C  642E                    1619      bcc.s   lab_1786        * return if carry clear, chr was not "0"-"9"
00000E7E                          1620  
00000E7E  2F02                    1621      move.l  d2,-(sp)        * save d2
00000E80                          1622  lab_1785
00000E80  2401                    1623      move.l  d1,d2           * copy integer register
00000E82  D281                    1624      add.l   d1,d1           * *2
00000E84  6500 F94A               1625      bcs lab_sner        * if overflow do syntax error, then warm start
00000E88                          1626  
00000E88  D281                    1627      add.l   d1,d1           * *4
00000E8A  6500 F944               1628      bcs lab_sner        * if overflow do syntax error, then warm start
00000E8E                          1629  
00000E8E  D282                    1630      add.l   d2,d1           * *1 + *4
00000E90  6500 F93E               1631      bcs lab_sner        * if overflow do syntax error, then warm start
00000E94                          1632  
00000E94  D281                    1633      add.l   d1,d1           * *10
00000E96  6500 F938               1634      bcs lab_sner        * if overflow do syntax error, then warm start
00000E9A                          1635  
00000E9A  0400 0030               1636      sub.b   #$30,d0         * subtract $30 from byte
00000E9E  D280                    1637      add.l   d0,d1           * add to integer register (top 24 bits always clear)
00000EA0  6900 F92E               1638      bvs lab_sner        * if overflow do syntax error, then warm start
00000EA4                          1639                      * (makes max line # 2147483647)
00000EA4  6100 065C               1640      bsr lab_igby        * increment & scan memory
00000EA8  65D6                    1641      bcs.s   lab_1785        * loop for next character if "0"-"9"
00000EAA                          1642  
00000EAA  241F                    1643      move.l  (sp)+,d2        * restore d2
00000EAC                          1644  lab_1786
00000EAC  23C1 0004042E           1645      move.l  d1,itemp        * save Itemp
00000EB2  4E75                    1646      rts
00000EB4                          1647  
00000EB4                          1648  * perform DEC
00000EB4                          1649  
00000EB4                          1650  lab_dec
00000EB4  3F3C 8180               1651      move.w  #$8180,-(sp)        * set -1 sign/exponent
00000EB8  6004                    1652      bra.s   lab_17b7        * go do DEC
00000EBA                          1653  
00000EBA                          1654  * perform INC
00000EBA                          1655  
00000EBA                          1656  lab_inc
00000EBA  3F3C 8100               1657      move.w  #$8100,-(sp)        * set 1 sign/exponent
00000EBE                          1658  lab_17b7
00000EBE  6100 085C               1659      bsr lab_gvar        * get var address
00000EC2                          1660                      * return pointer to variable in Cvaral and a0
00000EC2  4A39 000405BD           1661      tst.b   dtypef          * test data type, $80=string, $40=integer, $00=float
00000EC8  6B00 F8DA               1662      bmi lab_tmer        * if string do "Type mismatch" error/warm start
00000ECC                          1663  
00000ECC  6648                    1664      bne.s   lab_inci        * go do integer INC/DEC
00000ECE                          1665  
00000ECE  23C8 00040476           1666      move.l  a0,lvarpl       * save var address
00000ED4  6100 15F2               1667      bsr lab_ufac        * unpack memory (a0) into FAC1
00000ED8  23FC 80000000 0004059C  1668      move.l  #$80000000,fac2_m   * set FAC2 mantissa for 1
00000EE2  3017                    1669      move.w  (sp),d0         * move exponent & sign to d0
00000EE4  33C0 000405A0           1670      move.w  d0,fac2_e       * move exponent & sign to FAC2
00000EEA  13F9 00040599 000405A2  1671      move.b  fac1_s,fac_sc       * make sign compare = FAC1 sign
00000EF4  B139 000405A2           1672      eor.b   d0,fac_sc       * make sign compare (FAC1_s EOR FAC2_s)
00000EFA  6100 11EA               1673      bsr lab_add         * add FAC2 to FAC1
00000EFE  6100 15E8               1674      bsr lab_pfac        * pack FAC1 into variable (Lvarpl)
00000F02                          1675  lab_inct
00000F02  6100 0600               1676      bsr lab_gbyt        * scan memory
00000F06  0C00 002C               1677      cmpi.b  #$2c,d0         * compare with ","
00000F0A  6704                    1678      beq.s   lab_17b8        * continue if "," (another variable to do)
00000F0C                          1679  
00000F0C  544F                    1680      addq.w  #2,sp           * else dump sign & exponent
00000F0E  4E75                    1681      rts
00000F10                          1682                      * was "," so another INCR variable to do
00000F10                          1683  lab_17b8
00000F10  6100 05F0               1684      bsr lab_igby        * increment and scan memory
00000F14  60A8                    1685      bra.s   lab_17b7        * go do next var
00000F16                          1686  
00000F16                          1687  lab_inci
00000F16  4A2F 0001               1688      tst.b   1(sp)           * test sign
00000F1A  6604                    1689      bne.s   lab_deci        * branch if DEC
00000F1C                          1690  
00000F1C  5290                    1691      addq.l  #1,(a0)         * increment variable
00000F1E  60E2                    1692      bra.s   lab_inct        * go scan for more
00000F20                          1693  
00000F20                          1694  lab_deci
00000F20  5390                    1695      subq.l  #1,(a0)         * decrement variable
00000F22  60DE                    1696      bra.s   lab_inct        * go scan for more
00000F24                          1697  
00000F24                          1698  
00000F24                          1699  * perform LET
00000F24                          1700  
00000F24                          1701  lab_let
00000F24  6100 07F6               1702      bsr lab_gvar        * get variable address
00000F28                          1703                      * return pointer to variable in Cvaral and a0
00000F28  23C8 00040476           1704      move.l  a0,lvarpl       * save variable address
00000F2E  1F39 000405BD           1705      move.b  dtypef,-(sp)        * push var data type, $80=string, $40=int, $00=float
00000F34  70BC                    1706      moveq   #tk_equal-$100,d0   * get = token
00000F36  6100 05C4               1707      bsr lab_scca        * scan for CHR$(d0), else syntax error/warm start
00000F3A  6100 0408               1708      bsr lab_evex        * evaluate expression
00000F3E  1039 000405BD           1709      move.b  dtypef,d0       * copy expression data type
00000F44  13DF 000405BD           1710      move.b  (sp)+,dtypef        * pop variable data type
00000F4A  E318                    1711      rol.b   #1,d0           * set carry if expression type = string
00000F4C  6100 03E0               1712      bsr lab_cktm        * type match check, set C for string
00000F50  6700 1596               1713      beq lab_pfac        * if number pack FAC1 into variable Lvarpl & RET
00000F54                          1714  
00000F54                          1715  * string LET
00000F54                          1716  
00000F54                          1717  lab_17d5
00000F54  2479 00040476           1718      movea.l lvarpl,a2       * get pointer to variable
00000F5A                          1719  lab_17d6
00000F5A  2079 00040594           1720      movea.l fac1_m,a0       * get descriptor pointer
00000F60  2250                    1721      movea.l (a0),a1         * get string pointer
00000F62                          1722  *   cmp.l   smeml,a1        * compare bottom of memory with string pointer
00000F62                          1723  *   bcs.s   lab_1810        * if string was in utility memory copy it
00000F62                          1724  
00000F62  B3F9 0004044A           1725      cmp.l   sstorl,a1       * compare string memory start with string pointer
00000F68  651A                    1726      bcs.s   lab_1811        * if it was in program memory assign value & exit
00000F6A                          1727  
00000F6A  B1F9 00040436           1728      cmpa.l  sfncl,a0        * compare functions start with descriptor pointer
00000F70  6512                    1729      bcs.s   lab_1811        * branch if >= (string is on stack)
00000F72                          1730  
00000F72                          1731                      * string is variable$, make space and copy string
00000F72                          1732  lab_1810
00000F72  7200                    1733      moveq   #0,d1           * clear length
00000F74  3228 0004               1734      move.w  4(a0),d1        * get string length
00000F78  2050                    1735      movea.l (a0),a0         * get string pointer
00000F7A  6100 0C9E               1736      bsr lab_20c9        * copy string
00000F7E  2079 00040594           1737      movea.l fac1_m,a0       * get descriptor pointer back
00000F84                          1738                      * clean stack & assign value to string variable
00000F84                          1739  lab_1811
00000F84  B9C8                    1740      cmpa.l  a0,a4           * is string on the descriptor stack
00000F86  6602                    1741      bne.s   lab_1813        * skip pop if not
00000F88                          1742  
00000F88  5C4C                    1743      addq.w  #$06,a4         * else update stack pointer
00000F8A                          1744  lab_1813
00000F8A  24D8                    1745      move.l  (a0)+,(a2)+     * save pointer to variable
00000F8C  3490                    1746      move.w  (a0),(a2)       * save length to variable
00000F8E                          1747  rts_008
00000F8E  4E75                    1748      rts
00000F90                          1749  
00000F90                          1750  * perform GET
00000F90                          1751  
00000F90                          1752  lab_get
00000F90  6100 078A               1753      bsr lab_gvar        * get var address
00000F94                          1754                      * return pointer to variable in Cvaral and a0
00000F94  23C8 00040476           1755      move.l  a0,lvarpl       * save variable address as GET variable
00000F9A  4A39 000405BD           1756      tst.b   dtypef          * test data type, $80=string, $40=integer, $00=float
00000FA0  6B0C                    1757      bmi.s   lab_gets        * go get string character
00000FA2                          1758  
00000FA2                          1759                      * was numeric get
00000FA2  6100 1EBC               1760      bsr inget           * get input byte
00000FA6  6100 0B14               1761      bsr lab_1fd0        * convert d0 to unsigned byte in FAC1
00000FAA  6000 153C               1762      bra lab_pfac        * pack FAC1 into variable (Lvarpl) & return
00000FAE                          1763  
00000FAE                          1764  lab_gets
00000FAE  7200                    1765      moveq   #$00,d1         * assume no byte
00000FB0  6100 1EAE               1766      bsr inget           * get input byte
00000FB4  6402                    1767      bcc.s   lab_nobyte      * branch if no byte received
00000FB6                          1768  
00000FB6  7201                    1769      moveq   #$01,d1         * string is single byte
00000FB8                          1770  lab_nobyte
00000FB8  6100 0C98               1771      bsr lab_2115        * make string space d1 bytes long
00000FBC                          1772                      * return a0 = pointer, other registers unchanged
00000FBC  6702                    1773      beq.s   lab_nost        * skip store if null string (or will write over $00)
00000FBE                          1774  
00000FBE  1080                    1775      move.b  d0,(a0)         * save byte in string (byte IS string!)
00000FC0                          1776  lab_nost
00000FC0  6100 0C72               1777      bsr lab_rtst        * push string on descriptor stack
00000FC4                          1778                      * a0 = pointer, d1 = length
00000FC4                          1779  
00000FC4  608E                    1780      bra.s   lab_17d5        * do string LET & return
00000FC6                          1781  
00000FC6                          1782  * PRINT
00000FC6                          1783  
00000FC6                          1784  lab_1829
00000FC6  6100 00C0               1785      bsr lab_18c6        * print string from stack
00000FCA                          1786  lab_182c
00000FCA  6100 0538               1787      bsr lab_gbyt        * scan memory
00000FCE                          1788  
00000FCE                          1789  * perform PRINT
00000FCE                          1790  
00000FCE                          1791  lab_print
00000FCE  6752                    1792      beq.s   lab_crlf        * if nothing following just print CR/LF
00000FD0                          1793  
00000FD0                          1794  lab_1831
00000FD0  67BC                    1795      beq.s   rts_008         * exit if nothing more to print
00000FD2                          1796  
00000FD2  B03C 00A8               1797      cmp.b   #tk_tab,d0      * compare with TAB( token
00000FD6  6770                    1798      beq.s   lab_18a2        * go do TAB/SPC
00000FD8                          1799  
00000FD8  B03C 00AB               1800      cmp.b   #tk_spc,d0      * compare with SPC( token
00000FDC  676A                    1801      beq.s   lab_18a2        * go do TAB/SPC
00000FDE                          1802  
00000FDE  B03C 002C               1803      cmp.b   #',',d0         * compare with ","
00000FE2  6746                    1804      beq.s   lab_188b        * go do move to next TAB mark
00000FE4                          1805  
00000FE4  B03C 003B               1806      cmp.b   #';',d0         * compare with ";"
00000FE8  6700 0092               1807      beq lab_18bd        * if ";" continue with PRINT processing
00000FEC                          1808  
00000FEC  6100 0356               1809      bsr lab_evex        * evaluate expression
00000FF0  4A39 000405BD           1810      tst.b   dtypef          * test data type, $80=string, $40=integer, $00=float
00000FF6  6BCE                    1811      bmi.s   lab_1829        * branch if string
00000FF8                          1812  
00000FF8                          1813  ** replace the two lines above with this code
00000FF8                          1814  
00000FF8                          1815  **  move.b  dtypef,d0       * get data type flag, $80=string, $00=numeric
00000FF8                          1816  **  bmi.s   lab_1829        * branch if string
00000FF8                          1817  
00000FF8  6100 16CC               1818      bsr lab_2970        * convert FAC1 to string
00000FFC  6100 0BE8               1819      bsr lab_20ae        * print " terminated string to FAC1 stack
00001000                          1820  
00001000                          1821  * don't check fit if terminal width byte is zero
00001000                          1822  
00001000  7000                    1823      moveq   #0,d0           * clear d0
00001002  1039 000405EF           1824      move.b  twidth,d0       * get terminal width byte
00001008  670E                    1825      beq.s   lab_185e        * skip check if zero
0000100A                          1826  
0000100A  902C 0007               1827      sub.b   7(a4),d0        * subtract string length
0000100E  9039 000405EE           1828      sub.b   tpos,d0         * subtract terminal position
00001014  6402                    1829      bcc.s   lab_185e        * branch if less than terminal width
00001016                          1830  
00001016  610A                    1831      bsr.s   lab_crlf        * else print CR/LF
00001018                          1832  lab_185e
00001018  616E                    1833      bsr.s   lab_18c6        * print string from stack
0000101A  60AE                    1834      bra.s   lab_182c        * always go continue processing line
0000101C                          1835  
0000101C                          1836  * CR/LF return to BASIC from BASIC input handler
0000101C                          1837  * leaves a0 pointing to the buffer start
0000101C                          1838  
0000101C                          1839  lab_1866
0000101C  11BC 0000 1000          1840      move.b  #$00,(a0,d1.w)      * null terminate input
00001022                          1841  
00001022                          1842  * print CR/LF
00001022                          1843  
00001022                          1844  lab_crlf
00001022  700D                    1845      moveq   #$0d,d0         * load [CR]
00001024  6178                    1846      bsr.s   lab_prna        * go print the character
00001026  700A                    1847      moveq   #$0a,d0         * load [LF]
00001028  6074                    1848      bra.s   lab_prna        * go print the character & return (always branch)
0000102A                          1849  
0000102A                          1850  lab_188b
0000102A  1439 000405EE           1851      move.b  tpos,d2         * get terminal position
00001030  B439 000405F0           1852      cmp.b   iclim,d2        * compare with input column limit
00001036  6504                    1853      bcs.s   lab_1898        * branch if less than Iclim
00001038                          1854  
00001038  61E8                    1855      bsr.s   lab_crlf        * else print CR/LF (next line)
0000103A  6040                    1856      bra.s   lab_18bd        * continue with PRINT processing (branch always)
0000103C                          1857  
0000103C                          1858  lab_1898
0000103C  9439 000405EA           1859      sub.b   tabsiz,d2       * subtract TAB size
00001042  64F8                    1860      bcc.s   lab_1898        * loop if result was >= 0
00001044                          1861  
00001044  4402                    1862      neg.b   d2          * twos complement it
00001046  6026                    1863      bra.s   lab_18b7        * print d2 spaces
00001048                          1864  
00001048                          1865                      * do TAB/SPC
00001048                          1866  lab_18a2
00001048  3F00                    1867      move.w  d0,-(sp)        * save token
0000104A  6100 0F04               1868      bsr lab_sgby        * increment and get byte, result in d0 and Itemp
0000104E  3400                    1869      move.w  d0,d2           * copy byte
00001050  6100 04B2               1870      bsr lab_gbyt        * get basic byte back
00001054  B03C 0029               1871      cmp.b   #$29,d0         * is next character ")"
00001058  6600 F776               1872      bne lab_sner        * if not do syntax error, then warm start
0000105C                          1873  
0000105C  301F                    1874      move.w  (sp)+,d0        * get token back
0000105E  B03C 00A8               1875      cmp.b   #tk_tab,d0      * was it TAB ?
00001062  660A                    1876      bne.s   lab_18b7        * branch if not (was SPC)
00001064                          1877  
00001064                          1878                      * calculate TAB offset
00001064  9439 000405EE           1879      sub.b   tpos,d2         * subtract terminal position
0000106A  6510                    1880      bcs.s   lab_18bd        * branch if result was < 0 (can't TAB backwards)
0000106C                          1881  
0000106C  670E                    1882      beq.s   lab_18bd        * branch if result was = $0 (already here)
0000106E                          1883  
0000106E                          1884                      * print d2 spaces
0000106E                          1885  lab_18b7
0000106E  4A02                    1886      tst.b   d2          * test count
00001070  670A                    1887      beq.s   lab_18bd        * branch if zero
00001072                          1888  
00001072  5302                    1889      subq.b  #1,d2           * adjust for DBF loop
00001074  7020                    1890      moveq   #$20,d0         * load " "
00001076                          1891  lab_18b8
00001076  6126                    1892      bsr.s   lab_prna        * go print
00001078  51CA FFFC               1893      dbf d2,lab_18b8     * decrement count and loop if not all done
0000107C                          1894  
0000107C                          1895                      * continue with PRINT processing
0000107C                          1896  lab_18bd
0000107C  6100 0484               1897      bsr lab_igby        * increment & scan memory
00001080  6000 FF4E               1898      bra lab_1831        * continue executing PRINT
00001084                          1899  
00001084                          1900  * print null terminated string from a0
00001084                          1901  
00001084                          1902  lab_18c3
00001084  6100 0B60               1903      bsr lab_20ae        * print terminated string to FAC1/stack
00001088                          1904  
00001088                          1905  * print string from stack
00001088                          1906  
00001088                          1907  lab_18c6
00001088  6100 0D80               1908      bsr lab_22b6        * pop string off descriptor stack or from memory
0000108C                          1909                      * returns with d0 = length, a0 = pointer
0000108C  3200                    1910      move.w  d0,d1           * copy length & set Z flag
0000108E  670A                    1911      beq.s   rts_009         * exit (RTS) if null string
00001090                          1912  
00001090  5341                    1913      subq.w  #1,d1           * -1 for BF loop
00001092                          1914  lab_18cd
00001092  1018                    1915      move.b  (a0)+,d0        * get byte from string
00001094  6108                    1916      bsr.s   lab_prna        * go print the character
00001096  51C9 FFFA               1917      dbf d1,lab_18cd     * decrement count and loop if not done yet
0000109A                          1918  
0000109A                          1919  rts_009
0000109A  4E75                    1920      rts
0000109C                          1921  
0000109C                          1922  * print "?" character
0000109C                          1923  
0000109C                          1924  lab_18e3
0000109C  703F                    1925      moveq   #$3f,d0         * load "?" character
0000109E                          1926  
0000109E                          1927  * print character in d0, includes the null handler and infinite line length code
0000109E                          1928  * changes no registers.
0000109E                          1929  
0000109E                          1930  lab_prna
0000109E  2F01                    1931      move.l  d1,-(sp)        * save d1
000010A0  B03C 0020               1932      cmp.b   #$20,d0         * compare with " "
000010A4  6534                    1933      bcs.s   lab_18f9        * branch if less, non printing character
000010A6                          1934  
000010A6                          1935                      * don't check fit if terminal width byte is zero
000010A6  1239 000405EF           1936      move.b  twidth,d1       * get terminal width
000010AC  6616                    1937      bne.s   lab_18f0        * branch if not zero (not infinite length)
000010AE                          1938  
000010AE                          1939                      * is "infinite line" so check TAB position
000010AE  1239 000405EE           1940      move.b  tpos,d1         * get position
000010B4  9239 000405EA           1941      sub.b   tabsiz,d1       * subtract TAB size
000010BA  6618                    1942      bne.s   lab_18f7        * skip reset if different
000010BC                          1943  
000010BC  13C1 000405EE           1944      move.b  d1,tpos         * else reset position
000010C2  6010                    1945      bra.s   lab_18f7        * go print character
000010C4                          1946  
000010C4                          1947  lab_18f0
000010C4  B239 000405EE           1948      cmp.b   tpos,d1         * compare with terminal character position
000010CA  6608                    1949      bne.s   lab_18f7        * branch if not at end of line
000010CC                          1950  
000010CC  2F00                    1951      move.l  d0,-(sp)        * save d0
000010CE  6100 FF52               1952      bsr lab_crlf        * else print CR/LF
000010D2  201F                    1953      move.l  (sp)+,d0        * restore d0
000010D4                          1954  lab_18f7
000010D4  5239 000405EE           1955      addq.b  #$01,tpos       * increment terminal position
000010DA                          1956  lab_18f9
000010DA  4EB9 00040412           1957      jsr v_outp          * output byte via output vector
000010E0  B03C 000D               1958      cmp.b   #$0d,d0         * compare with [CR]
000010E4  661E                    1959      bne.s   lab_188a        * branch if not [CR]
000010E6                          1960  
000010E6                          1961                      * else print nullct nulls after the [CR]
000010E6  7200                    1962      moveq   #$00,d1         * clear d1
000010E8  1239 000405ED           1963      move.b  nullct,d1       * get null count
000010EE  670E                    1964      beq.s   lab_1886        * branch if no nulls
000010F0                          1965  
000010F0  7000                    1966      moveq   #$00,d0         * load [NULL]
000010F2                          1967  lab_1880
000010F2  4EB9 00040412           1968      jsr v_outp          * go print the character
000010F8  51C9 FFF8               1969      dbf d1,lab_1880     * decrement count and loop if not all done
000010FC                          1970  
000010FC  700D                    1971      moveq   #$0d,d0         * restore the character
000010FE                          1972  lab_1886
000010FE  13C1 000405EE           1973      move.b  d1,tpos         * clear terminal position
00001104                          1974  lab_188a
00001104  221F                    1975      move.l  (sp)+,d1        * restore d1
00001106  4E75                    1976      rts
00001108                          1977  
00001108                          1978  * handle bad input data
00001108                          1979  
00001108                          1980  lab_1904
00001108  4A39 000405E8           1981      tst.b   imode           * test input mode flag, $00=INPUT, $98=READ
0000110E  6A0E                    1982      bpl.s   lab_1913        * branch if INPUT (go do redo)
00001110                          1983  
00001110  23F9 00040462 00040456  1984      move.l  dlinel,clinel       * save DATA line as current line
0000111A  6000 F6B4               1985      bra lab_sner        * do syntax error, then warm start
0000111E                          1986  
0000111E                          1987                      * mode was INPUT
0000111E                          1988  lab_1913
0000111E  41FA 2BCD               1989      lea (lab_redo,pc),a0    * point to redo message
00001122  6100 FF60               1990      bsr lab_18c3        * print null terminated string from memory
00001126  2A79 0004045E           1991      movea.l cpntrl,a5       * save continue pointer as BASIC execute pointer
0000112C  4E75                    1992      rts
0000112E                          1993  
0000112E                          1994  * perform INPUT
0000112E                          1995  
0000112E                          1996  lab_input
0000112E  6100 0994               1997      bsr lab_ckrn        * check not Direct (back here if ok)
00001132  B03C 0022               1998      cmp.b   #$22,d0         * compare next byte with open quote
00001136  660E                    1999      bne.s   lab_1934        * branch if no prompt string
00001138                          2000  
00001138  6100 03A0               2001      bsr lab_1bc1        * print "..." string
0000113C  703B                    2002      moveq   #$3b,d0         * load d0 with ";"
0000113E  6100 03BC               2003      bsr lab_scca        * scan for CHR$(d0), else syntax error/warm start
00001142  6100 FF44               2004      bsr lab_18c6        * print string from Sutill/Sutilh
00001146                          2005                      * done with prompt, now get data
00001146                          2006  lab_1934
00001146  6100 F7BA               2007      bsr lab_inln        * print "? " and get BASIC input
0000114A                          2008                      * return a0 pointing to the buffer start
0000114A  7000                    2009      moveq   #0,d0           * clear d0 (flag INPUT)
0000114C  4A10                    2010      tst.b   (a0)            * test first byte from buffer
0000114E  6610                    2011      bne.s   lab_1953        * branch if not null input
00001150                          2012  
00001150  023C 00FE               2013      and #$fe,ccr        * was null input so clear carry to exit prog
00001154  6000 FB18               2014      bra lab_1647        * go do BREAK exit
00001158                          2015  
00001158                          2016  * perform READ
00001158                          2017  
00001158                          2018  lab_read
00001158  2079 00040466           2019      movea.l dptrl,a0        * get DATA pointer
0000115E  7098                    2020      moveq   #$98-$100,d0        * flag READ
00001160                          2021  lab_1953
00001160  13C0 000405E8           2022      move.b  d0,imode        * set input mode flag, $00=INPUT, $98=READ
00001166  23C8 0004046A           2023      move.l  a0,rdptrl       * save READ pointer
0000116C                          2024  
0000116C                          2025                      * READ or INPUT next variable from list
0000116C                          2026  lab_195b
0000116C  6100 05AE               2027      bsr lab_gvar        * get (var) address
00001170                          2028                      * return pointer to variable in Cvaral and a0
00001170  23C8 00040476           2029      move.l  a0,lvarpl       * save variable address as LET variable
00001176  2F0D                    2030      move.l  a5,-(sp)        * save BASIC execute pointer
00001178  2A79 0004046A           2031      movea.l rdptrl,a5       * set READ pointer as BASIC execute pointer
0000117E  6100 0384               2032      bsr lab_gbyt        * scan memory
00001182  6624                    2033      bne.s   lab_1986        * branch if not null
00001184                          2034  
00001184                          2035                      * pointer was to null entry
00001184  4A39 000405E8           2036      tst.b   imode           * test input mode flag, $00=INPUT, $98=READ
0000118A  6B7E                    2037      bmi.s   lab_19dd        * branch if READ (go find next statement)
0000118C                          2038  
0000118C                          2039                      * mode was INPUT
0000118C  6100 FF0E               2040      bsr lab_18e3        * print "?" character (double ? for extended input)
00001190  6100 F770               2041      bsr lab_inln        * print "? " and get BASIC input
00001194                          2042                      * return a0 pointing to the buffer start
00001194  4A10                    2043      tst.b   (a0)            * test first byte from buffer
00001196  6608                    2044      bne.s   lab_1984        * branch if not null input
00001198                          2045  
00001198  023C 00FE               2046      and #$fe,ccr        * was null input so clear carry to exit prog
0000119C  6000 FAD0               2047      bra lab_1647        * go do BREAK exit
000011A0                          2048  
000011A0                          2049  lab_1984
000011A0  2A48                    2050      movea.l a0,a5           * set BASIC execute pointer to buffer start
000011A2  534D                    2051      subq.w  #1,a5           * decrement pointer
000011A4                          2052  lab_1985
000011A4  6100 035C               2053      bsr lab_igby        * increment & scan memory
000011A8                          2054  lab_1986
000011A8  4A39 000405BD           2055      tst.b   dtypef          * test data type, $80=string, $40=integer, $00=float
000011AE  6A20                    2056      bpl.s   lab_19b0        * branch if numeric
000011B0                          2057  
000011B0                          2058                      * else get string
000011B0  1400                    2059      move.b  d0,d2           * save search character
000011B2  B03C 0022               2060      cmp.b   #$22,d0         * was it " ?
000011B6  6706                    2061      beq.s   lab_1999        * branch if so
000011B8                          2062  
000011B8  743A                    2063      moveq   #':',d2         * set new search character
000011BA  702C                    2064      moveq   #',',d0         * other search character is ","
000011BC  534D                    2065      subq.w  #1,a5           * decrement BASIC execute pointer
000011BE                          2066  lab_1999
000011BE  524D                    2067      addq.w  #1,a5           * increment BASIC execute pointer
000011C0  1600                    2068      move.b  d0,d3           * set second search character
000011C2  204D                    2069      movea.l a5,a0           * BASIC execute pointer is source
000011C4                          2070  
000011C4  6100 0A24               2071      bsr lab_20b4        * print d2/d3 terminated string to FAC1 stack
000011C8                          2072                      * d2 = Srchc, d3 = Asrch, a0 is source
000011C8  2A4A                    2073      movea.l a2,a5           * copy end of string to BASIC execute pointer
000011CA  6100 FD88               2074      bsr lab_17d5        * go do string LET
000011CE  6014                    2075      bra.s   lab_19b6        * go check string terminator
000011D0                          2076  
000011D0                          2077                      * get numeric INPUT
000011D0                          2078  lab_19b0
000011D0  1F39 000405BD           2079      move.b  dtypef,-(sp)        * save variable data type
000011D6  6100 1E80               2080      bsr lab_2887        * get FAC1 from string
000011DA  13DF 000405BD           2081      move.b  (sp)+,dtypef        * restore variable data type
000011E0  6100 1306               2082      bsr lab_pfac        * pack FAC1 into (Lvarpl)
000011E4                          2083  lab_19b6
000011E4  6100 031E               2084      bsr lab_gbyt        * scan memory
000011E8  670A                    2085      beq.s   lab_19c2        * branch if null (last entry)
000011EA                          2086  
000011EA  B03C 002C               2087      cmp.b   #',',d0         * else compare with ","
000011EE  6600 FF18               2088      bne lab_1904        * if not "," go handle bad input data
000011F2                          2089  
000011F2  524D                    2090      addq.w  #1,a5           * else was "," so point to next chr
000011F4                          2091                      * got good input data
000011F4                          2092  lab_19c2
000011F4  23CD 0004046A           2093      move.l  a5,rdptrl       * save read pointer for now
000011FA  2A5F                    2094      movea.l (sp)+,a5        * restore execute pointer
000011FC  6100 0306               2095      bsr lab_gbyt        * scan memory
00001200  6738                    2096      beq.s   lab_1a03        * if null go do extra ignored message
00001202                          2097  
00001202  6100 02F6               2098      bsr lab_1c01        * scan for "," , else do syntax error/warm start
00001206  6000 FF64               2099      bra lab_195b        * go INPUT next variable from list
0000120A                          2100  
0000120A                          2101                      * find next DATA statement or do "OD" error
0000120A                          2102  lab_19dd
0000120A  6100 FBEC               2103      bsr lab_snbs        * scan for next BASIC statement ([:] or [EOL])
0000120E                          2104                      * returns a0 as pointer to [:] or [EOL]
0000120E  2A48                    2105      movea.l a0,a5           * add index, now = pointer to [EOL]/[EOS]
00001210  524D                    2106      addq.w  #1,a5           * pointer to next character
00001212  B03C 003A               2107      cmp.b   #':',d0         * was it statement end?
00001216  6714                    2108      beq.s   lab_19f6        * branch if [:]
00001218                          2109  
00001218                          2110                      * was [EOL] so find next line
00001218                          2111  
00001218  320D                    2112      move.w  a5,d1           * past pad byte(s)
0000121A  C27C 0001               2113      and.w   #1,d1           * mask odd bit
0000121E  DAC1                    2114      add.w   d1,a5           * add pointer
00001220  241D                    2115      move.l  (a5)+,d2        * get next line pointer
00001222  6700 F5A4               2116      beq lab_oder        * branch if end of program
00001226                          2117  
00001226  23DD 00040462           2118      move.l  (a5)+,dlinel        * save current DATA line
0000122C                          2119  lab_19f6
0000122C  6100 02D6               2120      bsr lab_gbyt        * scan memory
00001230  B03C 0083               2121      cmp.b   #tk_data,d0     * compare with "DATA" token
00001234  6700 FF6E               2122      beq lab_1985        * was "DATA" so go do next READ
00001238                          2123  
00001238  60D0                    2124      bra.s   lab_19dd        * go find next statement if not "DATA"
0000123A                          2125  
0000123A                          2126  * end of INPUT/READ routine
0000123A                          2127  
0000123A                          2128  lab_1a03
0000123A  2079 0004046A           2129      movea.l rdptrl,a0       * get temp READ pointer
00001240  4A39 000405E8           2130      tst.b   imode           * get input mode flag, $00=INPUT, $98=READ
00001246  6A08                    2131      bpl.s   lab_1a0e        * branch if INPUT
00001248                          2132  
00001248  23C8 00040466           2133      move.l  a0,dptrl        * else save temp READ pointer as DATA pointer
0000124E  4E75                    2134      rts
00001250                          2135  
00001250                          2136                      * we were getting INPUT
00001250                          2137  lab_1a0e
00001250  4A10                    2138      tst.b   (a0)            * test next byte
00001252  6602                    2139      bne.s   lab_1a1b        * error if not end of INPUT
00001254                          2140  
00001254  4E75                    2141      rts
00001256                          2142                      * user typed too much
00001256                          2143  lab_1a1b
00001256  41FA 2A85               2144      lea (lab_imsg,pc),a0    * point to extra ignored message
0000125A  6000 FE28               2145      bra lab_18c3        * print null terminated string from memory & RTS
0000125E                          2146  
0000125E                          2147  * perform NEXT
0000125E                          2148  
0000125E                          2149  lab_next
0000125E  6606                    2150      bne.s   lab_1a46        * branch if NEXT var
00001260                          2151  
00001260  307C 0000               2152      movea.w #0,a0           * else clear a0
00001264  6004                    2153      bra.s   lab_1a49        * branch always (no variable to search for)
00001266                          2154  
00001266                          2155  * NEXT var
00001266                          2156  
00001266                          2157  lab_1a46
00001266  6100 04B4               2158      bsr lab_gvar        * get variable address
0000126A                          2159                      * return pointer to variable in Cvaral and a0
0000126A                          2160  lab_1a49
0000126A  23C8 00040476           2161      move.l  a0,frnxtl       * store variable pointer
00001270  6100 F4BE               2162      bsr lab_11a1        * search the stack for FOR or GOSUB activity
00001274                          2163                      * exit with z=1 if FOR else exit with z=0
00001274                          2164                      * return modified stack in a2
00001274  6600 F55E               2165      bne lab_nfer        * if not found do next without for err/warm start
00001278                          2166  
00001278  2E4A                    2167      movea.l a2,sp           * set stack pointer (dumps return addresses)
0000127A  33EA 0006 000405A0      2168      move.w  6(a2),fac2_e        * get STEP value exponent and sign
00001282  23EA 0008 0004059C      2169      move.l  8(a2),fac2_m        * get STEP value mantissa
0000128A                          2170  
0000128A  2079 00040476           2171      movea.l frnxtl,a0       * get FOR variable pointer
00001290  13EA 0012 000405BD      2172      move.b  18(a2),dtypef       * restore FOR variable data type
00001298  6100 0290               2173      bsr lab_1c19        * check type and unpack (a0)
0000129C                          2174  
0000129C  13F9 000405A1 000405A2  2175      move.b  fac2_s,fac_sc       * save FAC2 sign as sign compare
000012A6  1039 00040599           2176      move.b  fac1_s,d0       * get FAC1 sign
000012AC  B139 000405A2           2177      eor.b   d0,fac_sc       * EOR to create sign compare
000012B2                          2178  
000012B2  6100 0E32               2179      bsr lab_add         * add STEP value to FOR variable
000012B6  13EA 0012 000405BD      2180      move.b  18(a2),dtypef       * restore FOR variable data type (again)
000012BE  6100 1228               2181      bsr lab_pfac        * pack FAC1 into FOR variable
000012C2                          2182  
000012C2  33EA 000C 000405A0      2183      move.w  12(a2),fac2_e       * get TO value exponent and sign
000012CA  23EA 000E 0004059C      2184      move.l  14(a2),fac2_m       * get TO value mantissa
000012D2                          2185  
000012D2  13F9 000405A1 000405A2  2186      move.b  fac2_s,fac_sc       * save FAC2 sign as sign compare
000012DC  1039 00040599           2187      move.b  fac1_s,d0       * get FAC1 sign
000012E2  B139 000405A2           2188      eor.b   d0,fac_sc       * EOR to create sign compare
000012E8                          2189  
000012E8  6100 12D2               2190      bsr lab_27fa        * compare FAC1 with FAC2 (TO value)
000012EC                          2191                      * returns d0=+1 if FAC1 > FAC2
000012EC                          2192                      * returns d0= 0 if FAC1 = FAC2
000012EC                          2193                      * returns d0=-1 if FAC1 < FAC2
000012EC                          2194  
000012EC  322A 0006               2195      move.w  6(a2),d1        * get STEP value exponent and sign
000012F0  B141                    2196      eor.w   d0,d1           * EOR compare result with STEP (exponent and sign)
000012F2                          2197  
000012F2  4A00                    2198      tst.b   d0          * test for =
000012F4  6704                    2199      beq.s   lab_1a90        * branch if = (loop INcomplete)
000012F6                          2200  
000012F6  4A01                    2201      tst.b   d1          * test result
000012F8  6A10                    2202      bpl.s   lab_1a9b        * branch if > (loop complete)
000012FA                          2203  
000012FA                          2204                      * loop back and do it all again
000012FA                          2205  lab_1a90
000012FA  23EA 0014 00040456      2206      move.l  20(a2),clinel       * reset current line
00001302  2A6A 0018               2207      move.l  24(a2),a5       * reset BASIC execute pointer
00001306  6000 F900               2208      bra lab_15c2        * go do interpreter inner loop
0000130A                          2209  
0000130A                          2210                      * loop complete so carry on
0000130A                          2211  lab_1a9b
0000130A  D4FC 001C               2212      adda.w  #28,a2          * add 28 to dump FOR structure
0000130E  2E4A                    2213      movea.l a2,sp           * copy to stack pointer
00001310  6100 01F2               2214      bsr lab_gbyt        * scan memory
00001314  B03C 002C               2215      cmp.b   #$2c,d0         * compare with ","
00001318  6600 F8EE               2216      bne lab_15c2        * if not "," go do interpreter inner loop
0000131C                          2217  
0000131C                          2218                      * was "," so another NEXT variable to do
0000131C  6100 01E4               2219      bsr lab_igby        * else increment & scan memory
00001320  6100 FF44               2220      bsr lab_1a46        * do NEXT (var)
00001324                          2221  
00001324                          2222  * evaluate expression & check is numeric, else do type mismatch
00001324                          2223  
00001324                          2224  lab_evnm
00001324  611E                    2225      bsr.s   lab_evex        * evaluate expression
00001326                          2226  
00001326                          2227  * check if source is numeric, else do type mismatch
00001326                          2228  
00001326                          2229  lab_ctnm
00001326  B040                    2230      cmp.w   d0,d0           * required type is numeric so clear carry
00001328  6004                    2231      bra.s   lab_cktm        * go check type match
0000132A                          2232  
0000132A                          2233  * check if source is string, else do type mismatch
0000132A                          2234  
0000132A                          2235  lab_ctst
0000132A  003C 0001               2236      ori.b   #1,ccr          * required type is string so set carry
0000132E                          2237  
0000132E                          2238  * type match check, set C for string, clear C for numeric
0000132E                          2239  
0000132E                          2240  lab_cktm
0000132E  0839 0007 000405BD      2241      btst.b  #7,dtypef       * test data type flag, don't change carry
00001336  6606                    2242      bne.s   lab_1aba        * branch if data type is string
00001338                          2243  
00001338                          2244                      * else data type was numeric
00001338  6500 F46A               2245      bcs lab_tmer        * if required type is string do type mismatch err
0000133C                          2246  
0000133C  4E75                    2247      rts
0000133E                          2248                      * data type was string, now check required type
0000133E                          2249  lab_1aba
0000133E  6400 F464               2250      bcc lab_tmer        * if required type is numeric do type mismatch error
00001342                          2251  
00001342  4E75                    2252      rts
00001344                          2253  
00001344                          2254  * evaluate expression
00001344                          2255  
00001344                          2256  lab_evex
00001344  534D                    2257      subq.w  #1,a5           * decrement BASIC execute pointer
00001346  7200                    2258      moveq   #0,d1           * clear precedence word
00001348  6002                    2259      bra.s   lab_1acd        * enter loop
0000134A                          2260  
0000134A                          2261  lab_1acc
0000134A  3F00                    2262      move.w  d0,-(sp)        * push compare evaluation byte if branch to here
0000134C                          2263  lab_1acd
0000134C  3F01                    2264      move.w  d1,-(sp)        * push precedence word
0000134E                          2265  
0000134E                          2266  *   moveq   #$02,d0         * 2 bytes !!
0000134E                          2267  *   bsr.s   lab_1212        * check room on stack for d0 bytes
0000134E                          2268  
0000134E  6100 0156               2269      bsr lab_gval        * get value from line
00001352  13FC 0000 000405EC      2270      move.b  #$00,comp_f     * clear compare function flag
0000135A                          2271  lab_1adb
0000135A  6100 01A8               2272      bsr lab_gbyt        * scan memory
0000135E                          2273  lab_1ade
0000135E  0400 00BB               2274      sub.b   #tk_gt,d0       * subtract token for > (lowest compare function)
00001362  6538                    2275      bcs.s   lab_1afa        * branch if < TK_GT
00001364                          2276  
00001364  B03C 0003               2277      cmp.b   #$03,d0         * compare with ">" to "<" tokens
00001368  650C                    2278      bcs.s   lab_1ae0        * branch if < TK_SGN (is compare function)
0000136A                          2279  
0000136A  4A39 000405EC           2280      tst.b   comp_f          * test compare function flag
00001370  6676                    2281      bne.s   lab_1b2a        * branch if compare function
00001372                          2282  
00001372  6000 00E2               2283      bra lab_1b78        * go do functions
00001376                          2284  
00001376                          2285                      * was token for > = or < (d0 = 0, 1 or 2)
00001376                          2286  lab_1ae0
00001376  7201                    2287      moveq   #1,d1           * set to 0000 0001
00001378  E121                    2288      asl.b   d0,d1           * 1 if >, 2 if =, 4 if <
0000137A  1039 000405EC           2289      move.b  comp_f,d0       * copy old compare function flag
00001380  13C1 000405EC           2290      move.b  d1,comp_f       * save this compare function bit
00001386  B139 000405EC           2291      eor.b   d0,comp_f       * EOR in the old compare function flag
0000138C  B039 000405EC           2292      cmp.b   comp_f,d0       * compare old with new compare function flag
00001392  6400 F43C               2293      bcc lab_sner        * if <=(new comp_f) do syntax error/warm start
00001396                          2294                      * was more than one <, = or >)
00001396  6100 016A               2295      bsr lab_igby        * increment & scan memory
0000139A  60C2                    2296      bra.s   lab_1ade        * go do next character
0000139C                          2297  
0000139C                          2298                      * token is < ">" or > "<" tokens
0000139C                          2299  lab_1afa
0000139C  4A39 000405EC           2300      tst.b   comp_f          * test compare function flag
000013A2  6644                    2301      bne.s   lab_1b2a        * branch if compare function
000013A4                          2302  
000013A4                          2303                      * was <  TK_GT so is operator or lower
000013A4  0600 000A               2304      add.b   #(tk_gt-tk_plus),d0 * add # of operators (+ - * / ^ AND OR EOR)
000013A8  6400 00AC               2305      bcc lab_1b78        * branch if < + operator
000013AC                          2306  
000013AC  660A                    2307      bne.s   lab_1b0b        * branch if not + token
000013AE                          2308  
000013AE  4A39 000405BD           2309      tst.b   dtypef          * test data type, $80=string, $40=integer, $00=float
000013B4  6B00 09D6               2310      bmi lab_224d        * type is string & token was +
000013B8                          2311  
000013B8                          2312  lab_1b0b
000013B8  C0FC 0006               2313      mulu    #6,d0           * *6
000013BC  7200                    2314      moveq   #0,d1           * clear longword
000013BE  1200                    2315      move.b  d0,d1           * copy to index
000013C0                          2316  lab_1b13
000013C0  301F                    2317      move.w  (sp)+,d0        * pull previous precedence
000013C2  41FA 2378               2318      lea (lab_oppt,pc),a0    * set pointer to operator table
000013C6  B070 1000               2319      cmp.w   (a0,d1.w),d0        * compare with this opperator precedence
000013CA  6400 0090               2320      bcc lab_1b7d        * branch if previous precedence (d0) >=
000013CE                          2321  
000013CE  6100 FF56               2322      bsr lab_ctnm        * check if source is numeric, else type mismatch
000013D2                          2323  lab_1b1c
000013D2  3F00                    2324      move.w  d0,-(sp)        * save precedence
000013D4                          2325  lab_1b1d
000013D4  6142                    2326      bsr.s   lab_1b43        * get vector, set-up operator, continue evaluation
000013D6  301F                    2327      move.w  (sp)+,d0        * restore precedence
000013D8  2239 000405E0           2328      move.l  prstk,d1        * get stacked function pointer
000013DE  6A2C                    2329      bpl.s   lab_1b3c        * branch if stacked values
000013E0                          2330  
000013E0  3000                    2331      move.w  d0,d0           * copy precedence (set flags)
000013E2  6776                    2332      beq.s   lab_1b7b        * exit if done
000013E4                          2333  
000013E4  6000 0086               2334      bra lab_1b86        * else pop FAC2 & return (do function)
000013E8                          2335  
000013E8                          2336                      * was compare function (< = >)
000013E8                          2337  lab_1b2a
000013E8  1039 000405BD           2338      move.b  dtypef,d0       * get data type flag
000013EE  1239 000405EC           2339      move.b  comp_f,d1       * get compare function flag
000013F4                          2340  *   lsl.b   #1,d0           * string bit flag into X bit
000013F4                          2341  *   roxl.b  #1,d1           * shift compare function flag
000013F4                          2342  
000013F4  D000                    2343      add.b   d0,d0           * string bit flag into X bit
000013F6  D301                    2344      addx.b  d1,d1           * shift compare function flag
000013F8                          2345  
000013F8  13FC 0000 000405BD      2346      move.b  #0,dtypef       * clear data type flag, $00=float
00001400  13C1 000405EC           2347      move.b  d1,comp_f       * save new compare function flag
00001406  534D                    2348      subq.w  #1,a5           * decrement BASIC execute pointer
00001408  7248                    2349      moveq   #(tk_lt-tk_plus)*6,d1   * set offset to last operator entry
0000140A  60B4                    2350      bra.s   lab_1b13        * branch always
0000140C                          2351  
0000140C                          2352  lab_1b3c
0000140C  41FA 232E               2353      lea (lab_oppt,pc),a0    * point to function vector table
00001410  B070 1000               2354      cmp.w   (a0,d1.w),d0        * compare with this opperator precedence
00001414  6456                    2355      bcc.s   lab_1b86        * branch if d0 >=, pop FAC2 & return
00001416                          2356  
00001416  60BA                    2357      bra.s   lab_1b1c        * branch always
00001418                          2358  
00001418                          2359  * get vector, set up operator then continue evaluation
00001418                          2360  
00001418                          2361  lab_1b43
00001418  41FA 2322               2362      lea (lab_oppt,pc),a0    * point to operator vector table
0000141C  2F30 1002               2363      move.l  2(a0,d1.w),-(sp)    * put vector on stack
00001420  610A                    2364      bsr.s   lab_1b56        * function set up will return here, then the
00001422                          2365                      * next RTS will call the function
00001422  1039 000405EC           2366      move.b  comp_f,d0       * get compare function flag
00001428  6000 FF20               2367      bra lab_1acc        * continue evaluating expression
0000142C                          2368  
0000142C                          2369  lab_1b56
0000142C  1039 00040599           2370      move.b  fac1_s,d0       * get FAC1 sign (b7)
00001432  3230 1000               2371      move.w  (a0,d1.w),d1        * get precedence value
00001436  23DF 000405A8           2372      move.l  (sp)+,ut1_pl        * copy return address to utility pointer
0000143C  13C0 00040599           2373      move.b  d0,fac1_s       * set sign
00001442  2F39 00040594           2374      move.l  fac1_m,-(sp)        * push FAC1 mantissa
00001448  3F39 00040598           2375      move.w  fac1_e,-(sp)        * push sign and exponent
0000144E  2F39 000405A8           2376      move.l  ut1_pl,-(sp)        * push address
00001454  4E75                    2377      rts             * return
00001456                          2378  
00001456                          2379  * do functions
00001456                          2380  
00001456                          2381  lab_1b78
00001456  72FF                    2382      moveq   #-1,d1          * flag all done
00001458  301F                    2383      move.w  (sp)+,d0        * pull precedence word
0000145A                          2384  lab_1b7b
0000145A  6742                    2385      beq.s   lab_1b9d        * exit if done
0000145C                          2386  
0000145C                          2387  lab_1b7d
0000145C  B07C 0064               2388      cmp.w   #$64,d0         * compare previous precedence with $64
00001460  6704                    2389      beq.s   lab_1b84        * branch if was $64 (< function can be string)
00001462                          2390  
00001462  6100 FEC2               2391      bsr lab_ctnm        * check if source is numeric, else type mismatch
00001466                          2392  lab_1b84
00001466  23C1 000405E0           2393      move.l  d1,prstk        * save current operator index
0000146C                          2394  
0000146C                          2395                      * pop FAC2 & return
0000146C                          2396  lab_1b86
0000146C  301F                    2397      move.w  (sp)+,d0        * pop comparison evaluation
0000146E  1200                    2398      move.b  d0,d1           * copy comparison evaluation flag
00001470  E208                    2399      lsr.b   #1,d0           * shift out comparison evaluation lowest bit
00001472  13C0 000405E9           2400      move.b  d0,cflag        * save comparison evaluation flag
00001478  33DF 000405A0           2401      move.w  (sp)+,fac2_e        * pop exponent and sign
0000147E  23DF 0004059C           2402      move.l  (sp)+,fac2_m        * pop mantissa
00001484  13F9 000405A1 000405A2  2403      move.b  fac2_s,fac_sc       * copy FAC2 sign
0000148E  1039 00040599           2404      move.b  fac1_s,d0       * get FAC1 sign
00001494  B139 000405A2           2405      eor.b   d0,fac_sc       * EOR FAC1 sign and set sign compare
0000149A                          2406  
0000149A  E209                    2407      lsr.b   #1,d1           * type bit into X and C
0000149C  4E75                    2408      rts
0000149E                          2409  
0000149E                          2410  lab_1b9d
0000149E  1039 00040598           2411      move.b  fac1_e,d0       * get FAC1 exponent
000014A4  4E75                    2412      rts
000014A6                          2413  
000014A6                          2414  * get value from line
000014A6                          2415  
000014A6                          2416  lab_gval
000014A6  13FC 0000 000405BD      2417      move.b  #$00,dtypef     * clear data type flag, $00=float
000014AE                          2418  lab_1ba4
000014AE  6100 0052               2419      bsr lab_igby        * increment & scan memory
000014B2  6500 1BA4               2420      bcs lab_2887        * if numeric get FAC1 from string & return
000014B6                          2421  
000014B6  4A00                    2422      tst.b   d0          * test byte
000014B8  6B00 008A               2423      bmi lab_1bd0        * if -ve go test token values
000014BC                          2424  
000014BC                          2425                      * else is either string, number, variable or (<expr>)
000014BC  B03C 0024               2426      cmp.b   #'$',d0         * compare with "$"
000014C0  6700 1B96               2427      beq lab_2887        * if "$" get hex number from string & return
000014C4                          2428  
000014C4  B03C 0025               2429      cmp.b   #'%',d0         * else compare with "%"
000014C8  6700 1B8E               2430      beq lab_2887        * if "%" get binary number from string & return
000014CC                          2431  
000014CC  B03C 002E               2432      cmp.b   #$2e,d0         * compare with "."
000014D0  6700 1B86               2433      beq lab_2887        * if so get FAC1 from string & return (e.g. .123)
000014D4                          2434  
000014D4                          2435                      * wasn't a number so ...
000014D4  B03C 0022               2436      cmp.b   #$22,d0         * compare with "
000014D8  660C                    2437      bne.s   lab_1bf3        * if not open quote must be variable or open bracket
000014DA                          2438  
000014DA                          2439                      * was open quote so get the enclosed string
000014DA                          2440  
000014DA                          2441  * print "..." string to string stack
000014DA                          2442  
000014DA                          2443  lab_1bc1
000014DA  524D                    2444      addq.w  #1,a5           * increment basic execute pointer (past ")
000014DC  204D                    2445      movea.l a5,a0           * copy basic execute pointer (string start)
000014DE  6100 0706               2446      bsr lab_20ae        * print " terminated string to stack
000014E2  2A4A                    2447      movea.l a2,a5           * restore BASIC execute pointer from temp
000014E4  4E75                    2448      rts
000014E6                          2449  
000014E6                          2450  * get value from line .. continued
000014E6                          2451                      * wasn't any sort of number so ...
000014E6                          2452  lab_1bf3
000014E6  B03C 0028               2453      cmp.b   #'(',d0         * compare with "("
000014EA  663A                    2454      bne.s   lab_1c18        * if not "(" get (var), return value in FAC1 & $ flag
000014EC                          2455  
000014EC  524D                    2456      addq.w  #1,a5           * increment execute pointer
000014EE                          2457  
000014EE                          2458  * evaluate expression within parentheses
000014EE                          2459  
000014EE                          2460  lab_1bf7
000014EE  6100 FE54               2461      bsr lab_evex        * evaluate expression
000014F2                          2462  
000014F2                          2463  * all the 'scan for' routines return the character after the sought character
000014F2                          2464  
000014F2                          2465  * scan for ")" , else do syntax error, then warm start
000014F2                          2466  
000014F2                          2467  lab_1bfb
000014F2  7029                    2468      moveq   #$29,d0         * load d0 with ")"
000014F4  6006                    2469      bra.s   lab_scca
000014F6                          2470  
000014F6                          2471  * scan for "(" , else do syntax error, then warm start
000014F6                          2472  
000014F6                          2473  lab_1bfe
000014F6  7028                    2474      moveq   #$28,d0         * load d0 with "("
000014F8  6002                    2475      bra.s   lab_scca
000014FA                          2476  
000014FA                          2477  * scan for "," , else do syntax error, then warm start
000014FA                          2478  
000014FA                          2479  lab_1c01
000014FA  702C                    2480      moveq   #$2c,d0         * load d0 with ","
000014FC                          2481  
000014FC                          2482  * scan for CHR$(d0) , else do syntax error, then warm start
000014FC                          2483  
000014FC                          2484  lab_scca
000014FC  B015                    2485      cmp.b   (a5),d0         * check next byte is = d0
000014FE  6600 F2D0               2486      bne lab_sner        * if not do syntax error/warm start
00001502                          2487  
00001502                          2488                      * else get next BASIC byte
00001502                          2489  
00001502                          2490  * BASIC increment and scan memory routine
00001502                          2491  
00001502                          2492  lab_igby
00001502  524D                    2493      addq.w  #1,a5           * increment pointer
00001504                          2494  
00001504                          2495  * scan memory routine, exit with Cb = 1 if numeric character
00001504                          2496  * also skips any spaces encountered
00001504                          2497  
00001504                          2498  lab_gbyt
00001504  1015                    2499      move.b  (a5),d0         * get byte
00001506                          2500  
00001506  B03C 0020               2501      cmp.b   #$20,d0         * compare with " "
0000150A  67F6                    2502      beq.s   lab_igby        * if " " go do next
0000150C                          2503  
0000150C                          2504  * test current BASIC byte, exit with Cb = 1 if numeric character
0000150C                          2505  
0000150C                          2506  lab_tbyt
0000150C  B03C 003A               2507      cmp.b   #$3a,d0         * compare with ":"
00001510  6408                    2508      bcc.s   rts_001         * exit if >= (not numeric, carry clear)
00001512                          2509  
00001512  0400 0030               2510      subi.b  #$30,d0         * subtract "0"
00001516  0400 00D0               2511      subi.b  #$d0,d0         * subtract -"0"
0000151A                          2512  rts_001                 * carry set if byte = "0"-"9"
0000151A  4E75                    2513      rts
0000151C                          2514  
0000151C                          2515  * set-up for - operator
0000151C                          2516  
0000151C                          2517  lab_1c11
0000151C  323C 003C               2518      move.w  #(tk_gt-tk_plus)*6,d1   * set offset from base to - operator
00001520                          2519  lab_1c13
00001520  584F                    2520      addq.w  #4,sp           * dump GVAL return address
00001522  6000 FEB0               2521      bra lab_1b1d        * continue evaluating expression
00001526                          2522  
00001526                          2523  * variable name set-up
00001526                          2524  * get (var), return value in FAC_1 & data type flag
00001526                          2525  
00001526                          2526  lab_1c18
00001526  6100 01F4               2527      bsr lab_gvar        * get (var) address
0000152A                          2528                      * return pointer to variable in Cvaral and a0
0000152A                          2529  lab_1c19
0000152A  4A39 000405BD           2530      tst.b   dtypef          * test data type, $80=string, $40=integer, $00=float
00001530  6700 0F96               2531      beq lab_ufac        * if float unpack memory (a0) into FAC1 & return
00001534                          2532  
00001534  6A08                    2533      bpl.s   lab_1c1a        * if integer unpack memory (a0) into FAC1 & return
00001536                          2534  
00001536  23C8 00040594           2535      move.l  a0,fac1_m       * save address in FAC1
0000153C  4E75                    2536      rts
0000153E                          2537  
0000153E                          2538  lab_1c1a
0000153E  2010                    2539      move.l  (a0),d0         * get integer value
00001540  6000 0552               2540      bra lab_ayfc        * convert d0 to signed longword in FAC1 & return
00001544                          2541  
00001544                          2542  * get value from line .. continued
00001544                          2543  * do tokens
00001544                          2544  
00001544                          2545  lab_1bd0
00001544  B03C 00B2               2546      cmp.b   #tk_minus,d0        * compare with token for -
00001548  67D2                    2547      beq.s   lab_1c11        * branch if - token (do set-up for - operator)
0000154A                          2548  
0000154A                          2549                      * wasn't -123 so ...
0000154A  B03C 00B1               2550      cmp.b   #tk_plus,d0     * compare with token for +
0000154E  6700 FF5E               2551      beq lab_1ba4        * branch if + token (+n = n so ignore leading +)
00001552                          2552  
00001552  B03C 00AD               2553      cmp.b   #tk_not,d0      * compare with token for NOT
00001556  6606                    2554      bne.s   lab_1be7        * branch if not token for NOT
00001558                          2555  
00001558                          2556                      * was NOT token
00001558  323C 0042               2557      move.w  #(tk_equal-tk_plus)*6,d1 * offset to NOT function
0000155C  60C2                    2558      bra.s   lab_1c13        * do set-up for function then execute
0000155E                          2559  
0000155E                          2560                      * wasn't +, - or NOT so ...
0000155E                          2561  lab_1be7
0000155E  B03C 00AA               2562      cmp.b   #tk_fn,d0       * compare with token for FN
00001562  6700 05CA               2563      beq lab_201e        * if FN go evaluate FNx
00001566                          2564  
00001566                          2565                      * wasn't +, -, NOT or FN so ...
00001566  B03C 00BE               2566      cmp.b   #tk_sgn,d0      * compare with token for SGN
0000156A  6500 F264               2567      bcs lab_sner        * if < SGN token then do syntax error
0000156E                          2568  
0000156E                          2569  * get value from line ..
0000156E                          2570  * only functions left so ...
0000156E                          2571  * set up function references
0000156E                          2572  
0000156E                          2573  lab_1c27
0000156E  C07C 007F               2574      and.w   #$7f,d0         * normalise and mask byte
00001572  E540                    2575      asl.w   #2,d0           * *4 (4 bytes per function address)
00001574  3F00                    2576      move.w  d0,-(sp)        * push offset
00001576  3200                    2577      move.w  d0,d1           * copy offset
00001578  6188                    2578      bsr lab_igby        * increment & scan memory
0000157A  B27C 0159               2579      cmp.w   #(tk_chrs-$80)*4+1,d1   * compare function offset to CHR$ token offset+1
0000157E  656A                    2580      bcs.s   lab_1c51        * branch if <HEX$ (can not be =)
00001580                          2581  
00001580                          2582  * get value from line .. continued
00001580                          2583  * was HEX$, BIN$, VARPTR, LEFT$, RIGHT$ or MID$ so..
00001580                          2584  
00001580  B27C 0161               2585      cmp.w   #(tk_bins-$80)*4+1,d1   * compare function offset to BIN$ token offset+1
00001584  652C                    2586      bcs.s   lab_bhss        * branch if <BITTST (can not be =)
00001586                          2587  
00001586  B27C 0179               2588      cmp.w   #(tk_vptr-$80)*4+1,d1   * compare function offset VARPTR token offset+1
0000158A  6566                    2589      bcs.s   lab_1c54        * branch if <LEFT$ (can not be =)
0000158C                          2590  
0000158C                          2591  * get value from line .. continued
0000158C                          2592  * was LEFT$, RIGHT$ or MID$ so..
0000158C                          2593  
0000158C  6100 FF68               2594      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
00001590  6100 FDB2               2595      bsr lab_evex        * evaluate (should be string) expression
00001594  6100 FF64               2596      bsr lab_1c01        * scan for "," , else do syntax error/warm start
00001598  6100 FD90               2597      bsr lab_ctst        * check source is string, else do type mismatch
0000159C  3E1F                    2598      move.w  (sp)+,d7        * restore offset
0000159E  2F39 00040594           2599      move.l  fac1_m,-(sp)        * push descriptor pointer
000015A4  3F07                    2600      move.w  d7,-(sp)        * push function offset
000015A6  6100 09C2               2601      bsr lab_gtwo        * get word parameter, result in d0 and Itemp
000015AA  3E1F                    2602      move.w  (sp)+,d7        * restore offset
000015AC  3F00                    2603      move.w  d0,-(sp)        * push word parameter
000015AE  3007                    2604      move.w  d7,d0           * function offset to d0
000015B0  6042                    2605      bra.s   lab_1c56        * go call function
000015B2                          2606  
000015B2                          2607  * get value from line .. continued
000015B2                          2608  * was BIN$ or HEX$ so ..
000015B2                          2609  
000015B2                          2610  lab_bhss
000015B2  6100 FF42               2611      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
000015B6  6100 FD6C               2612      bsr lab_evnm        * evaluate expression & check is numeric,
000015BA                          2613                      * else do type mismatch
000015BA  6100 1038               2614      bsr lab_2831        * convert FAC1 floating-to-fixed
000015BE                          2615                      * result in d0 and Itemp
000015BE  6100 FF44               2616      bsr lab_gbyt        * get next BASIC byte
000015C2  7200                    2617      moveq   #0,d1           * set default to no leading "0"s
000015C4  B03C 0029               2618      cmp.b   #')',d0         * compare with close bracket
000015C8  6728                    2619      beq.s   lab_1c54        * if ")" go do rest of function
000015CA                          2620  
000015CA  2F39 0004042E           2621      move.l  itemp,-(sp)     * copy longword to stack (number)
000015D0  6100 0978               2622      bsr lab_scgb        * scan for "," and get byte value
000015D4  2200                    2623      move.l  d0,d1           * copy leading 0s #
000015D6  6100 FF2C               2624      bsr lab_gbyt        * get next BASIC byte
000015DA  B03C 0029               2625      cmp.b   #')',d0         * is next character )
000015DE  6600 F1E4               2626      bne lab_fcer        * if not ")" do function call error/warm start
000015E2                          2627  
000015E2  23DF 0004042E           2628      move.l  (sp)+,itemp     * restore number form stack
000015E8  6008                    2629      bra.s   lab_1c54        * go do rest of function
000015EA                          2630  
000015EA                          2631  * get value from line .. continued
000015EA                          2632  * was SGN() to CHR$() so..
000015EA                          2633  
000015EA                          2634  lab_1c51
000015EA  6100 FF0A               2635      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
000015EE  6100 FEFE               2636      bsr lab_1bf7        * evaluate expression within parentheses
000015F2                          2637  
000015F2                          2638                      * enter here if VARPTR(), MAX() or MIN()
000015F2                          2639  lab_1c54
000015F2  301F                    2640      move.w  (sp)+,d0        * get offset back
000015F4                          2641  lab_1c56
000015F4  41FA 1FBE               2642      lea (lab_ftbl,pc),a0    * pointer to functions vector table
000015F8  2070 0000               2643      movea.l (a0,d0.w),a0        * get function vector
000015FC  4E90                    2644      jsr (a0)            * go do function vector
000015FE  6000 FD26               2645      bra lab_ctnm        * check if source is numeric & RTS, else do
00001602                          2646                      * type mismatch
00001602                          2647  * perform EOR
00001602                          2648  
00001602                          2649  lab_eor
00001602  6120                    2650      bsr.s   getfirst        * get two values for OR, AND or EOR
00001604                          2651                      * first in d0, and Itemp, second in d2
00001604  B5B9 0004042E           2652      eor.l   d2,itemp        * EOR with first value
0000160A  2039 0004042E           2653      move.l  itemp,d0        * get result
00001610  6000 0482               2654      bra lab_ayfc        * convert d0 to signed longword in FAC1 & RET
00001614                          2655  
00001614                          2656  * perform OR
00001614                          2657  
00001614                          2658  lab_or
00001614  610E                    2659      bsr.s   getfirst        * get two values for OR, AND or EOR
00001616                          2660                      * first in d0, and Itemp, second in d2
00001616  8082                    2661      or.l    d2,d0           * do OR
00001618  6000 047A               2662      bra lab_ayfc        * convert d0 to signed longword in FAC1 & RET
0000161C                          2663  
0000161C                          2664  * perform AND
0000161C                          2665  
0000161C                          2666  lab_and
0000161C  6106                    2667      bsr.s   getfirst        * get two values for OR, AND or EOR
0000161E                          2668                      * first in d0, and Itemp, second in d2
0000161E  C082                    2669      and.l   d2,d0           * do AND
00001620  6000 0472               2670      bra lab_ayfc        * convert d0 to signed longword in FAC1 & RET
00001624                          2671  
00001624                          2672  * get two values for OR, AND, EOR
00001624                          2673  * first in d0, second in d2
00001624                          2674  
00001624                          2675  getfirst
00001624  6100 026C               2676      bsr lab_evir        * evaluate integer expression (no sign check)
00001628                          2677                      * result in d0 and Itemp
00001628  2400                    2678      move.l  d0,d2           * copy second value
0000162A  6100 0F04               2679      bsr lab_279b        * copy FAC2 to FAC1 (get 1st value in expression)
0000162E  6100 0262               2680      bsr lab_evir        * evaluate integer expression (no sign check)
00001632                          2681                      * result in d0 and Itemp
00001632  4E75                    2682      rts
00001634                          2683  
00001634                          2684  * perform NOT
00001634                          2685  
00001634                          2686  lab_equal
00001634  6100 025C               2687      bsr lab_evir        * evaluate integer expression (no sign check)
00001638                          2688                      * result in d0 and Itemp
00001638  4680                    2689      not.l   d0          * bitwise invert
0000163A  6000 0458               2690      bra lab_ayfc        * convert d0 to signed longword in FAC1 & RET
0000163E                          2691  
0000163E                          2692  * perform comparisons
0000163E                          2693  * do < compare
0000163E                          2694  
0000163E                          2695  lab_lthan
0000163E  6100 FCEE               2696      bsr lab_cktm        * type match check, set C for string
00001642  6506                    2697      bcs.s   lab_1cae        * branch if string
00001644                          2698  
00001644                          2699                      * do numeric < compare
00001644  6100 0F76               2700      bsr lab_27fa        * compare FAC1 with FAC2
00001648                          2701                      * returns d0=+1 if FAC1 > FAC2
00001648                          2702                      * returns d0= 0 if FAC1 = FAC2
00001648                          2703                      * returns d0=-1 if FAC1 < FAC2
00001648  6046                    2704      bra.s   lab_1cf2        * process result
0000164A                          2705  
0000164A                          2706                      * do string < compare
0000164A                          2707  lab_1cae
0000164A  13FC 0000 000405BD      2708      move.b  #$00,dtypef     * clear data type, $80=string, $40=integer, $00=float
00001652  6100 07B6               2709      bsr lab_22b6        * pop string off descriptor stack, or from top of
00001656                          2710                      * string space returns d0 = length, a0 = pointer
00001656  2248                    2711      movea.l a0,a1           * copy string 2 pointer
00001658  2200                    2712      move.l  d0,d1           * copy string 2 length
0000165A  2079 0004059C           2713      movea.l fac2_m,a0       * get string 1 descriptor pointer
00001660  6100 07AE               2714      bsr lab_22ba        * pop (a0) descriptor, returns with ..
00001664                          2715                      * d0 = length, a0 = pointer
00001664  2400                    2716      move.l  d0,d2           * copy length
00001666  6604                    2717      bne.s   lab_1cb5        * branch if not null string
00001668                          2718  
00001668  4A81                    2719      tst.l   d1          * test if string 2 is null also
0000166A  6724                    2720      beq.s   lab_1cf2        * if so do string 1 = string 2
0000166C                          2721  
0000166C                          2722  lab_1cb5
0000166C  9481                    2723      sub.l   d1,d2           * subtract string 2 length
0000166E  670C                    2724      beq.s   lab_1cd5        * branch if strings = length
00001670                          2725  
00001670  6504                    2726      bcs.s   lab_1cd4        * branch if string 1 < string 2
00001672                          2727  
00001672  70FF                    2728      moveq   #-1,d0          * set for string 1 > string 2
00001674  6008                    2729      bra.s   lab_1cd6        * go do character comapare
00001676                          2730  
00001676                          2731  lab_1cd4
00001676  2200                    2732      move.l  d0,d1           * string 1 length is compare length
00001678  7001                    2733      moveq   #1,d0           * and set for string 1 < string 2
0000167A  6002                    2734      bra.s   lab_1cd6        * go do character comapare
0000167C                          2735  
0000167C                          2736  lab_1cd5
0000167C  2002                    2737      move.l  d2,d0           * set for string 1 = string 2
0000167E                          2738  lab_1cd6
0000167E  5381                    2739      subq.l  #1,d1           * adjust length for DBcc loop
00001680                          2740  
00001680                          2741                      * d1 is length to compare, d0 is < = > for length
00001680                          2742                      * a0 is string 1 pointer, a1 is string 2 pointer
00001680                          2743  lab_1ce6
00001680  B308                    2744      cmpm.b  (a0)+,(a1)+     * compare string bytes (1 with 2)
00001682  56C9 FFFC               2745      dbne    d1,lab_1ce6     * loop if same and not end yet
00001686                          2746  
00001686  6708                    2747      beq.s   lab_1cf2        * if = to here, then go use length compare
00001688                          2748  
00001688  6404                    2749      bcc.s   lab_1cdb        * else branch if string 1 > string 2
0000168A                          2750  
0000168A  70FF                    2751      moveq   #-1,d0          * else set for string 1 < string 2
0000168C  6002                    2752      bra.s   lab_1cf2        * go set result
0000168E                          2753  
0000168E                          2754  lab_1cdb
0000168E  7001                    2755      moveq   #1,d0           * and set for string 1 > string 2
00001690                          2756  
00001690                          2757  lab_1cf2
00001690  5280                    2758      addq.l  #1,d0           * make result 0, 1 or 2
00001692  2200                    2759      move.l  d0,d1           * copy to d1
00001694  7001                    2760      moveq   #1,d0           * set d0
00001696  E3B8                    2761      rol.l   d1,d0           * make 1, 2 or 4 (result = flag bit)
00001698  C039 000405E9           2762      and.b   cflag,d0        * AND with comparison evaluation flag
0000169E  6700 0EFA               2763      beq lab_27db        * exit if not a wanted result (i.e. false)
000016A2                          2764  
000016A2  70FF                    2765      moveq   #-1,d0          * else set -1 (true)
000016A4  6000 0EF4               2766      bra lab_27db        * save d0 as integer & return
000016A8                          2767  
000016A8                          2768  
000016A8                          2769  lab_1cfe
000016A8  6100 FE50               2770      bsr lab_1c01        * scan for "," , else do syntax error/warm start
000016AC                          2771  
000016AC                          2772  * perform DIM
000016AC                          2773  
000016AC                          2774  lab_dim
000016AC  72FF                    2775      moveq   #-1,d1          * set "DIM" flag
000016AE  6172                    2776      bsr.s   lab_1d10        * search for variable
000016B0  6100 FE52               2777      bsr lab_gbyt        * scan memory
000016B4  66F2                    2778      bne.s   lab_1cfe        * loop and scan for "," if not null
000016B6                          2779  
000016B6  4E75                    2780      rts
000016B8                          2781  
000016B8                          2782  * perform << (left shift)
000016B8                          2783  
000016B8                          2784  lab_lshift
000016B8  612E                    2785      bsr.s   getpair         * get an integer and byte pair
000016BA                          2786                      * byte is in d2, integer is in d0 and Itemp
000016BA  6708                    2787      beq.s   noshift         * branch if byte zero
000016BC                          2788  
000016BC  B43C 0020               2789      cmp.b   #$20,d2         * compare bit count with 32d
000016C0  6420                    2790      bcc.s   toobig          * branch if >=
000016C2                          2791  
000016C2  E5A0                    2792      asl.l   d2,d0           * shift longword
000016C4                          2793  noshift
000016C4  6000 03CE               2794      bra lab_ayfc        * convert d0 to signed longword in FAC1 & RET
000016C8                          2795  
000016C8                          2796  * perform >> (right shift)
000016C8                          2797  
000016C8                          2798  lab_rshift
000016C8  611E                    2799      bsr.s   getpair         * get an integer and byte pair
000016CA                          2800                      * byte is in d2, integer is in d0 and Itemp
000016CA  67F8                    2801      beq.s   noshift         * branch if byte zero
000016CC                          2802  
000016CC  B43C 0020               2803      cmp.b   #$20,d2         * compare bit count with 32d
000016D0  650A                    2804      bcs.s   not2big         * branch if >= (return shift)
000016D2                          2805  
000016D2  4A80                    2806      tst.l   d0          * test sign bit
000016D4  6A0C                    2807      bpl.s   toobig          * branch if +ve
000016D6                          2808  
000016D6  70FF                    2809      moveq   #-1,d0          * set longword
000016D8  6000 03BA               2810      bra lab_ayfc        * convert d0 to longword in FAC1 & RET
000016DC                          2811  
000016DC                          2812  not2big
000016DC  E4A0                    2813      asr.l   d2,d0           * shift longword
000016DE  6000 03B4               2814      bra lab_ayfc        * convert d0 to longword in FAC1 & RET
000016E2                          2815  
000016E2                          2816  toobig
000016E2  7000                    2817      moveq   #0,d0           * clear longword
000016E4  6000 03AE               2818      bra lab_ayfc        * convert d0 to longword in FAC1 & RET
000016E8                          2819  
000016E8                          2820  * get an integer and byte pair
000016E8                          2821  * byte is in d2, integer is in d0 and Itemp
000016E8                          2822  
000016E8                          2823  getpair
000016E8  6100 086E               2824      bsr lab_evby        * evaluate byte expression, result in d0 and Itemp
000016EC  1400                    2825      move.b  d0,d2           * save it
000016EE  6100 0E40               2826      bsr lab_279b        * copy FAC2 to FAC1 (get 1st value in expression)
000016F2  6100 019E               2827      bsr lab_evir        * evaluate integer expression (no sign check)
000016F6                          2828                      * result in d0 and Itemp
000016F6  4A02                    2829      tst.b   d2          * test byte value
000016F8  4E75                    2830      rts
000016FA                          2831  
000016FA                          2832  * check byte, return C=0 if<"A" or >"Z" or <"a" to "z">
000016FA                          2833  
000016FA                          2834  lab_casc
000016FA  B03C 0061               2835      cmp.b   #$61,d0         * compare with "a"
000016FE  6412                    2836      bcc.s   lab_1d83        * if >="a" go check =<"z"
00001700                          2837  
00001700                          2838  * check byte, return C=0 if<"A" or >"Z"
00001700                          2839  
00001700                          2840  lab_1d82
00001700  B03C 005B               2841      cmp.b   #$5b,d0         * compare with "Z"+1
00001704  6502                    2842      bcs.s   lab_1d8a        * if <="Z" go check >="A"
00001706                          2843  
00001706  4E75                    2844      rts
00001708                          2845  
00001708                          2846  lab_1d8a
00001708  0400 0041               2847      sub.b   #$41,d0         * subtract "A"
0000170C  0400 00BF               2848      sub.b   #$bf,d0         * subtract $BF (restore byte)
00001710                          2849                      * carry set if byte>$40
00001710  4E75                    2850      rts
00001712                          2851  
00001712                          2852  lab_1d83
00001712  0600 0085               2853      add.b   #$85,d0         * add $85
00001716  0600 007B               2854      add.b   #$7b,d0         * add "z"+1 (restore byte)
0000171A                          2855                      * carry set if byte<=$7A
0000171A  4E75                    2856      rts
0000171C                          2857  
0000171C                          2858  * search for variable
0000171C                          2859  * DIM flag is in d1.b
0000171C                          2860  * return pointer to variable in Cvaral and a0
0000171C                          2861  * stet data type to variable type
0000171C                          2862  
0000171C                          2863  lab_gvar
0000171C  7200                    2864      moveq   #$00,d1         * set DIM flag = $00
0000171E  6100 FDE4               2865      bsr lab_gbyt        * scan memory (1st character)
00001722                          2866  lab_1d10
00001722  13C1 000405BC           2867      move.b  d1,defdim       * save DIM flag
00001728                          2868  
00001728                          2869  * search for FN name entry point
00001728                          2870  
00001728                          2871  lab_1d12
00001728  61D0                    2872      bsr.s   lab_casc        * check byte, return C=0 if<"A" or >"Z"
0000172A  6400 F0A4               2873      bcc lab_sner        * if not syntax error, then warm start
0000172E                          2874  
0000172E                          2875                      * is variable name so ...
0000172E  7200                    2876      moveq   #$0,d1          * set index for name byte
00001730  207C 0004046E           2877      movea.l #varname,a0     * pointer to variable name
00001736  2081                    2878      move.l  d1,(a0)         * clear variable name
00001738  13C1 000405BD           2879      move.b  d1,dtypef       * clear data type, $80=string, $40=integer, $00=float
0000173E                          2880  
0000173E                          2881  lab_1d2d
0000173E  B27C 0004               2882      cmp.w   #$04,d1         * done all significant characters?
00001742  6406                    2883      bcc.s   lab_1d2e        * if so go ignore any more
00001744                          2884  
00001744  1180 1000               2885      move.b  d0,(a0,d1.w)        * save character
00001748  5241                    2886      addq.w  #1,d1           * increment index
0000174A                          2887  lab_1d2e
0000174A  6100 FDB6               2888      bsr lab_igby        * increment & scan memory (next character)
0000174E  65EE                    2889      bcs.s   lab_1d2d        * branch if character = "0"-"9" (ok)
00001750                          2890  
00001750                          2891                      * character wasn't "0" to "9" so ...
00001750  61A8                    2892      bsr.s   lab_casc        * check byte, return C=0 if<"A" or >"Z"
00001752  65EA                    2893      bcs.s   lab_1d2d        * branch if = "A"-"Z" (ok)
00001754                          2894  
00001754                          2895                      * check if string variable
00001754  B03C 0024               2896      cmp.b   #'$',d0         * compare with "$"
00001758  660E                    2897      bne.s   lab_1d44        * branch if not string
0000175A                          2898  
0000175A                          2899                      * type is string
0000175A  0039 0080 0004046F      2900      or.b    #$80,varname+1      * set top bit of 2nd character (indicate string)
00001762  6100 FD9E               2901      bsr lab_igby        * increment & scan memory
00001766  6012                    2902      bra.s   lab_1d45        * skip integer check
00001768                          2903  
00001768                          2904                      * check if integer variable
00001768                          2905  lab_1d44
00001768  B03C 0026               2906      cmp.b   #'&',d0         * compare with "&"
0000176C  660C                    2907      bne.s   lab_1d45        * branch if not integer
0000176E                          2908  
0000176E                          2909                      * type is integer
0000176E  0039 0080 00040470      2910      or.b    #$80,varname+2      * set top bit of 3rd character (indicate integer)
00001776  6100 FD8A               2911      bsr lab_igby        * increment & scan memory
0000177A                          2912  
0000177A                          2913  * after we have determined the variable type we need to determine
0000177A                          2914  * if it's an array of type
0000177A                          2915  
0000177A                          2916                      * gets here with character after var name in d0
0000177A                          2917  lab_1d45
0000177A  4A39 000405E7           2918      tst.b   sufnxf          * test function name flag
00001780  6712                    2919      beq.s   lab_1d48        * branch if not FN or FN variable
00001782                          2920  
00001782  6A18                    2921      bpl.s   lab_1d49        * branch if FN variable
00001784                          2922  
00001784                          2923                      * else was FN name
00001784  2039 0004046E           2924      move.l  varname,d0      * get whole function name
0000178A  7208                    2925      moveq   #8,d1           * set step to next function size -4
0000178C  207C 00040436           2926      movea.l #sfncl,a0       * get pointer to start of functions
00001792  6020                    2927      bra.s   lab_1d4b        * go find function
00001794                          2928  
00001794                          2929  lab_1d48
00001794  0400 0028               2930      sub.b   #'(',d0         * subtract "("
00001798  6700 0128               2931      beq lab_1e17        * if "(" go find, or make, array
0000179C                          2932  
0000179C                          2933  * either find or create var
0000179C                          2934  * var name (1st four characters only!) is in Varname
0000179C                          2935  
0000179C                          2936                      * variable name wasn't var( .. look for plain var
0000179C                          2937  lab_1d49
0000179C  2039 0004046E           2938      move.l  varname,d0      * get whole variable name
000017A2                          2939  lab_1d4a
000017A2  7204                    2940      moveq   #4,d1           * set step to next variable size -4
000017A4  207C 0004043A           2941      movea.l #svarl,a0       * get pointer to start of variables
000017AA                          2942  
000017AA  0800 0017               2943      btst.l  #23,d0          * test if string name
000017AE  6704                    2944      beq.s   lab_1d4b        * branch if not
000017B0                          2945  
000017B0  5441                    2946      addq.w  #2,d1           * 10 bytes per string entry
000017B2  5848                    2947      addq.w  #(sstrl-svarl),a0   * move to string area
000017B4                          2948  
000017B4                          2949  lab_1d4b
000017B4  2268 0004               2950      movea.l 4(a0),a1        * get end address
000017B8  2050                    2951      movea.l (a0),a0         * get start address
000017BA  6006                    2952      bra.s   lab_1d5e        * enter loop at exit check
000017BC                          2953  
000017BC                          2954  lab_1d5d
000017BC  B098                    2955      cmp.l   (a0)+,d0        * compare this variable with name
000017BE  6774                    2956      beq.s   lab_1dd7        * branch if match (found var)
000017C0                          2957  
000017C0  D1C1                    2958      adda.l  d1,a0           * add offset to next variable
000017C2                          2959  lab_1d5e
000017C2  B1C9                    2960      cmpa.l  a1,a0           * compare address with variable space end
000017C4  66F6                    2961      bne.s   lab_1d5d        * if not end go check next
000017C6                          2962  
000017C6                          2963                      * reached end of variable mem without match
000017C6                          2964                      * ... so create new variable, possibly
000017C6  0C97 0000152A           2965      cmpi.l  #lab_1c19,(sp)      * compare return address with expected
000017CC  6700 EFBE               2966      beq lab_uver        * if RHS get (var) go do error or return null
000017D0                          2967  
000017D0                          2968  * This will only branch if the call was from LAB_1C18 and is only called from
000017D0                          2969  * there if it is searching for a variable from the RHS of a LET a=b statement
000017D0                          2970  
000017D0  0839 0000 000405E7      2971      btst.b  #0,sufnxf       * test function search flag
000017D8  6600 EFBA               2972      bne lab_ufer        * if not doing DEF then do undefined function error
000017DC                          2973  
000017DC                          2974                      * else create new variable/function
000017DC                          2975  lab_1d98
000017DC  2479 00040446           2976      movea.l earryl,a2       * get end of block to move
000017E2  240A                    2977      move.l  a2,d2           * copy end of block to move
000017E4  9489                    2978      sub.l   a1,d2           * calculate block to move size
000017E6                          2979  
000017E6  204A                    2980      movea.l a2,a0           * copy end of block to move
000017E8  5881                    2981      addq.l  #4,d1           * space for one variable/function + name
000017EA  D5C1                    2982      adda.l  d1,a2           * add space for one variable/function
000017EC  23CA 00040446           2983      move.l  a2,earryl       * set new array mem end
000017F2  E28A                    2984      lsr.l   #1,d2           * /2 for word copy
000017F4  6708                    2985      beq.s   lab_1daf        * skip move if zero length block
000017F6                          2986  
000017F6  5342                    2987      subq.w  #1,d2           * -1 for DFB loop
000017F8                          2988  lab_1dae
000017F8  3520                    2989      move.w  -(a0),-(a2)     * copy word
000017FA  51CA FFFC               2990      dbf d2,lab_1dae     * loop until done
000017FE                          2991  
000017FE                          2992  * get here after creating either a function, variable or string
000017FE                          2993  * if function set variables start, string start, array start
000017FE                          2994  * if variable set string start, array start
000017FE                          2995  * if string set array start
000017FE                          2996  
000017FE                          2997  lab_1daf
000017FE  4A39 000405E7           2998      tst.b   sufnxf          * was it function
00001804  6B08                    2999      bmi.s   lab_1db0        * branch if was FN
00001806                          3000  
00001806  0800 0017               3001      btst.l  #23,d0          * was it string
0000180A  660E                    3002      bne.s   lab_1db2        * branch if string
0000180C                          3003  
0000180C  6006                    3004      bra.s   lab_1db1        * branch if was plain variable
0000180E                          3005  
0000180E                          3006  lab_1db0
0000180E  D3B9 0004043A           3007      add.l   d1,svarl        * set new variable memory start
00001814                          3008  lab_1db1
00001814  D3B9 0004043E           3009      add.l   d1,sstrl        * set new start of strings
0000181A                          3010  lab_1db2
0000181A  D3B9 00040442           3011      add.l   d1,sarryl       * set new array memory start
00001820  20C0                    3012      move.l  d0,(a0)+        * save variable/function name
00001822  20BC 00000000           3013      move.l  #$00,(a0)       * initialise variable
00001828  0800 0017               3014      btst.l  #23,d0          * was it string
0000182C  6706                    3015      beq.s   lab_1dd7        * branch if not string
0000182E                          3016  
0000182E  317C 0000 0004          3017      move.w  #$00,4(a0)      * else initialise string length
00001834                          3018  
00001834                          3019                      * found a match for var ((Vrschl) = ptr)
00001834                          3020  lab_1dd7
00001834  13FC 0000 000405BD      3021      move.b  #$00,dtypef     * clear data type
0000183C  0800 0017               3022      btst.l  #23,d0          * was it string
00001840  670A                    3023      beq.s   lab_1dd8        * branch if not string
00001842                          3024  
00001842  13FC 0080 000405BD      3025      move.b  #$80,dtypef     * set data type = string
0000184A  600E                    3026      bra.s   lab_1dd9        * skip intger test
0000184C                          3027  
0000184C                          3028  lab_1dd8
0000184C  0800 000F               3029      btst.l  #15,d0          * was it integer
00001850  6708                    3030      beq.s   lab_1dd9        * branch if not integer
00001852                          3031  
00001852  13FC 0040 000405BD      3032      move.b  #$40,dtypef     * set data type = integer
0000185A                          3033  lab_1dd9
0000185A  23C8 00040472           3034      move.l  a0,cvaral       * save current variable/function value address
00001860  13FC 0000 000405E7      3035      move.b  #$00,sufnxf     * clear FN flag byte
00001868  4E75                    3036      rts
0000186A                          3037  
0000186A                          3038  * set-up array pointer, Adatal, to first element in array
0000186A                          3039  * set Adatal to Astrtl+2*Dimcnt+#$0A
0000186A                          3040  
0000186A                          3041  lab_1de6
0000186A  7000                    3042      moveq   #0,d0           * clear d0
0000186C  1039 000405E3           3043      move.b  dimcnt,d0       * get # of dimensions (1, 2 or 3)
00001872  5A80                    3044      addq.l  #5,d0           * +5 (actually 10d but addq is quicker)
00001874  D080                    3045      add.l   d0,d0           * *2 (bytes per dimension size)
00001876  D088                    3046      add.l   a0,d0           * add array start pointer
00001878  23C0 000405B0           3047      move.l  d0,adatal       * save array data pointer
0000187E  4E75                    3048      rts
00001880                          3049  
00001880                          3050  * evaluate unsigned integer expression
00001880                          3051  
00001880                          3052  lab_evin
00001880  6100 FC80               3053      bsr lab_igby        * increment & scan memory
00001884  6100 FA9E               3054      bsr lab_evnm        * evaluate expression & check is numeric,
00001888                          3055                      * else do type mismatch
00001888                          3056  
00001888                          3057  * evaluate positive integer expression, result in d0 and Itemp
00001888                          3058  
00001888                          3059  lab_evpi
00001888  4A39 00040599           3060      tst.b   fac1_s          * test FAC1 sign (b7)
0000188E  6B00 EF34               3061      bmi lab_fcer        * do function call error if -ve
00001892                          3062  
00001892                          3063  * evaluate integer expression, no sign check, result in d0 and Itemp
00001892                          3064  
00001892                          3065  lab_evir
00001892  0C39 00A0 00040598      3066      cmpi.b  #$a0,fac1_e     * compare exponent with exponent = 2^32 (n>2^31)
0000189A  6500 0D58               3067      bcs lab_2831        * convert FAC1 floating-to-fixed
0000189E                          3068                      * result in d0 and Itemp
0000189E  6600 EF24               3069      bne lab_fcer        * if > do function call error, then warm start
000018A2                          3070  
000018A2  4A39 00040599           3071      tst.b   fac1_s          * test sign of FAC1
000018A8  6A10                    3072      bpl.s   lab_evix        * if = and +ve then ok
000018AA                          3073  
000018AA  2039 00040594           3074      move.l  fac1_m,d0       * get mantissa
000018B0  B0BC 80000000           3075      cmp.l   #$80000000,d0       * compare -2147483648 with mantissa
000018B6  6600 EF0C               3076      bne lab_fcer        * if <> do function call error, then warm start
000018BA                          3077  
000018BA                          3078  lab_evix
000018BA  23C0 0004042E           3079      move.l  d0,itemp        * else just set it
000018C0  4E75                    3080      rts
000018C2                          3081  
000018C2                          3082  * find or make array
000018C2                          3083  
000018C2                          3084  lab_1e17
000018C2  3F39 000405BC           3085      move.w  defdim,-(sp)        * get DIM flag and data type flag (word in mem)
000018C8  7200                    3086      moveq   #0,d1           * clear dimensions count
000018CA                          3087  
000018CA                          3088  * now get the array dimension(s) and stack it (them) before the data type and DIM flag
000018CA                          3089  
000018CA                          3090  lab_1e1f
000018CA  3F01                    3091      move.w  d1,-(sp)        * save dimensions count
000018CC  2F39 0004046E           3092      move.l  varname,-(sp)       * save variable name
000018D2  61AC                    3093      bsr.s   lab_evin        * evaluate integer expression
000018D4  23DF 0004046E           3094      move.l  (sp)+,varname       * restore variable name
000018DA  321F                    3095      move.w  (sp)+,d1        * restore dimensions count
000018DC  301F                    3096      move.w  (sp)+,d0        * restore DIM and data type flags
000018DE  3F39 00040430           3097      move.w  itemp+2,-(sp)       * stack this dimension size
000018E4  3F00                    3098      move.w  d0,-(sp)        * save DIM and data type flags
000018E6  5241                    3099      addq.w  #1,d1           * increment dimensions count
000018E8  6100 FC1A               3100      bsr lab_gbyt        * scan memory
000018EC  B03C 002C               3101      cmp.b   #$2c,d0         * compare with ","
000018F0  67D8                    3102      beq.s   lab_1e1f        * if found go do next dimension
000018F2                          3103  
000018F2  13C1 000405E3           3104      move.b  d1,dimcnt       * store dimensions count
000018F8  6100 FBF8               3105      bsr lab_1bfb        * scan for ")" , else do syntax error/warm start
000018FC  33DF 000405BC           3106      move.w  (sp)+,defdim        * restore DIM and data type flags (word in mem)
00001902  2079 00040442           3107      movea.l sarryl,a0       * get array mem start
00001908                          3108  
00001908                          3109  * now check to see if we are at the end of array memory (we would be if there were
00001908                          3110  * no arrays).
00001908                          3111  
00001908                          3112  lab_1e5c
00001908  23C8 000405B4           3113      move.l  a0,astrtl       * save as array start pointer
0000190E  B1F9 00040446           3114      cmpa.l  earryl,a0       * compare with array mem end
00001914  6736                    3115      beq.s   lab_1ea1        * go build array if not found
00001916                          3116  
00001916                          3117                      * search for array
00001916  2010                    3118      move.l  (a0),d0         * get this array name
00001918  B0B9 0004046E           3119      cmp.l   varname,d0      * compare with array name
0000191E  670C                    3120      beq.s   lab_1e8d        * array found so branch
00001920                          3121  
00001920                          3122                      * no match
00001920  2068 0004               3123      movea.l 4(a0),a0        * get this array size
00001924  D1F9 000405B4           3124      adda.l  astrtl,a0       * add to array start pointer
0000192A  60DC                    3125      bra.s   lab_1e5c        * go check next array
0000192C                          3126  
0000192C                          3127                      * found array, are we trying to dimension it?
0000192C                          3128  lab_1e8d
0000192C  4A39 000405BC           3129      tst.b   defdim          * are we trying to dimension it?
00001932  6600 EE7C               3130      bne lab_dder        * if so do  double dimension error/warm start
00001936                          3131  
00001936                          3132  * found the array and we're not dimensioning it so we must find an element in it
00001936                          3133  
00001936  6100 FF32               3134      bsr lab_1de6        * set data pointer, Adatal, to the first element
0000193A                          3135                      * in the array. Astrtl (and a0) points to the
0000193A                          3136                      * start of the array
0000193A  5048                    3137      addq.w  #8,a0           * index to dimension count
0000193C  3018                    3138      move.w  (a0)+,d0        * get no of dimensions
0000193E  B039 000405E3           3139      cmp.b   dimcnt,d0       * compare with dimensions count
00001944  6700 00AC               3140      beq lab_1f28        * found array so go get element
00001948                          3141  
00001948  6000 EE3A               3142      bra lab_wder        * else wrong so do "Wrong dimensions" error
0000194C                          3143  
0000194C                          3144                      * array not found, so build it
0000194C                          3145  lab_1ea1
0000194C  6100 FF1C               3146      bsr lab_1de6        * set data pointer, Adatal, to the first element
00001950                          3147                      * in the array. Astrtl (and a0) points to the
00001950                          3148                      * start of the array
00001950  6100 EE18               3149      bsr lab_121f        * check available memory, "Out of memory" error
00001954                          3150                      * if no room, addr to check is in a0
00001954  2079 000405B4           3151      movea.l astrtl,a0       * get array start pointer
0000195A  2039 0004046E           3152      move.l  varname,d0      * get array name
00001960  20C0                    3153      move.l  d0,(a0)+        * save array name
00001962  7204                    3154      moveq   #4,d1           * set 4 bytes per element
00001964  0800 0017               3155      btst.l  #23,d0          * test if string array
00001968  6702                    3156      beq.s   lab_1edf        * branch if not string
0000196A                          3157  
0000196A  7206                    3158      moveq   #6,d1           * else 6 bytes per element
0000196C                          3159  lab_1edf
0000196C  23C1 000405AC           3160      move.l  d1,asptl        * set array data size (bytes per element)
00001972                          3161  *   moveq   #0,d1           * clear d1 (only byte is used so skip this)
00001972  1239 000405E3           3162      move.b  dimcnt,d1       * get dimensions count
00001978  5848                    3163      addq.w  #4,a0           * skip the array size now (don't know it yet!)
0000197A  30C1                    3164      move.w  d1,(a0)+        * set array's dimensions count
0000197C                          3165  
0000197C  4A39 000405BC           3166      tst.b   defdim          * test default DIM flag
00001982  6700 EE04               3167      beq lab_uder        * if default flag is clear then we are on the
00001986                          3168                      * LHS of = with no array so go do "Undimensioned
00001986                          3169                      * array" error.
00001986                          3170                      * now calculate the array data space size
00001986                          3171  lab_1ec0
00001986                          3172  
00001986                          3173  * If you want arrays to dimension themselves by default then comment out the test
00001986                          3174  * above and uncomment the next three code lines and the label LAB_1ED0
00001986                          3175  
00001986                          3176  *   move.w  #$0b,d1         * set default dimension value (allow 0 to 10)
00001986                          3177  *   tst.b   defdim          * test default DIM flag
00001986                          3178  *   bne.s   lab_1ed0        * branch if b6 of Defdim is clear
00001986                          3179  
00001986  321F                    3180      move.w  (sp)+,d1        * get dimension size
00001988  5241                    3181      addq.w  #1,d1           * +1 to allow 0 to n
0000198A                          3182  
0000198A                          3183  *LAB_1ED0
0000198A  30C1                    3184      move.w  d1,(a0)+        * save to array header
0000198C  6100 00C8               3185      bsr lab_1f7c        * do this dimension size (d1) * array size (Asptl)
00001990                          3186                      * result in d0
00001990  23C0 000405AC           3187      move.l  d0,asptl        * save array data size
00001996  5339 000405E3           3188      subq.b  #1,dimcnt       * decrement dimensions count
0000199C  66E8                    3189      bne.s   lab_1ec0        * loop while not = 0
0000199E                          3190  
0000199E  D1F9 000405AC           3191      adda.l  asptl,a0        * add size to first element address
000019A4  6500 EE16               3192      bcs lab_omer        * if overflow go do "Out of memory" error
000019A8                          3193  
000019A8  6100 EDC0               3194      bsr lab_121f        * check available memory, "Out of memory" error
000019AC                          3195                      * if no room, addr to check is in a0
000019AC  23C8 00040446           3196      move.l  a0,earryl       * save array mem end
000019B2  7000                    3197      moveq   #0,d0           * zero d0
000019B4  2239 000405AC           3198      move.l  asptl,d1        * get size in bytes
000019BA  E289                    3199      lsr.l   #1,d1           * /2 for word fill (may be odd # words)
000019BC  5341                    3200      subq.w  #1,d1           * adjust for DBF loop
000019BE                          3201  lab_1ed8
000019BE  3100                    3202      move.w  d0,-(a0)        * decrement pointer and clear word
000019C0  51C9 FFFC               3203      dbf d1,lab_1ed8     * decrement & loop until low word done
000019C4                          3204  
000019C4  4841                    3205      swap    d1          * swap words
000019C6  4A41                    3206      tst.w   d1          * test high word
000019C8  6706                    3207      beq.s   lab_1f07        * exit if done
000019CA                          3208  
000019CA  5341                    3209      subq.w  #1,d1           * decrement low (high) word
000019CC  4841                    3210      swap    d1          * swap back
000019CE  60EE                    3211      bra.s   lab_1ed8        * go do a whole block
000019D0                          3212  
000019D0                          3213  * now we need to calculate the array size by doing Earryl - Astrtl
000019D0                          3214  
000019D0                          3215  lab_1f07
000019D0  2079 000405B4           3216      movea.l astrtl,a0       * get for calculation and as pointer
000019D6  2039 00040446           3217      move.l  earryl,d0       * get array memory end
000019DC  9088                    3218      sub.l   a0,d0           * calculate array size
000019DE  2140 0004               3219      move.l  d0,4(a0)        * save size to array
000019E2  4A39 000405BC           3220      tst.b   defdim          * test default DIM flag
000019E8  666A                    3221      bne.s   rts_011         * exit (RET) if this was a DIM command
000019EA                          3222  
000019EA                          3223                      * else, find element
000019EA  5048                    3224      addq.w  #8,a0           * index to dimension count
000019EC  33D8 000405E3           3225      move.w  (a0)+,dimcnt        * get array's dimension count
000019F2                          3226  
000019F2                          3227  * we have found, or built, the array. now we need to find the element
000019F2                          3228  
000019F2                          3229  lab_1f28
000019F2  7000                    3230      moveq   #0,d0           * clear first result
000019F4  23C0 000405AC           3231      move.l  d0,asptl        * clear array data pointer
000019FA                          3232  
000019FA                          3233  * compare nth dimension bound (a0) with nth index (sp)+
000019FA                          3234  * if greater do array bounds error
000019FA                          3235  
000019FA                          3236  lab_1f2c
000019FA  3218                    3237      move.w  (a0)+,d1        * get nth dimension bound
000019FC  B257                    3238      cmp.w   (sp),d1         * compare nth index with nth dimension bound
000019FE  6F00 EDB4               3239      ble lab_aber        * if d1 less or = do array bounds error
00001A02                          3240  
00001A02                          3241  * now do pointer = pointer * nth dimension + nth index
00001A02                          3242  
00001A02  4A80                    3243      tst.l   d0          * test pointer
00001A04  6702                    3244      beq.s   lab_1f5a        * skip multiply if last result = null
00001A06                          3245  
00001A06  614E                    3246      bsr.s   lab_1f7c        * do this dimension size (d1) * array size (Asptl)
00001A08                          3247  lab_1f5a
00001A08  7200                    3248      moveq   #0,d1           * clear longword
00001A0A  321F                    3249      move.w  (sp)+,d1        * get nth dimension index
00001A0C  D081                    3250      add.l   d1,d0           * add index to size
00001A0E  23C0 000405AC           3251      move.l  d0,asptl        * save array data pointer
00001A14                          3252  
00001A14  5339 000405E3           3253      subq.b  #1,dimcnt       * decrement dimensions count
00001A1A  66DE                    3254      bne.s   lab_1f2c        * loop if dimensions still to do
00001A1C                          3255  
00001A1C  13FC 0000 000405BD      3256      move.b  #0,dtypef       * set data type to float
00001A24  7204                    3257      moveq   #4,d1           * set for numeric array
00001A26  4A39 0004046F           3258      tst.b   varname+1       * test if string array
00001A2C  6A0C                    3259      bpl.s   lab_1f6a        * branch if not string
00001A2E                          3260  
00001A2E  7206                    3261      moveq   #6,d1           * else set for string array
00001A30  13FC 0080 000405BD      3262      move.b  #$80,dtypef     * and set data type to string
00001A38  6010                    3263      bra.s   lab_1f6b        * skip integer test
00001A3A                          3264  
00001A3A                          3265  lab_1f6a
00001A3A  4A39 00040470           3266      tst.b   varname+2       * test if integer array
00001A40  6A08                    3267      bpl.s   lab_1f6b        * branch if not integer
00001A42                          3268  
00001A42  13FC 0040 000405BD      3269      move.b  #$40,dtypef     * else set data type to integer
00001A4A                          3270  lab_1f6b
00001A4A  610A                    3271      bsr.s   lab_1f7c        * do element size (d1) * array size (Asptl)
00001A4C  D1C0                    3272      adda.l  d0,a0           * add array data start pointer
00001A4E  23C8 00040472           3273      move.l  a0,cvaral       * save current variable address
00001A54                          3274  rts_011
00001A54  4E75                    3275      rts
00001A56                          3276  
00001A56                          3277  * does d0 = (Astrtl),Y * (Asptl)
00001A56                          3278  * do this dimension size (d1) * array data size (Asptl)
00001A56                          3279  
00001A56                          3280  lab_1f7c
00001A56                          3281  
00001A56                          3282  * do a 16 x 32 bit multiply
00001A56                          3283  * d1 holds the 16 bit multiplier
00001A56                          3284  * Asptl holds the 32 bit multiplicand
00001A56                          3285  
00001A56                          3286  * d0  bbbb  bbbb
00001A56                          3287  * d1  0000  aaaa
00001A56                          3288  *     ----------
00001A56                          3289  * d0  rrrr  rrrr
00001A56                          3290  
00001A56  2039 000405AC           3291      move.l  asptl,d0        * get result
00001A5C  2400                    3292      move.l  d0,d2           * copy it
00001A5E  4242                    3293      clr.w   d2          * clear low word
00001A60  9082                    3294      sub.l   d2,d0           * clear high word
00001A62  4842                    3295      swap    d2          * shift high word to low word
00001A64  C0C1                    3296      mulu    d1,d0           * low result
00001A66  C4C1                    3297      mulu    d1,d2           * high result
00001A68  4842                    3298      swap    d2          * align words for test
00001A6A  4A42                    3299      tst.w   d2          * must be zero
00001A6C  6600 ED4E               3300      bne lab_omer        * if overflow go do "Out of memory" error
00001A70                          3301  
00001A70  D082                    3302      add.l   d2,d0           * calculate result
00001A72  6500 ED48               3303      bcs lab_omer        * if overflow go do "Out of memory" error
00001A76                          3304  
00001A76  4E75                    3305      rts
00001A78                          3306  
00001A78                          3307  * perform FRE()
00001A78                          3308  
00001A78                          3309  lab_fre
00001A78  4A39 000405BD           3310      tst.b   dtypef          * test data type, $80=string, $40=integer, $00=float
00001A7E  6A04                    3311      bpl.s   lab_1fb4        * branch if numeric
00001A80                          3312  
00001A80  6100 0388               3313      bsr lab_22b6        * pop string off descriptor stack, or from top of
00001A84                          3314                      * string space, returns d0 = length, a0 = pointer
00001A84                          3315  
00001A84                          3316                      * FRE(n) was numeric so do this
00001A84                          3317  lab_1fb4
00001A84  6100 0222               3318      bsr lab_garb        * go do garbage collection
00001A88  2039 0004044A           3319      move.l  sstorl,d0       * get bottom of string space
00001A8E  90B9 00040446           3320      sub.l   earryl,d0       * subtract array mem end
00001A94                          3321  
00001A94                          3322  * convert d0 to signed longword in FAC1
00001A94                          3323  
00001A94                          3324  lab_ayfc
00001A94  13FC 0000 000405BD      3325      move.b  #$00,dtypef     * clear data type, $80=string, $40=integer, $00=float
00001A9C  33FC A000 00040598      3326      move.w  #$a000,fac1_e       * set FAC1 exponent and clear sign (b7)
00001AA4  23C0 00040594           3327      move.l  d0,fac1_m       * save FAC1 mantissa
00001AAA  6A00 06C6               3328      bpl lab_24d0        * convert if +ve
00001AAE                          3329  
00001AAE  003C 0001               3330      ori.b   #1,ccr          * else set carry
00001AB2  6000 06BE               3331      bra lab_24d0        * do +/- (carry is sign) & normalise FAC1
00001AB6                          3332  
00001AB6                          3333  * remember if the line length is zero (infinite line) then POS(n) will return
00001AB6                          3334  * position MOD tabsize
00001AB6                          3335  
00001AB6                          3336  * perform POS()
00001AB6                          3337  
00001AB6                          3338  lab_pos
00001AB6  1039 000405EE           3339      move.b  tpos,d0         * get terminal position
00001ABC                          3340  
00001ABC                          3341  * convert d0 to unsigned byte in FAC1
00001ABC                          3342  
00001ABC                          3343  lab_1fd0
00001ABC  C0BC 000000FF           3344      and.l   #$ff,d0         * clear high bits
00001AC2  60D0                    3345      bra.s   lab_ayfc        * convert d0 to signed longword in FAC1 & RET
00001AC4                          3346  
00001AC4                          3347  * check not Direct (used by DEF and INPUT)
00001AC4                          3348  
00001AC4                          3349  lab_ckrn
00001AC4  2239 00040456           3350      move.l  clinel,d1       * get current line #
00001ACA  5281                    3351      addq.l  #1,d1           * increment line #
00001ACC  6700 ECDA               3352      beq lab_ider        * if 0 go do illegal direct error then warm start
00001AD0                          3353  
00001AD0  4E75                    3354      rts             * can continue so return
00001AD2                          3355  
00001AD2                          3356  * perform DEF
00001AD2                          3357  
00001AD2                          3358  lab_def
00001AD2  70AA                    3359      moveq   #tk_fn-$100,d0      * get FN token
00001AD4  6100 FA26               3360      bsr lab_scca        * scan for CHR$(d0) , else syntax error/warm start
00001AD8                          3361                      * return character after d0
00001AD8  13FC 0080 000405E7      3362      move.b  #$80,sufnxf     * set FN flag bit
00001AE0  6100 FC46               3363      bsr lab_1d12        * get FN name
00001AE4  23C8 000405B8           3364      move.l  a0,func_l       * save function pointer
00001AEA                          3365  
00001AEA  61D8                    3366      bsr.s   lab_ckrn        * check not Direct (back here if ok)
00001AEC  6100 FA08               3367      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
00001AF0  13FC 007E 000405E7      3368      move.b  #$7e,sufnxf     * set FN variable flag bits
00001AF8  6100 FC22               3369      bsr lab_gvar        * get/create function variable address
00001AFC                          3370                      * return pointer to variable in Cvaral and a0
00001AFC  7000                    3371      moveq   #0,d0           * set zero to clear variable
00001AFE  20C0                    3372      move.l  d0,(a0)+        * clear variable
00001B00  4A39 000405BD           3373      tst.b   dtypef          * test data type
00001B06  6A02                    3374      bpl.s   lab_defv        * branch if numeric variable
00001B08                          3375  
00001B08  3080                    3376      move.w  d0,(a0)         * else clear string length
00001B0A                          3377  lab_defv
00001B0A  6100 F9E6               3378      bsr lab_1bfb        * scan for ")" , else do syntax error/warm start
00001B0E  70BC                    3379      moveq   #tk_equal-$100,d0   * = token
00001B10  6100 F9EA               3380      bsr lab_scca        * scan for CHR$(A), else syntax error/warm start
00001B14                          3381                      * return character after d0
00001B14  2F39 0004046E           3382      move.l  varname,-(sp)       * push current variable name
00001B1A  2F0D                    3383      move.l  a5,-(sp)        * push BASIC execute pointer
00001B1C  6100 F2D2               3384      bsr lab_data        * go perform DATA (find end of DEF FN statement)
00001B20  2079 000405B8           3385      movea.l func_l,a0       * get pointer
00001B26  209F                    3386      move.l  (sp)+,(a0)      * save BASIC execute pointer to function
00001B28  215F 0004               3387      move.l  (sp)+,4(a0)     * save current variable name to function
00001B2C  4E75                    3388      rts
00001B2E                          3389  
00001B2E                          3390  * evaluate FNx
00001B2E                          3391  
00001B2E                          3392  lab_201e
00001B2E  13FC 0081 000405E7      3393      move.b  #$81,sufnxf     * set FN flag (find not create)
00001B36  6100 F9CA               3394      bsr lab_igby        * increment & scan memory
00001B3A  6100 FBEC               3395      bsr lab_1d12        * get FN name
00001B3E  1F39 000405BD           3396      move.b  dtypef,-(sp)        * push data type flag (function type)
00001B44  2F08                    3397      move.l  a0,-(sp)        * push function pointer
00001B46  6100 F9AE               3398      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
00001B4A  6100 F9A2               3399      bsr lab_1bf7        * evaluate expression within parentheses
00001B4E  205F                    3400      movea.l (sp)+,a0        * pop function pointer
00001B50  23C8 000405B8           3401      move.l  a0,func_l       * set function pointer
00001B56  1F39 000405BD           3402      move.b  dtypef,-(sp)        * push data type flag (function expression type)
00001B5C                          3403  
00001B5C  2028 0004               3404      move.l  4(a0),d0        * get function variable name
00001B60  6100 FC40               3405      bsr lab_1d4a        * go find function variable (already created)
00001B64                          3406  
00001B64                          3407                      * now check type match for variable
00001B64  101F                    3408      move.b  (sp)+,d0        * pop data type flag (function expression type)
00001B66  E318                    3409      rol.b   #1,d0           * set carry if type = string
00001B68  6100 F7C4               3410      bsr lab_cktm        * type match check, set C for string
00001B6C                          3411  
00001B6C                          3412                      * now stack the function variable value before use
00001B6C  6712                    3413      beq.s   lab_2043        * branch if not string
00001B6E                          3414  
00001B6E  B9FC 0004047A           3415      cmpa.l  #des_sk_e,a4        * compare string stack pointer with max+1
00001B74  6700 EC26               3416      beq lab_scer        * if no space on stack do string too complex error
00001B78                          3417  
00001B78  3928 0004               3418      move.w  4(a0),-(a4)     * string length on descriptor stack
00001B7C  2910                    3419      move.l  (a0),-(a4)      * string address on stack
00001B7E  6002                    3420      bra.s   lab_204s        * skip var push
00001B80                          3421  
00001B80                          3422  lab_2043
00001B80  2F10                    3423      move.l  (a0),-(sp)      * push variable
00001B82                          3424  lab_204s
00001B82  2F08                    3425      move.l  a0,-(sp)        * push variable address
00001B84  1F39 000405BD           3426      move.b  dtypef,-(sp)        * push variable data type
00001B8A                          3427  
00001B8A  6140                    3428      bsr.s   lab_2045        * pack function expression value into (a0)
00001B8C                          3429                      * (function variable)
00001B8C  2F0D                    3430      move.l  a5,-(sp)        * push BASIC execute pointer
00001B8E  2079 000405B8           3431      movea.l func_l,a0       * get function pointer
00001B94  2A50                    3432      movea.l (a0),a5         * save function execute ptr as BASIC execute ptr
00001B96  2F39 00040472           3433      move.l  cvaral,-(sp)        * push variable address
00001B9C  6100 F7A6               3434      bsr lab_evex        * evaluate expression
00001BA0  23DF 00040472           3435      move.l  (sp)+,cvaral        * pull variable address
00001BA6  6100 F95C               3436      bsr lab_gbyt        * scan memory
00001BAA  6600 EC24               3437      bne lab_sner        * if not [EOL] or [EOS] do syntax error/warm start
00001BAE                          3438  
00001BAE  2A5F                    3439      move.l  (sp)+,a5        * restore BASIC execute pointer
00001BB0                          3440  
00001BB0                          3441  * restore variable from stack and test data type
00001BB0                          3442  
00001BB0  101F                    3443      move.b  (sp)+,d0        * pull variable data type
00001BB2  205F                    3444      movea.l (sp)+,a0        * pull variable address
00001BB4  4A00                    3445      tst.b   d0          * test variable data type
00001BB6  6A08                    3446      bpl.s   lab_204t        * branch if not string
00001BB8                          3447  
00001BB8  209C                    3448      move.l  (a4)+,(a0)      * string address from descriptor stack
00001BBA  315C 0004               3449      move.w  (a4)+,4(a0)     * string length from descriptor stack
00001BBE  6002                    3450      bra.s   lab_2044        * skip variable pull
00001BC0                          3451  
00001BC0                          3452  lab_204t
00001BC0  209F                    3453      move.l  (sp)+,(a0)      * restore variable from stack
00001BC2                          3454  lab_2044
00001BC2  101F                    3455      move.b  (sp)+,d0        * pop data type flag (function type)
00001BC4  E318                    3456      rol.b   #1,d0           * set carry if type = string
00001BC6  6100 F766               3457      bsr lab_cktm        * type match check, set C for string
00001BCA  4E75                    3458      rts
00001BCC                          3459  
00001BCC                          3460  lab_2045
00001BCC  4A39 000405BD           3461      tst.b   dtypef          * test data type
00001BD2  6A00 0930               3462      bpl lab_2778        * if numeric pack FAC1 into variable (a0) & return
00001BD6                          3463  
00001BD6  2448                    3464      movea.l a0,a2           * copy variable pointer
00001BD8  6000 F380               3465      bra lab_17d6        * go do string LET & return
00001BDC                          3466  
00001BDC                          3467  
00001BDC                          3468  * perform STR$()
00001BDC                          3469  
00001BDC                          3470  lab_strs
00001BDC  6100 F748               3471      bsr lab_ctnm        * check if source is numeric, else type mismatch
00001BE0  6100 0AE4               3472      bsr lab_2970        * convert FAC1 to string
00001BE4  584F                    3473      addq.w  #4,sp           * skip return type check
00001BE6                          3474  
00001BE6                          3475  * Scan, set up string
00001BE6                          3476  * print " terminated string to FAC1 stack
00001BE6                          3477  
00001BE6                          3478  lab_20ae
00001BE6  7422                    3479      moveq   #$22,d2         * set Srchc character (terminator 1)
00001BE8  3602                    3480      move.w  d2,d3           * set Asrch character (terminator 2)
00001BEA                          3481  
00001BEA                          3482  * print d2/d3 terminated string to FAC1 stack
00001BEA                          3483  * d2 = Srchc, d3 = Asrch, a0 is source
00001BEA                          3484  * a6 is temp
00001BEA                          3485  
00001BEA                          3486  lab_20b4
00001BEA  7200                    3487      moveq   #0,d1           * clear longword
00001BEC  5341                    3488      subq.w  #1,d1           * set length to -1
00001BEE  2448                    3489      movea.l a0,a2           * copy start to calculate end
00001BF0                          3490  lab_20be
00001BF0  5241                    3491      addq.w  #1,d1           * increment length
00001BF2  1030 1000               3492      move.b  (a0,d1.w),d0        * get byte from string
00001BF6  6710                    3493      beq.s   lab_20d0        * exit loop if null byte [EOS]
00001BF8                          3494  
00001BF8  B002                    3495      cmp.b   d2,d0           * compare with search character (terminator 1)
00001BFA  6704                    3496      beq.s   lab_20cb        * branch if terminator
00001BFC                          3497  
00001BFC  B003                    3498      cmp.b   d3,d0           * compare with terminator 2
00001BFE  66F0                    3499      bne.s   lab_20be        * loop if not terminator 2 (or null string)
00001C00                          3500  
00001C00                          3501  lab_20cb
00001C00  B03C 0022               3502      cmp.b   #$22,d0         * compare with "
00001C04  6602                    3503      bne.s   lab_20d0        * branch if not "
00001C06                          3504  
00001C06  524A                    3505      addq.w  #1,a2           * else increment string start (skip " at end)
00001C08                          3506  lab_20d0
00001C08  D5C1                    3507      adda.l  d1,a2           * add longowrd length to make string end+1
00001C0A                          3508  
00001C0A  B1FC 00040000           3509      cmpa.l  #ram_strt,a0        * is string in ram
00001C10  6522                    3510      bcs.s   lab_rtst        * if not go push descriptor on stack & exit
00001C12                          3511                      * (could be message string from ROM)
00001C12                          3512  
00001C12  B1F9 00040432           3513      cmpa.l  smeml,a0        * is string in utility ram
00001C18  641A                    3514      bcc.s   lab_rtst        * if not go push descriptor on stack & exit
00001C1A                          3515                      * (is in string or program space)
00001C1A                          3516  
00001C1A                          3517                      * (else) copy string to string memory
00001C1A                          3518  lab_20c9
00001C1A  2248                    3519      movea.l a0,a1           * copy descriptor pointer
00001C1C  2001                    3520      move.l  d1,d0           * copy longword length
00001C1E  6604                    3521      bne.s   lab_20d8        * branch if not null string
00001C20                          3522  
00001C20  2041                    3523      movea.l d1,a0           * make null pointer
00001C22  6010                    3524      bra.s   lab_rtst        * go push descriptor on stack & exit
00001C24                          3525  
00001C24                          3526  lab_20d8
00001C24  612C                    3527      bsr.s   lab_2115        * make string space d1 bytes long
00001C26  2001                    3528      move.l  d1,d0           * copy length again
00001C28  D1C1                    3529      adda.l  d1,a0           * new string end
00001C2A  D3C1                    3530      adda.l  d1,a1           * old string end
00001C2C  5340                    3531      subq.w  #1,d0           * -1 for DBF loop
00001C2E                          3532  lab_20e0
00001C2E  1121                    3533      move.b  -(a1),-(a0)     * copy byte (source can be odd aligned)
00001C30  51C8 FFFC               3534      dbf d0,lab_20e0     * loop until done
00001C34                          3535  
00001C34                          3536  
00001C34                          3537  * check for space on descriptor stack then ...
00001C34                          3538  * put string address and length on descriptor stack & update stack pointers
00001C34                          3539  * start is in a0, length is in d1
00001C34                          3540  
00001C34                          3541  lab_rtst
00001C34  B9FC 0004047A           3542      cmpa.l  #des_sk_e,a4        * compare string stack pointer with max+1
00001C3A  6700 EB60               3543      beq lab_scer        * if no space on string stack ..
00001C3E                          3544                      * .. go do 'string too complex' error
00001C3E                          3545  
00001C3E                          3546                      * push string & update pointers
00001C3E  3901                    3547      move.w  d1,-(a4)        * string length on descriptor stack
00001C40  2908                    3548      move.l  a0,-(a4)        * string address on stack
00001C42  23CC 00040594           3549      move.l  a4,fac1_m       * string descriptor pointer in FAC1
00001C48  13FC 0080 000405BD      3550      move.b  #$80,dtypef     * save data type flag, $80=string
00001C50  4E75                    3551      rts
00001C52                          3552  
00001C52                          3553  * Build descriptor a0/d1
00001C52                          3554  * make space in string memory for string d1.w long
00001C52                          3555  * return pointer in a0/Sutill
00001C52                          3556  
00001C52                          3557  lab_2115
00001C52  4A41                    3558      tst.w   d1          * test length
00001C54  6738                    3559      beq.s   lab_2128        * branch if user wants null string
00001C56                          3560  
00001C56                          3561                      * make space for string d1 long
00001C56  3F00                    3562      move.w  d0,-(sp)        * save d0
00001C58  7000                    3563      moveq   #0,d0           * clear longword
00001C5A  13C0 000405E6           3564      move.b  d0,gclctd       * clear garbage collected flag (b7)
00001C60  7001                    3565      moveq   #1,d0           * +1 to possibly round up
00001C62  C041                    3566      and.w   d1,d0           * mask odd bit
00001C64  D041                    3567      add.w   d1,d0           * ensure d0 is even length
00001C66  6404                    3568      bcc.s   lab_2117        * branch if no overflow
00001C68                          3569  
00001C68  7001                    3570      moveq   #1,d0           * set to allocate 65536 bytes
00001C6A  4840                    3571      swap    d0          * makes $00010000
00001C6C                          3572  lab_2117
00001C6C  2079 0004044A           3573      movea.l sstorl,a0       * get bottom of string space
00001C72  91C0                    3574      suba.l  d0,a0           * subtract string length
00001C74  B1F9 00040446           3575      cmpa.l  earryl,a0       * compare with top of array space
00001C7A  6516                    3576      bcs.s   lab_2137        * possibly do out of memory error if less
00001C7C                          3577  
00001C7C  23C8 0004044A           3578      move.l  a0,sstorl       * save bottom of string space low byte
00001C82  23C8 00040452           3579      move.l  a0,sutill       * save string utility ptr low byte
00001C88  301F                    3580      move.w  (sp)+,d0        * restore d0
00001C8A  4A41                    3581      tst.w   d1          * set flags on length
00001C8C  4E75                    3582      rts
00001C8E                          3583  
00001C8E                          3584  lab_2128
00001C8E  3041                    3585      movea.w d1,a0           * make null pointer
00001C90  4E75                    3586      rts
00001C92                          3587  
00001C92                          3588  lab_2137
00001C92  4A39 000405E6           3589      tst.b   gclctd          * get garbage collected flag
00001C98  6B00 EB22               3590      bmi lab_omer        * do "Out of memory" error, then warm start
00001C9C                          3591  
00001C9C  610A                    3592      bsr.s   lab_garb        * else go do garbage collection
00001C9E  13FC 0080 000405E6      3593      move.b  #$80,gclctd     * set garbage collected flag
00001CA6  60C4                    3594      bra.s   lab_2117        * go try again
00001CA8                          3595  
00001CA8                          3596  * garbage collection routine
00001CA8                          3597  
00001CA8                          3598  lab_garb
00001CA8  48E7 E0E0               3599      movem.l d0-d2/a0-a2,-(sp)   * save registers
00001CAC  23F9 0004044E 0004044A  3600      move.l  ememl,sstorl        * start with no strings
00001CB6                          3601  
00001CB6                          3602                      * re-run routine from last ending
00001CB6                          3603  lab_214b
00001CB6  2239 00040446           3604      move.l  earryl,d1       * set highest uncollected string so far
00001CBC  7000                    3605      moveq   #0,d0           * clear longword
00001CBE  2240                    3606      movea.l d0,a1           * clear string to move pointer
00001CC0  2079 0004043E           3607      movea.l sstrl,a0        * set pointer to start of strings
00001CC6  2479 00040442           3608      movea.l sarryl,a2       * set end pointer to start of arrays (end of strings)
00001CCC  600A                    3609      bra.s   lab_2176        * branch into loop at end loop test
00001CCE                          3610  
00001CCE                          3611  lab_2161
00001CCE  6100 0088               3612      bsr lab_2206        * test and set if this is the highest string
00001CD2  D1FC 0000000A           3613      add.l   #10,a0          * increment to next string
00001CD8                          3614  lab_2176
00001CD8  B5C8                    3615      cmpa.l  a0,a2           * compare pointer with with end of area
00001CDA  66F2                    3616      bne.s   lab_2161        * go do next if not at end
00001CDC                          3617  
00001CDC                          3618  * done strings, now do arrays.
00001CDC                          3619  
00001CDC                          3620  **  movea.l sarryl,a0       * set pointer to start of arrays (should be there)
00001CDC  2479 00040446           3621      movea.l earryl,a2       * set end pointer to end of arrays
00001CE2  6024                    3622      bra.s   lab_218f        * branch into loop at end loop test
00001CE4                          3623  
00001CE4                          3624  lab_217e
00001CE4  2428 0004               3625      move.l  4(a0),d2        * get array size
00001CE8  D488                    3626      add.l   a0,d2           * makes start of next array
00001CEA                          3627  
00001CEA  2010                    3628      move.l  (a0),d0         * get array name
00001CEC  0800 0017               3629      btst    #23,d0          * test string flag
00001CF0  6714                    3630      beq.s   lab_218b        * branch if not string
00001CF2                          3631  
00001CF2  3028 0008               3632      move.w  8(a0),d0        * get # of dimensions
00001CF6  D040                    3633      add.w   d0,d0           * *2
00001CF8  D0C0                    3634      adda.w  d0,a0           * add to skip dimension size(s)
00001CFA  D0FC 000A               3635      adda.w  #$0a,a0         * increment to first element
00001CFE                          3636  lab_2183
00001CFE  6158                    3637      bsr.s   lab_2206        * test and set if this is the highest string
00001D00  5C48                    3638      addq.w  #6,a0           * increment to next element
00001D02  B1C2                    3639      cmpa.l  d2,a0           * compare with start of next array
00001D04  66F8                    3640      bne.s   lab_2183        * go do next if not at end of array
00001D06                          3641  
00001D06                          3642  lab_218b
00001D06  2042                    3643      movea.l d2,a0           * pointer to next array
00001D08                          3644  lab_218f
00001D08  B5C8                    3645      cmpa.l  a0,a2           * compare pointer with array end
00001D0A  66D8                    3646      bne.s   lab_217e        * go do next if not at end
00001D0C                          3647  
00001D0C                          3648  * done arrays and variables, now just the descriptor stack to do
00001D0C                          3649  
00001D0C  204C                    3650      movea.l a4,a0           * get descriptor stack pointer
00001D0E  247C 00040492           3651      movea.l #des_sk,a2      * set end pointer to end of stack
00001D14  6004                    3652      bra.s   lab_21c4        * branch into loop at end loop test
00001D16                          3653  
00001D16                          3654  lab_21c2
00001D16  6140                    3655      bsr.s   lab_2206        * test and set if this is the highest string
00001D18  5C48                    3656      addq.w  #06,a0          * increment to next string
00001D1A                          3657  lab_21c4
00001D1A  B5C8                    3658      cmpa.l  a0,a2           * compare pointer with stack end
00001D1C  66F8                    3659      bne.s   lab_21c2        * go do next if not at end
00001D1E                          3660  
00001D1E                          3661  * descriptor search complete, now either exit or set-up and move string
00001D1E                          3662  
00001D1E  2009                    3663      move.l  a1,d0           * set the flags (a1 is move string)
00001D20  6730                    3664      beq.s   lab_21d1        * go tidy up and exit if no move
00001D22                          3665  
00001D22  2051                    3666      movea.l (a1),a0         * a0 is now string start
00001D24  7200                    3667      moveq   #0,d1           * clear d1
00001D26  3229 0004               3668      move.w  4(a1),d1        * d1 is string length
00001D2A  5281                    3669      addq.l  #1,d1           * +1
00001D2C  C23C 00FE               3670      and.b   #$fe,d1         * make even length
00001D30  D1C1                    3671      adda.l  d1,a0           * pointer is now to string end+1
00001D32  2479 0004044A           3672      movea.l sstorl,a2       * is destination end+1
00001D38  B1CA                    3673      cmpa.l  a2,a0           * does the string need moving
00001D3A  670C                    3674      beq.s   lab_2240        * branch if not
00001D3C                          3675  
00001D3C  E289                    3676      lsr.l   #1,d1           * word move so do /2
00001D3E  5341                    3677      subq.w  #1,d1           * -1 for DBF loop
00001D40                          3678  lab_2216
00001D40  3520                    3679      move.w  -(a0),-(a2)     * copy word
00001D42  51C9 FFFC               3680      dbf d1,lab_2216     * loop until done
00001D46                          3681  
00001D46  2288                    3682      move.l  a0,(a1)         * save new string start
00001D48                          3683  lab_2240
00001D48  23D1 0004044A           3684      move.l  (a1),sstorl     * string start is new string mem start
00001D4E  6000 FF66               3685      bra lab_214b        * re-run routine from last ending
00001D52                          3686                      * (but don't collect this string)
00001D52                          3687  
00001D52                          3688  lab_21d1
00001D52  4CDF 0707               3689      movem.l (sp)+,d0-d2/a0-a2   * restore registers
00001D56                          3690  rts_012
00001D56  4E75                    3691      rts
00001D58                          3692  
00001D58                          3693  *  test and set if this is the highest string
00001D58                          3694  
00001D58                          3695  lab_2206
00001D58  2010                    3696      move.l  (a0),d0         * get this string pointer
00001D5A  67FA                    3697      beq.s   rts_012         * exit if null string
00001D5C                          3698  
00001D5C  B280                    3699      cmp.l   d0,d1           * compare with highest uncollected string so far
00001D5E  64F6                    3700      bcc.s   rts_012         * exit if <= with highest so far
00001D60                          3701  
00001D60  B0B9 0004044A           3702      cmp.l   sstorl,d0       * compare with bottom of string space
00001D66  64EE                    3703      bcc.s   rts_012         * exit if >= bottom of string space
00001D68                          3704  
00001D68  7000                    3705      moveq   #0,d0           * clear d0
00001D6A  3029 0004               3706      move.w  4(a1),d0        * d0 is string length
00001D6E  4480                    3707      neg.l   d0          * make -ve
00001D70  C03C 00FE               3708      and.b   #$fe,d0         * make -ve even length
00001D74  D0B9 0004044A           3709      add.l   sstorl,d0       * add string store to -ve length
00001D7A  B090                    3710      cmp.l   (a0),d0         * compare with string address
00001D7C  6706                    3711      beq.s   lab_2212        * if = go move string store pointer down
00001D7E                          3712  
00001D7E  2210                    3713      move.l  (a0),d1         * highest = current
00001D80  2248                    3714      movea.l a0,a1           * string to move = current
00001D82  4E75                    3715      rts
00001D84                          3716  
00001D84                          3717  lab_2212
00001D84  23C0 0004044A           3718      move.l  d0,sstorl       * set new string store start
00001D8A  4E75                    3719      rts
00001D8C                          3720  
00001D8C                          3721  * concatenate
00001D8C                          3722  * add strings, string descriptor 1 is in FAC1_m, string 2 is in line
00001D8C                          3723  
00001D8C                          3724  lab_224d
00001D8C  2F39 00040594           3725      move.l  fac1_m,-(sp)        * stack descriptor pointer for string 1
00001D92                          3726  
00001D92  6100 F712               3727      bsr lab_gval        * get value from line
00001D96  6100 F592               3728      bsr lab_ctst        * check if source is string, else do type mismatch
00001D9A                          3729  
00001D9A  2279 00040594           3730      movea.l fac1_m,a1       * copy descriptor pointer 2
00001DA0  2057                    3731      movea.l (sp),a0         * copy descriptor pointer 1
00001DA2  7200                    3732      moveq   #0,d1           * clear longword length
00001DA4  3228 0004               3733      move.w  4(a0),d1        * get length 1
00001DA8  D269 0004               3734      add.w   4(a1),d1        * add length 2
00001DAC  6500 E9F2               3735      bcs lab_sler        * if overflow go do 'string too long' error
00001DB0                          3736  
00001DB0  6100 FEA0               3737      bsr lab_2115        * make space d1 bytes long
00001DB4  23C8 0004059C           3738      move.l  a0,fac2_m       * save new string start pointer
00001DBA  2057                    3739      movea.l (sp),a0         * copy descriptor pointer 1 from stack
00001DBC  6124                    3740      bsr.s   lab_229c        * copy string from descriptor a0 to Sutill
00001DBE                          3741                      * return with a0 = pointer, d1 = length
00001DBE                          3742  
00001DBE  2079 00040594           3743      movea.l fac1_m,a0       * get descriptor pointer for string 2
00001DC4  614A                    3744      bsr.s   lab_22ba        * pop (a0) descriptor, returns with ..
00001DC6                          3745                      * a0 = pointer, d0 = length
00001DC6  6120                    3746      bsr.s   lab_229e        * copy string d0 bytes long from a0 to Sutill
00001DC8                          3747                      * return with a0 = pointer, d1 = length
00001DC8                          3748  
00001DC8  205F                    3749      movea.l (sp)+,a0        * get descriptor pointer for string 1
00001DCA  6144                    3750      bsr.s   lab_22ba        * pop (a0) descriptor, returns with ..
00001DCC                          3751                      * d0 = length, a0 = pointer
00001DCC                          3752  
00001DCC  2079 0004059C           3753      movea.l fac2_m,a0       * retreive result string pointer
00001DD2  2239 00040452           3754      move.l  sutill,d1       * copy end
00001DD8  9288                    3755      sub.l   a0,d1           * subtract start = length
00001DDA  6100 FE58               3756      bsr lab_rtst        * push string on descriptor stack
00001DDE                          3757                      * a0 = pointer, d1 = length
00001DDE  6000 F57A               3758      bra lab_1adb        * continue evaluation
00001DE2                          3759  
00001DE2                          3760  * copy string from descriptor (a0) to Sutill
00001DE2                          3761  * return with a0 = pointer, d1 = length
00001DE2                          3762  
00001DE2                          3763  lab_229c
00001DE2  3028 0004               3764      move.w  4(a0),d0        * get length
00001DE6  2050                    3765      movea.l (a0),a0         * get string pointer
00001DE8                          3766  lab_229e
00001DE8  2279 00040452           3767      movea.l sutill,a1       * get destination pointer
00001DEE  3200                    3768      move.w  d0,d1           * copy and check length
00001DF0  6712                    3769      beq.s   rts_013         * skip copy if null
00001DF2                          3770  
00001DF2  2F09                    3771      move.l  a1,-(sp)        * save destination string pointer
00001DF4  5340                    3772      subq.w  #1,d0           * subtract for DBF loop
00001DF6                          3773  lab_22a0
00001DF6  12D8                    3774      move.b  (a0)+,(a1)+     * copy byte
00001DF8  51C8 FFFC               3775      dbf d0,lab_22a0     * loop if not done
00001DFC                          3776  
00001DFC  23C9 00040452           3777      move.l  a1,sutill       * update Sutill to end of copied string
00001E02  205F                    3778      movea.l (sp)+,a0        * restore destination string pointer
00001E04                          3779  rts_013
00001E04  4E75                    3780      rts
00001E06                          3781  
00001E06                          3782  * evaluate string, returns d0 = length, a0 = pointer
00001E06                          3783  
00001E06                          3784  lab_evst
00001E06  6100 F522               3785      bsr lab_ctst        * check if source is string, else do type mismatch
00001E0A                          3786  
00001E0A                          3787  * pop string off descriptor stack, or from top of string space
00001E0A                          3788  * returns with d0 = length, a0 = pointer
00001E0A                          3789  
00001E0A                          3790  lab_22b6
00001E0A  2079 00040594           3791      movea.l fac1_m,a0       * get descriptor pointer
00001E10                          3792  
00001E10                          3793  * pop (a0) descriptor off stack or from string space
00001E10                          3794  * returns with d0 = length, a0 = pointer
00001E10                          3795  
00001E10                          3796  lab_22ba
00001E10  48E7 4040               3797      movem.l a1/d1,-(sp)     * save other regs
00001E14  B9C8                    3798      cmpa.l  a0,a4           * is string on the descriptor stack
00001E16  6602                    3799      bne.s   lab_22bd        * skip pop if not
00001E18                          3800  
00001E18  5C4C                    3801      addq.w  #$06,a4         * else update stack pointer
00001E1A                          3802  lab_22bd
00001E1A  7000                    3803      moveq   #0,d0           * clear string length longword
00001E1C  2258                    3804      movea.l (a0)+,a1        * get string address
00001E1E  3018                    3805      move.w  (a0)+,d0        * get string length
00001E20                          3806  
00001E20  B9C8                    3807      cmpa.l  a0,a4           * was it on the descriptor stack
00001E22  6614                    3808      bne.s   lab_22e6        * branch if it wasn't
00001E24                          3809  
00001E24  B3F9 0004044A           3810      cmpa.l  sstorl,a1       * compare string address with bottom of string space
00001E2A  660C                    3811      bne.s   lab_22e6        * branch if <>
00001E2C                          3812  
00001E2C  7201                    3813      moveq   #1,d1           * mask for odd bit
00001E2E  C240                    3814      and.w   d0,d1           * AND length
00001E30  D280                    3815      add.l   d0,d1           * make it fit word aligned length
00001E32                          3816  
00001E32  D3B9 0004044A           3817      add.l   d1,sstorl       * add to bottom of string space
00001E38                          3818  lab_22e6
00001E38  2049                    3819      movea.l a1,a0           * copy to a0
00001E3A  4CDF 0202               3820      movem.l (sp)+,a1/d1     * restore other regs
00001E3E  4E75                    3821      rts
00001E40                          3822  
00001E40                          3823  * perform CHR$()
00001E40                          3824  
00001E40                          3825  lab_chrs
00001E40  6100 0116               3826      bsr lab_evby        * evaluate byte expression, result in d0 and Itemp
00001E44  7201                    3827      moveq   #1,d1           * string is single byte
00001E46  6100 FE0A               3828      bsr lab_2115        * make string space d1 bytes long
00001E4A                          3829                      * return a0/Sutill = pointer, others unchanged
00001E4A  1080                    3830      move.b  d0,(a0)         * save byte in string (byte IS string!)
00001E4C  584F                    3831      addq.w  #4,sp           * skip return type check
00001E4E  6000 FDE4               3832      bra lab_rtst        * push string on descriptor stack
00001E52                          3833                      * a0 = pointer, d1 = length
00001E52                          3834  
00001E52                          3835  * perform LEFT$()
00001E52                          3836  
00001E52                          3837  lab_left
00001E52  6178                    3838      bsr.s   lab_236f        * pull string data & word parameter from stack
00001E54                          3839                      * return pointer in a0, word in d0. destroys d1
00001E54  C141                    3840      exg d0,d1           * offset in d0, word in d1
00001E56  4A81                    3841      tst.l   d1          * test returned length
00001E58  671E                    3842      beq.s   lab_231c        * branch if null return
00001E5A                          3843  
00001E5A  7000                    3844      moveq   #0,d0           * clear start offset
00001E5C  B268 0004               3845      cmp.w   4(a0),d1        * compare word parameter with string length
00001E60  6516                    3846      bcs.s   lab_231c        * branch if string length > word parameter
00001E62                          3847  
00001E62  600E                    3848      bra.s   lab_2316        * go copy whole string
00001E64                          3849  
00001E64                          3850  * perform RIGHT$()
00001E64                          3851  
00001E64                          3852  lab_right
00001E64  6166                    3853      bsr.s   lab_236f        * pull string data & word parameter from stack
00001E66                          3854                      * return pointer in a0, word in d0. destroys d1
00001E66  2200                    3855      move.l  d0,d1           * copy word (and clear high word)
00001E68  670E                    3856      beq.s   lab_231c        * branch if null return
00001E6A                          3857  
00001E6A  3028 0004               3858      move.w  4(a0),d0        * get string length
00001E6E  9081                    3859      sub.l   d1,d0           * subtract word
00001E70  6406                    3860      bcc.s   lab_231c        * branch if string length > word parameter
00001E72                          3861  
00001E72                          3862                      * else copy whole string
00001E72                          3863  lab_2316
00001E72  7000                    3864      moveq   #0,d0           * clear start offset
00001E74  3228 0004               3865      move.w  4(a0),d1        * else make parameter = length
00001E78                          3866  
00001E78                          3867  * get here with ...
00001E78                          3868  *   a0  - points to descriptor
00001E78                          3869  * 4(a0) - is string length
00001E78                          3870  *   d0  - is offset from string start
00001E78                          3871  *   d1  - is required string length
00001E78                          3872  
00001E78                          3873  lab_231c
00001E78  2F08                    3874      move.l  a0,-(sp)        * save string descriptor pointer
00001E7A  6100 FDD6               3875      bsr lab_2115        * make string space d1 bytes long
00001E7E                          3876                      * return a0/Sutill = pointer, others unchanged
00001E7E  205F                    3877      movea.l (sp)+,a0        * restore string descriptor pointer
00001E80  2F00                    3878      move.l  d0,-(sp)        * save start offset (longword)
00001E82  618C                    3879      bsr.s   lab_22ba        * pop (a0) descriptor, returns with ..
00001E84                          3880                      * d0 = length, a0 = pointer
00001E84  D1DF                    3881      adda.l  (sp)+,a0        * adjust pointer to start of wanted string
00001E86  3001                    3882      move.w  d1,d0           * length to d0
00001E88  6100 FF5E               3883      bsr lab_229e        * store string d0 bytes long from (a0) to (Sutill)
00001E8C                          3884                      * return with a0 = pointer, d1 = length
00001E8C  6000 FDA6               3885      bra lab_rtst        * push string on descriptor stack
00001E90                          3886                      * a0 = pointer, d1 = length
00001E90                          3887  
00001E90                          3888  * perform MID$()
00001E90                          3889  
00001E90                          3890  lab_mids
00001E90  7E00                    3891      moveq   #0,d7           * clear longword
00001E92  5347                    3892      subq.w  #1,d7           * set default length = 65535
00001E94  6100 F66E               3893      bsr lab_gbyt        * scan memory
00001E98  B03C 0029               3894      cmp.b   #$29,d0         * compare with ")"
00001E9C  670A                    3895      beq.s   lab_2358        * branch if = ")" (skip second byte get)
00001E9E                          3896  
00001E9E  6100 F65A               3897      bsr lab_1c01        * find "," - else do syntax error/warm start
00001EA2  6100 00C6               3898      bsr lab_gtwo        * get word parameter, result in d0 and Itemp
00001EA6  2E00                    3899      move.l  d0,d7           * copy length
00001EA8                          3900  lab_2358
00001EA8  6122                    3901      bsr.s   lab_236f        * pull string data & byte parameter from stack
00001EAA                          3902                      * return pointer in a0, word in d0. destroys d1
00001EAA  7200                    3903      moveq   #0,d1           * null length
00001EAC  5380                    3904      subq.l  #1,d0           * decrement start index
00001EAE  6B00 E914               3905      bmi lab_fcer        * if was null do function call error, then warm start
00001EB2                          3906  
00001EB2  B068 0004               3907      cmp.w   4(a0),d0        * compare string length with start index
00001EB6  64C0                    3908      bcc.s   lab_231c        * if start not in string do null string (d1=0)
00001EB8                          3909  
00001EB8  2207                    3910      move.l  d7,d1           * get length back
00001EBA  DE40                    3911      add.w   d0,d7           * d7 now = MID$() end
00001EBC  6506                    3912      bcs.s   lab_2368        * already too long so do RIGHT$ equivalent
00001EBE                          3913  
00001EBE  BE68 0004               3914      cmp.w   4(a0),d7        * compare string length with start index + length
00001EC2  65B4                    3915      bcs.s   lab_231c        * if end in string go do string
00001EC4                          3916  
00001EC4                          3917  lab_2368
00001EC4  3228 0004               3918      move.w  4(a0),d1        * get string length
00001EC8  9240                    3919      sub.w   d0,d1           * subtract start offset
00001ECA  60AC                    3920      bra.s   lab_231c        * go do string (effectively RIGHT$)
00001ECC                          3921  
00001ECC                          3922  * pull string data & word parameter from stack
00001ECC                          3923  * return pointer in a0, word in d0. destroys d1
00001ECC                          3924  
00001ECC                          3925  lab_236f
00001ECC  6100 F624               3926      bsr lab_1bfb        * scan for ")" , else do syntax error/warm start
00001ED0  221F                    3927      move.l  (sp)+,d1        * pull return address
00001ED2  584F                    3928      addq    #4,sp           * skip type check on exit
00001ED4  7000                    3929      moveq   #0,d0           * clear longword
00001ED6  301F                    3930      move.w  (sp)+,d0        * pull word parameter
00001ED8  205F                    3931      move.l  (sp)+,a0        * pull string pointer
00001EDA  2F01                    3932      move.l  d1,-(sp)        * push return address
00001EDC  4E75                    3933      rts
00001EDE                          3934  
00001EDE                          3935  * perform LCASE$()
00001EDE                          3936  
00001EDE                          3937  lab_lcase
00001EDE  6100 FF26               3938      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
00001EE2  2200                    3939      move.l  d0,d1           * copy length and set flags
00001EE4  673E                    3940      beq.s   nostring        * branch if null string
00001EE6                          3941  
00001EE6  3400                    3942      move.w  d0,d2           * copy for counter
00001EE8  5382                    3943      subq.l  #1,d2           * subtract for DBF loop
00001EEA                          3944  lc_loop
00001EEA  1030 2000               3945      move.b  (a0,d2.w),d0        * get byte from string
00001EEE  6100 F810               3946      bsr lab_1d82        * is character "A" to "Z"
00001EF2  6408                    3947      bcc.s   noucase         * branch if not upper case alpha
00001EF4                          3948  
00001EF4  0000 0020               3949      ori.b   #$20,d0         * convert upper to lower case
00001EF8  1180 2000               3950      move.b  d0,(a0,d2.w)        * save byte back to string
00001EFC                          3951  noucase
00001EFC  51CA FFEC               3952      dbf d2,lc_loop      * decrement and loop if not all done
00001F00                          3953  
00001F00  6022                    3954      bra.s   nostring        * tidy up & exit (branch always)
00001F02                          3955  
00001F02                          3956  * perform UCASE$()
00001F02                          3957  
00001F02                          3958  lab_ucase
00001F02  6100 FF02               3959      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
00001F06  2200                    3960      move.l  d0,d1           * copy length and set flags
00001F08  671A                    3961      beq.s   nostring        * branch if null string
00001F0A                          3962  
00001F0A  3400                    3963      move.w  d0,d2           * copy for counter
00001F0C  5382                    3964      subq.l  #1,d2           * subtract for DBF loop
00001F0E                          3965  uc_loop
00001F0E  1030 2000               3966      move.b  (a0,d2.w),d0        * get byte from string
00001F12  6100 F7E6               3967      bsr lab_casc        * is character "a" to "z" (or "A" to "Z")
00001F16  6408                    3968      bcc.s   nolcase         * branch if not alpha
00001F18                          3969  
00001F18  0200 00DF               3970      andi.b  #$df,d0         * convert lower to upper case
00001F1C  1180 2000               3971      move.b  d0,(a0,d2.w)        * save byte back to string
00001F20                          3972  nolcase
00001F20  51CA FFEC               3973      dbf d2,uc_loop      * decrement and loop if not all done
00001F24                          3974  
00001F24                          3975  nostring
00001F24  584F                    3976      addq.w  #4,sp           * dump RTS address (skip numeric type check)
00001F26  6000 FD0C               3977      bra lab_rtst        * push string on descriptor stack
00001F2A                          3978                      * a0 = pointer, d1 = length
00001F2A                          3979  
00001F2A                          3980  * perform SADD()
00001F2A                          3981  
00001F2A                          3982  lab_sadd
00001F2A  6100 FEDA               3983      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
00001F2E  2008                    3984      move.l  a0,d0           * copy string address
00001F30  6000 FB62               3985      bra lab_ayfc        * convert d0 to signed longword in FAC1 & return
00001F34                          3986  
00001F34                          3987  * perform LEN()
00001F34                          3988  
00001F34                          3989  lab_lens
00001F34  6100 FED0               3990      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
00001F38  6000 FB82               3991      bra lab_1fd0        * convert d0 to unsigned byte in FAC1 & return
00001F3C                          3992  
00001F3C                          3993  * perform ASC()
00001F3C                          3994  
00001F3C                          3995  lab_asc
00001F3C  6100 FEC8               3996      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
00001F40  6700 E882               3997      beq lab_fcer        * if null do function call error, then warm start
00001F44                          3998  
00001F44  1010                    3999      move.b  (a0),d0         * get first character byte
00001F46  6000 FB74               4000      bra lab_1fd0        * convert d0 to unsigned byte in FAC1 & return
00001F4A                          4001  
00001F4A                          4002  * scan for "," and get byte, else do Syntax error then warm start
00001F4A                          4003  
00001F4A                          4004  lab_scgb
00001F4A  6100 F5AE               4005      bsr lab_1c01        * scan for "," , else do syntax error/warm start
00001F4E  6004                    4006      bra.s   lab_gtby        * get byte parameter, result in d0 and Itemp & RET
00001F50                          4007  
00001F50                          4008  * increment and get byte, result in d0 and Itemp
00001F50                          4009  
00001F50                          4010  lab_sgby
00001F50  6100 F5B0               4011      bsr lab_igby        * increment & scan memory
00001F54                          4012  
00001F54                          4013  * get byte parameter, result in d0 and Itemp
00001F54                          4014  
00001F54                          4015  lab_gtby
00001F54  6100 F3CE               4016      bsr lab_evnm        * evaluate expression & check is numeric,
00001F58                          4017                      * else do type mismatch
00001F58                          4018  
00001F58                          4019  * evaluate byte expression, result in d0 and Itemp
00001F58                          4020  
00001F58                          4021  lab_evby
00001F58  6100 F92E               4022      bsr lab_evpi        * evaluate positive integer expression
00001F5C                          4023                      * result in d0 and Itemp
00001F5C  2200                    4024      move.l  d0,d1           * copy result
00001F5E  C2BC FFFFFF00           4025      and.l   #$ffffff00,d1       * check top 24 bits
00001F64  6600 E85E               4026      bne lab_fcer        * if <> 0 do function call error/warm start
00001F68                          4027  
00001F68  4E75                    4028      rts
00001F6A                          4029  
00001F6A                          4030  * get word parameter, result in d0 and Itemp
00001F6A                          4031  
00001F6A                          4032  lab_gtwo
00001F6A  6100 F3B8               4033      bsr lab_evnm        * evaluate expression & check is numeric,
00001F6E                          4034                      * else do type mismatch
00001F6E  6100 F918               4035      bsr lab_evpi        * evaluate positive integer expression
00001F72                          4036                      * result in d0 and Itemp
00001F72  4840                    4037      swap    d0          * copy high word to low word
00001F74  4A40                    4038      tst.w   d0          * set flags
00001F76  6600 E84C               4039      bne lab_fcer        * if <> 0 do function call error/warm start
00001F7A                          4040  
00001F7A  4840                    4041      swap    d0          * copy high word to low word
00001F7C  4E75                    4042      rts
00001F7E                          4043  
00001F7E                          4044  * perform VAL()
00001F7E                          4045  
00001F7E                          4046  lab_val
00001F7E  6100 FE86               4047      bsr lab_evst        * evaluate string, returns d0 = length, a0 = pointer
00001F82  4A40                    4048      tst.w   d0          * check length
00001F84  6722                    4049      beq.s   lab_valz        * string was null so set result = $00
00001F86                          4050                      * clear FAC1 exponent & sign & return
00001F86                          4051  
00001F86  2C4D                    4052      movea.l a5,a6           * save BASIC execute pointer
00001F88  2A48                    4053      movea.l a0,a5           * copy string pointer to execute pointer
00001F8A  D1C0                    4054      adda.l  d0,a0           * string end+1
00001F8C  1010                    4055      move.b  (a0),d0         * get byte from string+1
00001F8E  3F00                    4056      move.w  d0,-(sp)        * save it
00001F90  2F08                    4057      move.l  a0,-(sp)        * save address
00001F92  10BC 0000               4058      move.b  #0,(a0)         * null terminate string
00001F96  6100 F56C               4059      bsr lab_gbyt        * scan memory
00001F9A  6100 10BC               4060      bsr lab_2887        * get FAC1 from string
00001F9E  205F                    4061      movea.l (sp)+,a0        * restore pointer
00001FA0  301F                    4062      move.w  (sp)+,d0        * pop byte
00001FA2  1080                    4063      move.b  d0,(a0)         * restore to memory
00001FA4  2A4E                    4064      movea.l a6,a5           * restore BASIC execute pointer
00001FA6  4E75                    4065      rts
00001FA8                          4066  
00001FA8                          4067  lab_valz
00001FA8  33C0 00040598           4068      move.w  d0,fac1_e       * clear FAC1 exponent & sign
00001FAE  4E75                    4069      rts
00001FB0                          4070  
00001FB0                          4071  * get two parameters for POKE or WAIT, first parameter in a0, second in d0
00001FB0                          4072  
00001FB0                          4073  lab_gadb
00001FB0  6100 F372               4074      bsr lab_evnm        * evaluate expression & check is numeric,
00001FB4                          4075                      * else do type mismatch
00001FB4  6100 063E               4076      bsr lab_2831        * convert FAC1 floating-to-fixed
00001FB8                          4077                      * result in d0 and Itemp
00001FB8  2F00                    4078      move.l  d0,-(sp)        * copy to stack
00001FBA  6100 F53E               4079      bsr lab_1c01        * scan for "," , else do syntax error/warm start
00001FBE  6194                    4080      bsr.s   lab_gtby        * get byte parameter, result in d0 and Itemp
00001FC0  205F                    4081      movea.l (sp)+,a0        * pull address
00001FC2  4E75                    4082      rts
00001FC4                          4083  
00001FC4                          4084  * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
00001FC4                          4085  
00001FC4                          4086  lab_gadw
00001FC4  611E                    4087      bsr.s   lab_gead        * get even address (for word/long memory actions)
00001FC6                          4088                      * address returned in d0 and on the stack
00001FC6  6100 F532               4089      bsr lab_1c01        * scan for "," , else do syntax error/warm start
00001FCA  6100 F358               4090      bsr lab_evnm        * evaluate expression & check is numeric,
00001FCE                          4091                      * else do type mismatch
00001FCE  6100 F8C2               4092      bsr lab_evir        * evaluate integer expression
00001FD2                          4093                      * result in d0 and Itemp
00001FD2  4840                    4094      swap    d0          * swap words
00001FD4  4A40                    4095      tst.w   d0          * test high word
00001FD6  6706                    4096      beq.s   lab_xgadw       * exit if null
00001FD8                          4097  
00001FD8  5240                    4098      addq.w  #1,d0           * increment word
00001FDA  6600 E7E8               4099      bne lab_fcer        * if <> 0 do function call error/warm start
00001FDE                          4100  
00001FDE                          4101  lab_xgadw
00001FDE  4840                    4102      swap    d0          * swap words back
00001FE0  205F                    4103      movea.l (sp)+,a0        * pull address
00001FE2  4E75                    4104      rts
00001FE4                          4105  
00001FE4                          4106  * get even address (for word or longword memory actions)
00001FE4                          4107  * address returned in d0 and on the stack
00001FE4                          4108  * does address error if the address is odd
00001FE4                          4109  
00001FE4                          4110  lab_gead
00001FE4  6100 F33E               4111      bsr lab_evnm        * evaluate expression & check is numeric,
00001FE8                          4112                      * else do type mismatch
00001FE8  6100 060A               4113      bsr lab_2831        * convert FAC1 floating-to-fixed
00001FEC                          4114                      * result in d0 and Itemp
00001FEC  0800 0000               4115      btst    #0,d0           * test low bit of longword
00001FF0  6600 E78E               4116      bne lab_ader        * if address is odd do address error/warm start
00001FF4                          4117  
00001FF4  205F                    4118      movea.l (sp)+,a0        * copy return address
00001FF6  2F00                    4119      move.l  d0,-(sp)        * address on stack
00001FF8  2F08                    4120      move.l  a0,-(sp)        * put return address back
00001FFA  4E75                    4121      rts
00001FFC                          4122  
00001FFC                          4123  * perform PEEK()
00001FFC                          4124  
00001FFC                          4125  lab_peek
00001FFC  6100 05F6               4126      bsr lab_2831        * convert FAC1 floating-to-fixed
00002000                          4127                      * result in d0 and Itemp
00002000  2040                    4128      movea.l d0,a0           * copy to address register
00002002  1010                    4129      move.b  (a0),d0         * get byte
00002004  6000 FAB6               4130      bra lab_1fd0        * convert d0 to unsigned byte in FAC1 & return
00002008                          4131  
00002008                          4132  * perform POKE
00002008                          4133  
00002008                          4134  lab_poke
00002008  61A6                    4135      bsr.s   lab_gadb        * get two parameters for POKE or WAIT
0000200A                          4136                      * first parameter in a0, second in d0
0000200A  1080                    4137      move.b  d0,(a0)         * put byte in memory
0000200C  4E75                    4138      rts
0000200E                          4139  
0000200E                          4140  * perform DEEK()
0000200E                          4141  
0000200E                          4142  lab_deek
0000200E  6100 05E4               4143      bsr lab_2831        * convert FAC1 floating-to-fixed
00002012                          4144                      * result in d0 and Itemp
00002012  0800 0000               4145      btst    #0,d0           * test low bit of longword
00002016  6600 E768               4146      bne lab_ader        * if address is odd do address error/warm start
0000201A                          4147  
0000201A  C188                    4148      exg d0,a0           * copy to address register
0000201C  7000                    4149      moveq   #0,d0           * clear top bits
0000201E  3010                    4150      move.w  (a0),d0         * get word
00002020  6000 FA72               4151      bra lab_ayfc        * convert d0 to signed longword in FAC1 & return
00002024                          4152  
00002024                          4153  * perform LEEK()
00002024                          4154  
00002024                          4155  lab_leek
00002024  6100 05CE               4156      bsr lab_2831        * convert FAC1 floating-to-fixed
00002028                          4157                      * result in d0 and Itemp
00002028  0800 0000               4158      btst    #0,d0           * test low bit of longword
0000202C  6600 E752               4159      bne lab_ader        * if address is odd do address error/warm start
00002030                          4160  
00002030  C188                    4161      exg d0,a0           * copy to address register
00002032  2010                    4162      move.l  (a0),d0         * get word
00002034  6000 FA5E               4163      bra lab_ayfc        * convert d0 to signed longword in FAC1 & return
00002038                          4164  
00002038                          4165  * perform DOKE
00002038                          4166  
00002038                          4167  lab_doke
00002038  618A                    4168      bsr.s   lab_gadw        * get two parameters for DOKE or WAIT
0000203A                          4169                      * first parameter in a0, second in d0
0000203A  3080                    4170      move.w  d0,(a0)         * put word in memory
0000203C  4E75                    4171      rts
0000203E                          4172  
0000203E                          4173  * perform LOKE
0000203E                          4174  
0000203E                          4175  lab_loke
0000203E  61A4                    4176      bsr.s   lab_gead        * get even address
00002040                          4177                      * address returned in d0 and on the stack
00002040  6100 F4B8               4178      bsr lab_1c01        * scan for "," , else do syntax error/warm start
00002044  6100 F2DE               4179      bsr lab_evnm        * evaluate expression & check is numeric,
00002048                          4180                      * else do type mismatch
00002048  6100 F848               4181      bsr lab_evir        * evaluate integer value (no sign check)
0000204C  205F                    4182      movea.l (sp)+,a0        * pull address
0000204E  2080                    4183      move.l  d0,(a0)         * put longword in memory
00002050                          4184  rts_015
00002050  4E75                    4185      rts
00002052                          4186  
00002052                          4187  * perform SWAP
00002052                          4188  
00002052                          4189  lab_swap
00002052  6100 F6C8               4190      bsr lab_gvar        * get var1 address
00002056                          4191                      * return pointer to variable in Cvaral and a0
00002056  2648                    4192      movea.l a0,a3           * copy address
00002058  1639 000405BD           4193      move.b  dtypef,d3       * get data type, $80=string, $40=inetger $00=float
0000205E                          4194  
0000205E  6100 F49A               4195      bsr lab_1c01        * scan for "," , else do syntax error/warm start
00002062  6100 F6B8               4196      bsr lab_gvar        * get var2 address (pointer in Cvaral/h)
00002066                          4197                      * return pointer to variable in Cvaral and a0
00002066  B639 000405BD           4198      cmp.b   dtypef,d3       * compare with var2 data type
0000206C  6600 E736               4199      bne lab_tmer        * if not both the same type do "Type mismatch"
00002070                          4200                      * error then warm start
00002070                          4201  
00002070  2010                    4202      move.l  (a0),d0         * get var2
00002072  2093                    4203      move.l  (a3),(a0)       * copy var1 to var2
00002074  2680                    4204      move.l  d0,(a3)         * save var2 to var1
00002076                          4205  
00002076  4A03                    4206      tst.b   d3          * check data type
00002078  6AD6                    4207      bpl.s   rts_015         * exit if not string
0000207A                          4208  
0000207A  3028 0004               4209      move.w  4(a0),d0        * get string 2 length
0000207E  316B 0004 0004          4210      move.w  4(a3),4(a0)     * copy string 1 length to string 2 length
00002084  3740 0004               4211      move.w  d0,4(a3)        * save string 2 length to string 1 length
00002088  4E75                    4212      rts
0000208A                          4213  
0000208A                          4214  * perform CALL
0000208A                          4215  
0000208A                          4216  lab_call
0000208A  6100 F298               4217      bsr lab_evnm        * evaluate expression & check is numeric,
0000208E                          4218                      * else do type mismatch
0000208E  6100 0564               4219      bsr lab_2831        * convert FAC1 floating-to-fixed
00002092                          4220                      * result in d0 and Itemp
00002092  487A F470               4221      pea (lab_gbyt,pc)       * put return address on stack
00002096  2040                    4222      movea.l d0,a0           * address into address register
00002098  4ED0                    4223      jmp (a0)            * do indirect jump to user routine
0000209A                          4224  
0000209A                          4225  * if the called routine exits correctly then it will return via the get byte routine.
0000209A                          4226  * this will then get the next byte for the interpreter and return
0000209A                          4227  
0000209A                          4228  * perform WAIT
0000209A                          4229  
0000209A                          4230  lab_wait
0000209A  6100 FF14               4231      bsr lab_gadb        * get two parameters for POKE or WAIT
0000209E                          4232                      * first parameter in a0, second in d0
0000209E  2F08                    4233      move.l  a0,-(sp)        * save address
000020A0  3F00                    4234      move.w  d0,-(sp)        * save byte
000020A2  7400                    4235      moveq   #0,d2           * clear mask
000020A4  6100 F45E               4236      bsr lab_gbyt        * scan memory
000020A8  6706                    4237      beq.s   lab_2441        * skip if no third argument
000020AA                          4238  
000020AA  6100 FE9E               4239      bsr lab_scgb        * scan for "," & get byte,
000020AE                          4240                      * else do syntax error/warm start
000020AE  2400                    4241      move.l  d0,d2           * copy mask
000020B0                          4242  lab_2441
000020B0  321F                    4243      move.w  (sp)+,d1        * get byte
000020B2  205F                    4244      movea.l (sp)+,a0        * get address
000020B4                          4245  lab_2445
000020B4  1010                    4246      move.b  (a0),d0         * read memory byte
000020B6  B500                    4247      eor.b   d2,d0           * EOR with second argument (mask)
000020B8  C001                    4248      and.b   d1,d0           * AND with first argument (byte)
000020BA  67F8                    4249      beq.s   lab_2445        * loop if result is zero
000020BC                          4250  
000020BC  4E75                    4251      rts
000020BE                          4252  
000020BE                          4253  * perform subtraction, FAC1 from FAC2
000020BE                          4254  
000020BE                          4255  lab_subtract
000020BE  0A39 0080 00040599      4256      eori.b  #$80,fac1_s     * complement FAC1 sign
000020C6  13F9 000405A1 000405A2  4257      move.b  fac2_s,fac_sc       * copy FAC2 sign byte
000020D0                          4258  
000020D0  1039 00040599           4259      move.b  fac1_s,d0       * get FAC1 sign byte
000020D6  B139 000405A2           4260      eor.b   d0,fac_sc       * EOR with FAC2 sign
000020DC                          4261  
000020DC  6008                    4262      bra.s   lab_add         * go add FAC2 to FAC1
000020DE                          4263  
000020DE                          4264  * add 0.5 to FAC1
000020DE                          4265  
000020DE                          4266  lab_244e
000020DE  41FA 16B6               4267      lea (lab_2a96,pc),a0    * set 0.5 pointer
000020E2                          4268  
000020E2                          4269  * perform addition, add (a0) to FAC1
000020E2                          4270  
000020E2                          4271  lab_246c
000020E2  6100 02AC               4272      bsr lab_264d        * unpack memory (a0) into FAC2
000020E6                          4273  
000020E6                          4274  * add FAC2 to FAC1
000020E6                          4275  
000020E6                          4276  lab_add
000020E6  1039 00040598           4277      move.b  fac1_e,d0       * get exponent
000020EC  6700 0442               4278      beq lab_279b        * FAC1 was zero so copy FAC2 to FAC1 & return
000020F0                          4279  
000020F0                          4280                      * FAC1 is non zero
000020F0  207C 0004059C           4281      movea.l #fac2_m,a0      * set pointer1 to FAC2 mantissa
000020F6  1039 000405A0           4282      move.b  fac2_e,d0       * get FAC2 exponent
000020FC  6756                    4283      beq.s   rts_016         * exit if zero
000020FE                          4284  
000020FE  9039 00040598           4285      sub.b   fac1_e,d0       * subtract FAC1 exponent
00002104  6726                    4286      beq.s   lab_24a8        * branch if = (go add mantissa)
00002106                          4287  
00002106  650E                    4288      bcs.s   lab_249c        * branch if FAC2 < FAC1
00002108                          4289  
00002108                          4290                      * FAC2 > FAC1
00002108  33F9 000405A0 00040598  4291      move.w  fac2_e,fac1_e       * copy sign and exponent of FAC2
00002112  4400                    4292      neg.b   d0          * negate exponent difference (make diff -ve)
00002114  5148                    4293      subq.w  #8,a0           * pointer1 to FAC1
00002116                          4294  
00002116                          4295  lab_249c
00002116  4400                    4296      neg.b   d0          * negate exponent difference (make diff +ve)
00002118  2F01                    4297      move.l  d1,-(sp)        * save d1
0000211A  B03C 0020               4298      cmp.b   #32,d0          * compare exponent diff with 32
0000211E  6D04                    4299      blt.s   lab_2467        * branch if range >= 32
00002120                          4300  
00002120  7200                    4301      moveq   #0,d1           * clear d1
00002122  6004                    4302      bra.s   lab_2468        * go clear smaller mantissa
00002124                          4303  
00002124                          4304  lab_2467
00002124  2210                    4305      move.l  (a0),d1         * get FACx mantissa
00002126  E0A9                    4306      lsr.l   d0,d1           * shift d0 times right
00002128                          4307  lab_2468
00002128  2081                    4308      move.l  d1,(a0)         * save it back
0000212A  221F                    4309      move.l  (sp)+,d1        * restore d1
0000212C                          4310  
0000212C                          4311                      * exponents are equal now do mantissa add/subtract
0000212C                          4312  lab_24a8
0000212C  4A39 000405A2           4313      tst.b   fac_sc          * test sign compare (FAC1 EOR FAC2)
00002132  6B22                    4314      bmi.s   lab_24f8        * if <> go do subtract
00002134                          4315  
00002134  2039 0004059C           4316      move.l  fac2_m,d0       * get FAC2 mantissa
0000213A  D0B9 00040594           4317      add.l   fac1_m,d0       * add FAC1 mantissa
00002140  640C                    4318      bcc.s   lab_24f7        * save and exit if no carry (FAC1 is normal)
00002142                          4319  
00002142  E290                    4320      roxr.l  #1,d0           * else shift carry back into mantissa
00002144  5239 00040598           4321      addq.b  #1,fac1_e       * increment FAC1 exponent
0000214A  6500 E674               4322      bcs lab_ofer        * if carry do overflow error & warm start
0000214E                          4323  
0000214E                          4324  lab_24f7
0000214E  23C0 00040594           4325      move.l  d0,fac1_m       * save mantissa
00002154                          4326  rts_016
00002154  4E75                    4327      rts
00002156                          4328                      * signs are different
00002156                          4329  lab_24f8
00002156  227C 00040594           4330      movea.l #fac1_m,a1      * pointer 2 to FAC1
0000215C  B3C8                    4331      cmpa.l  a0,a1           * compare pointers
0000215E  6602                    4332      bne.s   lab_24b4        * branch if <>
00002160                          4333  
00002160  5049                    4334      addq.w  #8,a1           * else pointer2 to FAC2
00002162                          4335  
00002162                          4336                      * take smaller from bigger (take sign of bigger)
00002162                          4337  lab_24b4
00002162  2011                    4338      move.l  (a1),d0         * get larger mantissa
00002164  2210                    4339      move.l  (a0),d1         * get smaller mantissa
00002166  23C0 00040594           4340      move.l  d0,fac1_m       * save larger mantissa
0000216C  93B9 00040594           4341      sub.l   d1,fac1_m       * subtract smaller
00002172                          4342  
00002172                          4343  * do +/- (carry is sign) & normalise FAC1
00002172                          4344  
00002172                          4345  lab_24d0
00002172  640E                    4346      bcc.s   lab_24d5        * branch if result is +ve
00002174                          4347  
00002174                          4348                      * erk! subtract wrong way round, negate everything
00002174  0A39 00FF 00040599      4349      eori.b  #$ff,fac1_s     * complement FAC1 sign
0000217C  44B9 00040594           4350      neg.l   fac1_m          * negate FAC1 mantissa
00002182                          4351  
00002182                          4352  * normalise FAC1
00002182                          4353  
00002182                          4354  lab_24d5
00002182  2039 00040594           4355      move.l  fac1_m,d0       * get mantissa
00002188  6B36                    4356      bmi.s   lab_24da        * mantissa is normal so just exit
0000218A                          4357  
0000218A  6608                    4358      bne.s   lab_24d9        * mantissa is not zero so go normalise FAC1
0000218C                          4359  
0000218C  33C0 00040598           4360      move.w  d0,fac1_e       * else make FAC1 = +zero
00002192  4E75                    4361      rts
00002194                          4362  
00002194                          4363  lab_24d9
00002194  2F01                    4364      move.l  d1,-(sp)        * save d1
00002196  2200                    4365      move.l  d0,d1           * mantissa to d1
00002198  7000                    4366      moveq   #0,d0           * clear d0
0000219A  1039 00040598           4367      move.b  fac1_e,d0       * get exponent byte
000021A0  6716                    4368      beq.s   lab_24d8        * if exponent is zero then clean up and exit
000021A2                          4369  lab_24d6
000021A2  D281                    4370      add.l   d1,d1           * shift mantissa (ADD is quicker for single shift)
000021A4  5BC8 FFFC               4371      dbmi    d0,lab_24d6     * decrement exponent and loop if mantissa and
000021A8                          4372                      * exponent +ve
000021A8                          4373  
000021A8  4A40                    4374      tst.w   d0          * test exponent
000021AA  670C                    4375      beq.s   lab_24d8        * if exponent is zero make FAC1 zero
000021AC                          4376  
000021AC  6A02                    4377      bpl.s   lab_24d7        * if exponent is >zero go save FAC1
000021AE                          4378  
000021AE  7001                    4379      moveq   #1,d0           * else set for zero after correction
000021B0                          4380  lab_24d7
000021B0  5300                    4381      subq.b  #1,d0           * adjust exponent for loop
000021B2  23C1 00040594           4382      move.l  d1,fac1_m       * save normalised mantissa
000021B8                          4383  lab_24d8
000021B8  221F                    4384      move.l  (sp)+,d1        * restore d1
000021BA  13C0 00040598           4385      move.b  d0,fac1_e       * save corrected exponent
000021C0                          4386  lab_24da
000021C0  4E75                    4387      rts
000021C2                          4388  
000021C2                          4389  * perform LOG()
000021C2                          4390  
000021C2                          4391  lab_log
000021C2  4A39 00040599           4392      tst.b   fac1_s          * test sign
000021C8  6B00 E5FA               4393      bmi lab_fcer        * if -ve do function call error/warm start
000021CC                          4394  
000021CC  7E00                    4395      moveq   #0,d7           * clear d7
000021CE  13C7 000405A2           4396      move.b  d7,fac_sc       * clear sign compare
000021D4  1E39 00040598           4397      move.b  fac1_e,d7       * get exponent
000021DA  6700 E5E8               4398      beq lab_fcer        * if 0 do function call error/warm start
000021DE                          4399  
000021DE  0487 00000081           4400      sub.l   #$81,d7         * normalise exponent
000021E4  13FC 0081 00040598      4401      move.b  #$81,fac1_e     * force a value between 1 and 2
000021EC  2C39 00040594           4402      move.l  fac1_m,d6       * copy mantissa
000021F2                          4403  
000021F2  23FC 80000000 0004059C  4404      move.l  #$80000000,fac2_m   * set mantissa for 1
000021FC  33FC 8100 000405A0      4405      move.w  #$8100,fac2_e       * set exponent for 1
00002204  6100 FEE0               4406      bsr lab_add         * find arg+1
00002208  7000                    4407      moveq   #0,d0           * setup for calc skip
0000220A  33C0 000405A0           4408      move.w  d0,fac2_e       * set FAC1 for zero result
00002210  DC86                    4409      add.l   d6,d6           * shift 1 bit out
00002212  23C6 0004059C           4410      move.l  d6,fac2_m       * put back FAC2
00002218  6762                    4411      beq.s   lab_lonn        * if 0 skip calculation
0000221A                          4412  
0000221A  33FC 8000 000405A0      4413      move.w  #$8000,fac2_e       * set exponent for .5
00002222  6100 01D8               4414      bsr lab_divide      * do (arg-1)/(arg+1)
00002226  4A39 00040598           4415      tst.b   fac1_e          * test exponent
0000222C  674E                    4416      beq.s   lab_lonn        * if 0 skip calculation
0000222E                          4417  
0000222E  1239 00040598           4418      move.b  fac1_e,d1       * get exponent
00002234  0401 0082               4419      sub.b   #$82,d1         * normalise and two integer bits
00002238  4401                    4420      neg.b   d1          * negate for shift
0000223A                          4421  **  cmp.b   #$1f,d1         * will mantissa vanish?
0000223A                          4422  **  bgt.s   lab_dunno       * if so do ???
0000223A                          4423  
0000223A  2039 00040594           4424      move.l  fac1_m,d0       * get mantissa
00002240  E2A8                    4425      lsr.l   d1,d0           * shift in two integer bits
00002242                          4426  
00002242                          4427  * d0 = arg
00002242                          4428  * d0 = x, d1 = y
00002242                          4429  * d2 = x1, d3 = y1
00002242                          4430  * d4 = shift count
00002242                          4431  * d5 = loop count
00002242                          4432  * d6 = z
00002242                          4433  * a0 = table pointer
00002242                          4434  
00002242  7C00                    4435      moveq   #0,d6           * z = 0
00002244  223C 40000000           4436      move.l  #1<<30,d1       * y = 1
0000224A  207C 0000358C           4437      movea.l #tab_hthet,a0       * pointer to hyperbolic tangent table
00002250  7A1E                    4438      moveq   #30,d5          * loop 31 times
00002252  7801                    4439      moveq   #1,d4           * set shift count
00002254  6006                    4440      bra.s   lab_locc        * entry point for loop
00002256                          4441  
00002256                          4442  lab_laad
00002256  E8A2                    4443      asr.l   d4,d2           * x1 >> i
00002258  9282                    4444      sub.l   d2,d1           * y = y - x1
0000225A  DC90                    4445      add.l   (a0),d6         * z = z + tanh(i)
0000225C                          4446  lab_locc
0000225C  2400                    4447      move.l  d0,d2           * x1 = x
0000225E  2601                    4448      move.l  d1,d3           * y1 = Y
00002260  E8A3                    4449      asr.l   d4,d3           * y1 >> i
00002262  6402                    4450      bcc.s   lab_lolp
00002264                          4451  
00002264  5283                    4452      addq.l  #1,d3
00002266                          4453  lab_lolp
00002266  9083                    4454      sub.l   d3,d0           * x = x - y1
00002268  6AEC                    4455      bpl.s   lab_laad        * branch if > 0
0000226A                          4456  
0000226A  2002                    4457      move.l  d2,d0           * get x back
0000226C  5848                    4458      addq.w  #4,a0           * next entry
0000226E  5284                    4459      addq.l  #1,d4           * next i
00002270  E28B                    4460      lsr.l   #1,d3           * /2
00002272  6704                    4461      beq.s   lab_locx        * branch y1 = 0
00002274                          4462  
00002274  51CD FFF0               4463      dbf d5,lab_lolp     * decrement and loop if not done
00002278                          4464  
00002278                          4465                      * now sort out the result
00002278                          4466  lab_locx
00002278  DC86                    4467      add.l   d6,d6           * *2
0000227A  2006                    4468      move.l  d6,d0           * setup for d7 = 0
0000227C                          4469  lab_lonn
0000227C  2800                    4470      move.l  d0,d4           * save cordic result
0000227E  7A00                    4471      moveq   #0,d5           * set default exponent sign
00002280  4A87                    4472      tst.l   d7          * check original exponent sign
00002282  6718                    4473      beq.s   lab_loxo        * branch if original was 0
00002284                          4474  
00002284  6A04                    4475      bpl.s   lab_loxp        * branch if was +ve
00002286                          4476  
00002286  4487                    4477      neg.l   d7          * make original exponent +ve
00002288  7A80                    4478      moveq   #$80-$100,d5        * make sign -ve
0000228A                          4479  lab_loxp
0000228A  13C5 00040599           4480      move.b  d5,fac1_s       * save original exponent sign
00002290  4847                    4481      swap    d7          * 16 bit shift
00002292  E18F                    4482      lsl.l   #8,d7           * easy first part
00002294  7A88                    4483      moveq   #$88-$100,d5        * start with byte
00002296                          4484  lab_lone
00002296  5385                    4485      subq.l  #1,d5           * decrement exponent
00002298  DE87                    4486      add.l   d7,d7           * shift mantissa
0000229A  6AFA                    4487      bpl.s   lab_lone        * loop if not normal
0000229C                          4488  
0000229C                          4489  lab_loxo
0000229C  23C7 00040594           4490      move.l  d7,fac1_m       * save original exponent as mantissa
000022A2  13C5 00040598           4491      move.b  d5,fac1_e       * save exponent for this
000022A8  23FC B17217F8 0004059C  4492      move.l  #$b17217f8,fac2_m   * LOG(2) mantissa
000022B2  33FC 8000 000405A0      4493      move.w  #$8000,fac2_e       * LOG(2) exponent & sign
000022BA  13F9 00040599 000405A2  4494      move.b  fac1_s,fac_sc       * make sign compare = FAC1 sign
000022C4  6120                    4495      bsr.s   lab_multiply        * do multiply
000022C6  23C4 0004059C           4496      move.l  d4,fac2_m       * save cordic result
000022CC  6716                    4497      beq.s   lab_lowz        * branch if zero
000022CE                          4498  
000022CE  33FC 8200 000405A0      4499      move.w  #$8200,fac2_e       * set exponent & sign
000022D6  13F9 00040599 000405A2  4500      move.b  fac1_s,fac_sc       * clear sign compare
000022E0  6100 FE04               4501      bsr lab_add         * and add for final result
000022E4                          4502  
000022E4                          4503  lab_lowz
000022E4  4E75                    4504      rts
000022E6                          4505  
000022E6                          4506  * multiply FAC1 by FAC2
000022E6                          4507  
000022E6                          4508  lab_multiply
000022E6  48E7 F800               4509      movem.l d0-d4,-(sp)     * save registers
000022EA  4A39 00040598           4510      tst.b   fac1_e          * test FAC1 exponent
000022F0  6700 008E               4511      beq lab_muuf        * if exponent zero go make result zero
000022F4                          4512  
000022F4  1039 000405A0           4513      move.b  fac2_e,d0       * get FAC2 exponent
000022FA  6700 0084               4514      beq lab_muuf        * if exponent zero go make result zero
000022FE                          4515  
000022FE  13F9 000405A2 00040599  4516      move.b  fac_sc,fac1_s       * sign compare becomes sign
00002308                          4517  
00002308  D039 00040598           4518      add.b   fac1_e,d0       * multiply exponents by adding
0000230E  640A                    4519      bcc.s   lab_mnoc        * branch if no carry
00002310                          4520  
00002310  0400 0080               4521      sub.b   #$80,d0         * normalise result
00002314  6400 E4AA               4522      bcc lab_ofer        * if no carry do overflow
00002318                          4523  
00002318  6008                    4524      bra.s   lab_madd        * branch
0000231A                          4525  
0000231A                          4526                      * no carry for exponent add
0000231A                          4527  lab_mnoc
0000231A  0400 0080               4528      sub.b   #$80,d0         * normalise result
0000231E  6500 0060               4529      bcs lab_muuf        * return zero if underflow
00002322                          4530  
00002322                          4531  lab_madd
00002322  13C0 00040598           4532      move.b  d0,fac1_e       * save exponent
00002328                          4533  
00002328                          4534                      * d1 (FAC1) x d2 (FAC2)
00002328  2239 00040594           4535      move.l  fac1_m,d1       * get FAC1 mantissa
0000232E  2439 0004059C           4536      move.l  fac2_m,d2       * get FAC2 mantissa
00002334                          4537  
00002334  3801                    4538      move.w  d1,d4           * copy low word FAC1
00002336  2001                    4539      move.l  d1,d0           * copy long word FAC1
00002338  4840                    4540      swap    d0          * high word FAC1 to low word FAC1
0000233A  3600                    4541      move.w  d0,d3           * copy high word FAC1
0000233C                          4542  
0000233C  C2C2                    4543      mulu    d2,d1           * low word FAC2 x low word FAC1
0000233E  C0C2                    4544      mulu    d2,d0           * low word FAC2 x high word FAC1
00002340  4842                    4545      swap    d2          * high word FAC2 to low word FAC2
00002342  C8C2                    4546      mulu    d2,d4           * high word FAC2 x low word FAC1
00002344  C6C2                    4547      mulu    d2,d3           * high word FAC2 x high word FAC1
00002346                          4548  
00002346                          4549  * done multiply, now add partial products
00002346                          4550  
00002346                          4551  *                 d1 =                          aaaa  ----  FAC2_L x FAC1_L
00002346                          4552  *                 d0 =                    bbbb  aaaa        FAC2_L x FAC1_H
00002346                          4553  *                 d4 =                    bbbb  aaaa        FAC2_H x FAC1_L
00002346                          4554  *                 d3 =              cccc  bbbb              FAC2_H x FAC1_H
00002346                          4555  *                 product =         mmmm  mmmm
00002346                          4556  
00002346  0681 00008000           4557      add.l   #$8000,d1       * round up lowest word
0000234C  4241                    4558      clr.w   d1          * clear low word, don't need it
0000234E  4841                    4559      swap    d1          * align high word
00002350  D280                    4560      add.l   d0,d1           * add FAC2_L x FAC1_H (can't be carry)
00002352                          4561  lab_muf1
00002352  D284                    4562      add.l   d4,d1           * now add intermediate (FAC2_H x FAC1_L)
00002354  6406                    4563      bcc.s   lab_muf2        * branch if no carry
00002356                          4564  
00002356  0683 00010000           4565      add.l   #$10000,d3      * else correct result
0000235C                          4566  lab_muf2
0000235C  0681 00008000           4567      add.l   #$8000,d1       * round up low word
00002362  4241                    4568      clr.w   d1          * clear low word
00002364  4841                    4569      swap    d1          * align for final add
00002366  D283                    4570      add.l   d3,d1           * add FAC2_H x FAC1_H, result
00002368  6B0A                    4571      bmi.s   lab_muf3        * branch if normalisation not needed
0000236A                          4572  
0000236A  D281                    4573      add.l   d1,d1           * shift mantissa
0000236C  5339 00040598           4574      subq.b  #1,fac1_e       * adjust exponent
00002372  670C                    4575      beq.s   lab_muuf        * branch if underflow
00002374                          4576  
00002374                          4577  lab_muf3
00002374  23C1 00040594           4578      move.l  d1,fac1_m       * save mantissa
0000237A                          4579  lab_muex
0000237A  4CDF 001F               4580      movem.l (sp)+,d0-d4     * restore registers
0000237E  4E75                    4581      rts
00002380                          4582                      * either zero or underflow result
00002380                          4583  lab_muuf
00002380  7000                    4584      moveq   #0,d0           * quick clear
00002382  23C0 00040594           4585      move.l  d0,fac1_m       * clear mantissa
00002388  33C0 00040598           4586      move.w  d0,fac1_e       * clear sign and exponent
0000238E  60EA                    4587      bra.s   lab_muex        * restore regs & exit
00002390                          4588  
00002390                          4589  * unpack memory (a0) into FAC2, trashes d0
00002390                          4590  
00002390                          4591  lab_264d
00002390  2010                    4592      move.l  (a0),d0         * get value
00002392  4840                    4593      swap    d0          * exponent and sign to bits 0-15
00002394  33C0 000405A0           4594      move.w  d0,fac2_e       * save FAC2 exponent & sign
0000239A  13C0 000405A2           4595      move.b  d0,fac_sc       * save sign as sign compare
000023A0  803C 0080               4596      or.b    #$80,d0         * restore MSb
000023A4  4840                    4597      swap    d0          * swap words back
000023A6                          4598  
000023A6  E180                    4599      asl.l   #8,d0           * shift exponent & clear guard byte
000023A8  23C0 0004059C           4600      move.l  d0,fac2_m       * move into FAC2
000023AE                          4601  
000023AE  1039 00040599           4602      move.b  fac1_s,d0       * get FAC1 sign
000023B4  B139 000405A2           4603      eor.b   d0,fac_sc       * make sign compare (FAC1_s EOR FAC2_s)
000023BA                          4604  
000023BA  4E75                    4605      rts
000023BC                          4606  
000023BC                          4607  * multiply by 10
000023BC                          4608  
000023BC                          4609  lab_269e
000023BC  4A39 00040598           4610      tst.b   fac1_e          * test exponent byte
000023C2  6734                    4611      beq.s   x10exit         * exit if zero
000023C4                          4612  
000023C4  2F00                    4613      move.l  d0,-(sp)        * save d0
000023C6  2039 00040594           4614      move.l  fac1_m,d0       * get FAC1
000023CC  E488                    4615      lsr.l   #2,d0           * /4
000023CE  6402                    4616      bcc.s   x10nornd        * if no carry don't round up
000023D0                          4617  
000023D0  5280                    4618      addq.l  #1,d0           * round up least bit, there won't be any carry
000023D2                          4619  x10nornd
000023D2  D0B9 00040594           4620      add.l   fac1_m,d0       * add FAC1 (x1.125)
000023D8  640C                    4621      bcc.s   x10exp          * branch if no carry
000023DA                          4622  
000023DA  E290                    4623      roxr.l  #1,d0           * shift carry back in
000023DC  5239 00040598           4624      addq.b  #1,fac1_e       * increment exponent
000023E2  6500 E3DC               4625      bcs lab_ofer        * branch if overflow
000023E6                          4626  
000023E6                          4627  x10exp
000023E6  23C0 00040594           4628      move.l  d0,fac1_m       * save new mantissa
000023EC  5639 00040598           4629      addq.b  #3,fac1_e       * correct exponent ( 8 x 1.125 = 10 )
000023F2  6500 E3CC               4630      bcs lab_ofer        * branch if overflow
000023F6                          4631  
000023F6  201F                    4632      move.l  (sp)+,d0        * restore d0
000023F8                          4633  x10exit
000023F8  4E75                    4634      rts
000023FA                          4635  
000023FA                          4636  * convert a0 and do (a0)/FAC1
000023FA                          4637  
000023FA                          4638  lab_26ca
000023FA  6194                    4639      bsr lab_264d        * unpack memory (a0) into FAC2, trashes d0
000023FC                          4640  
000023FC                          4641  * do FAC2/FAC1, result in FAC1
000023FC                          4642  * fast hardware version
000023FC                          4643  
000023FC                          4644  lab_divide
000023FC  2F07                    4645      move.l  d7,-(sp)        * save d7
000023FE  7000                    4646      moveq   #0,d0           * clear FAC2 exponent
00002400  2400                    4647      move.l  d0,d2           * clear FAC1 exponent
00002402                          4648  
00002402  1439 00040598           4649      move.b  fac1_e,d2       * get FAC1 exponent
00002408  6700 E3A2               4650      beq lab_dzer        * if zero go do /0 error
0000240C                          4651  
0000240C  1039 000405A0           4652      move.b  fac2_e,d0       * get FAC2 exponent
00002412  677A                    4653      beq.s   lab_div0        * if zero return zero
00002414                          4654  
00002414  9042                    4655      sub.w   d2,d0           * get result exponent by subtracting
00002416  0640 0080               4656      add.w   #$80,d0         * correct 16 bit exponent result
0000241A                          4657  
0000241A  13F9 000405A2 00040599  4658      move.b  fac_sc,fac1_s       * sign compare is result sign
00002424                          4659  
00002424                          4660  * now to do 32/32 bit mantissa divide
00002424                          4661  
00002424  4239 000405A3           4662      clr.b   flag            * clear 'flag' byte
0000242A  2639 00040594           4663      move.l  fac1_m,d3       * get FAC1 mantissa
00002430  2839 0004059C           4664      move.l  fac2_m,d4       * get FAC2 mantissa
00002436  B883                    4665      cmp.l   d3,d4           * compare FAC2 with FAC1 mantissa
00002438  674E                    4666      beq.s   lab_man1        * set mantissa result = 1 if equal
0000243A                          4667  
0000243A  6508                    4668      bcs.s   ac1gtac2        * branch if FAC1 > FAC2
0000243C                          4669  
0000243C  9883                    4670      sub.l   d3,d4           * subtract FAC1 from FAC2 (result now must be <1)
0000243E  5639 000405A3           4671      addq.b  #3,flag         * FAC2>FAC1 so set 'flag' byte
00002444                          4672  ac1gtac2
00002444  614E                    4673      bsr.s   lab_32_16       * do 32/16 divide
00002446  4841                    4674      swap    d1          * move 16 bit result to high word
00002448  2802                    4675      move.l  d2,d4           * copy remainder longword
0000244A  614A                    4676      bsr.s   lab_3216        * do 32/16 divide again (skip copy d4 to d2)
0000244C  84C5                    4677      divu    d5,d2           * now divide remainder to make guard word
0000244E  1E39 000405A3           4678      move.b  flag,d7         * now normalise, get flag byte back
00002454  6708                    4679      beq.s   lab_divx        * skip add if null
00002456                          4680  
00002456                          4681  * else result was >1 so we need to add 1 to result mantissa and adjust exponent
00002456                          4682  
00002456  E20F                    4683      lsr.b   #1,d7           * shift 1 into eXtend
00002458  E291                    4684      roxr.l  #1,d1           * shift extend result >>
0000245A  E252                    4685      roxr.w  #1,d2           * shift extend guard word >>
0000245C  5200                    4686      addq.b  #1,d0           * adjust exponent
0000245E                          4687  
0000245E                          4688  * now round result to 32 bits
0000245E                          4689  
0000245E                          4690  lab_divx
0000245E  D442                    4691      add.w   d2,d2           * guard bit into eXtend bit
00002460  6408                    4692      bcc.s   l_divrnd        * branch if guard=0
00002462                          4693  
00002462  5281                    4694      addq.l  #1,d1           * add guard to mantissa
00002464  6404                    4695      bcc.s   l_divrnd        * branch if no overflow
00002466                          4696  
00002466                          4697  lab_set1
00002466  E291                    4698      roxr.l  #1,d1           * shift extend result >>
00002468  5240                    4699      addq.w  #1,d0           * adjust exponent
0000246A                          4700  
0000246A                          4701                      * test for over/under flow
0000246A                          4702  l_divrnd
0000246A  3600                    4703      move.w  d0,d3           * copy exponent
0000246C  6B00 0020               4704      bmi lab_div0        * if -ve return zero
00002470                          4705  
00002470  0243 FF00               4706      andi.w  #$ff00,d3       * mask low byte
00002474  6600 E34A               4707      bne lab_ofer        * branch if overflow
00002478                          4708  
00002478                          4709                      * move result into FAC1
00002478                          4710  lab_xdiv
00002478  2E1F                    4711      move.l  (sp)+,d7        * restore d7
0000247A  13C0 00040598           4712      move.b  d0,fac1_e       * save result exponent
00002480  23C1 00040594           4713      move.l  d1,fac1_m       * save result mantissa
00002486  4E75                    4714      rts
00002488                          4715  
00002488                          4716  * FAC1 mantissa = FAC2 mantissa so set result mantissa
00002488                          4717  
00002488                          4718  lab_man1
00002488  7201                    4719      moveq   #1,d1           * set bit
0000248A  E2A9                    4720      lsr.l   d1,d1           * bit into eXtend
0000248C  60D8                    4721      bra.s   lab_set1        * set mantissa, adjust exponent and exit
0000248E                          4722  
0000248E                          4723  * result is zero
0000248E                          4724  
0000248E                          4725  lab_div0
0000248E  7000                    4726      moveq   #0,d0           * zero exponent & sign
00002490  2200                    4727      move.l  d0,d1           * zero mantissa
00002492  60E4                    4728      bra lab_xdiv        * exit divide
00002494                          4729  
00002494                          4730  * divide 16 bits into 32, AB/Ex
00002494                          4731  *
00002494                          4732  * d4              AAAA  BBBB        * 32 bit numerator
00002494                          4733  * d3              EEEE  xxxx        * 16 bit denominator
00002494                          4734  *
00002494                          4735  * returns -
00002494                          4736  *
00002494                          4737  * d1              xxxx  DDDD        * 16 bit result
00002494                          4738  * d2                    HHHH  IIII  * 32 bit remainder
00002494                          4739  
00002494                          4740  lab_32_16
00002494  2404                    4741      move.l  d4,d2           * copy FAC2 mantissa          (AB)
00002496                          4742  lab_3216
00002496  2A03                    4743      move.l  d3,d5           * copy FAC1 mantissa          (EF)
00002498  4245                    4744      clr.w   d5          * clear low word d1           (Ex)
0000249A  4845                    4745      swap    d5          * swap high word to low word  (xE)
0000249C  88C5                    4746      divu    d5,d4           * do FAC2/FAC1 high word      (AB/E)
0000249E  6802                    4747      bvc.s   lab_lt_1        * if no overflow DIV was ok
000024A0                          4748  
000024A0  78FF                    4749      moveq   #-1,d4          * else set default value
000024A2                          4750  
000024A2                          4751  ; done the divide, now check the result, we have ...
000024A2                          4752  
000024A2                          4753  * d3              EEEE  FFFF        * denominator copy
000024A2                          4754  * d5        0000  EEEE          * denominator high word
000024A2                          4755  * d2              AAAA  BBBB        * numerator copy
000024A2                          4756  * d4              MMMM  DDDD        * result MOD and DIV
000024A2                          4757  
000024A2                          4758  lab_lt_1
000024A2  3C04                    4759      move.w  d4,d6           * copy 16 bit result
000024A4  3204                    4760      move.w  d4,d1           * copy 16 bit result again
000024A6                          4761  
000024A6                          4762  * we now have ..
000024A6                          4763  * d3              EEEE  FFFF        * denominator copy
000024A6                          4764  * d5        0000  EEEE          * denominator high word
000024A6                          4765  * d6              xxxx  DDDD        * result DIV copy
000024A6                          4766  * d1              xxxx  DDDD        * result DIV copy
000024A6                          4767  * d2              AAAA  BBBB        * numerator copy
000024A6                          4768  * d4              MMMM  DDDD        * result MOD and DIV
000024A6                          4769  
000024A6                          4770  * now multiply out 32 bit denominator by 16 bit result
000024A6                          4771  * QRS = AB*D
000024A6                          4772  
000024A6  CCC3                    4773      mulu    d3,d6           * FFFF * DDDD =       rrrr  SSSS
000024A8  C8C5                    4774      mulu    d5,d4           * EEEE * DDDD = QQQQ  rrrr
000024AA                          4775  
000024AA                          4776  * we now have ..
000024AA                          4777  * d3              EEEE  FFFF        * denominator copy
000024AA                          4778  * d5        0000  EEEE          * denominator high word
000024AA                          4779  * d6                    rrrr  SSSS  * 48 bit result partial low
000024AA                          4780  * d1              xxxx  DDDD        * result DIV copy
000024AA                          4781  * d2              AAAA  BBBB        * numerator copy
000024AA                          4782  * d4              QQQQ  rrrr        * 48 bit result partial
000024AA                          4783  
000024AA  3E06                    4784      move.w  d6,d7           * copy low word of low multiply
000024AC                          4785  
000024AC                          4786  * d7                    xxxx  SSSS  * 48 bit result partial low
000024AC                          4787  
000024AC  4246                    4788      clr.w   d6          * clear low word of low multiply
000024AE  4846                    4789      swap    d6          * high word of low multiply to low word
000024B0                          4790  
000024B0                          4791  * d6              0000  rrrr        * high word of 48 bit result partial low
000024B0                          4792  
000024B0  D886                    4793      add.l   d6,d4
000024B2                          4794  
000024B2                          4795  * d4              QQQQ  RRRR        * 48 bit result partial high longword
000024B2                          4796  
000024B2  7C00                    4797      moveq   #0,d6           * clear to extend numerator to 48 bits
000024B4                          4798  
000024B4                          4799  * now do GHI = AB0 - QRS (which is the remainder)
000024B4                          4800  
000024B4  9C47                    4801      sub.w   d7,d6           * low word subtract
000024B6                          4802  
000024B6                          4803  * d6                    xxxx  IIII  * remainder low word
000024B6                          4804  
000024B6  9584                    4805      subx.l  d4,d2           * high longword subtract
000024B8                          4806  
000024B8                          4807  * d2              GGGG  HHHH        * remainder high longword
000024B8                          4808  
000024B8                          4809  * now if we got the divide correct then the remainder high longword will be +ve
000024B8                          4810  
000024B8  6A08                    4811      bpl.s   l_ddiv          * branch if result is ok (<needed)
000024BA                          4812  
000024BA                          4813  * remainder was -ve so DDDD is too big
000024BA                          4814  
000024BA                          4815  lab_remm
000024BA  5341                    4816      subq.w  #1,d1           * adjust DDDD
000024BC                          4817  
000024BC                          4818  * d3                    xxxx  FFFF  * denominator copy
000024BC                          4819  * d6                    xxxx  IIII  * remainder low word
000024BC                          4820  
000024BC  DC43                    4821      add.w   d3,d6           * add EF*1 low remainder low word
000024BE                          4822  
000024BE                          4823  * d5              0000  EEEE        * denominator high word
000024BE                          4824  * d2              GGGG  HHHH        * remainder high longword
000024BE                          4825  
000024BE  D585                    4826      addx.l  d5,d2           * add extend EF*1 to remainder high longword
000024C0  6BF8                    4827      bmi.s   lab_remm        * loop if result still too big
000024C2                          4828  
000024C2                          4829  * all done and result correct or <
000024C2                          4830  
000024C2                          4831  l_ddiv
000024C2  4842                    4832      swap    d2          * remainder mid word to high word
000024C4                          4833  
000024C4                          4834  * d2              HHHH  GGGG        * (high word /should/ be $0000)
000024C4                          4835  
000024C4  3406                    4836      move.w  d6,d2           * remainder in high word
000024C6                          4837  
000024C6                          4838  * d2                    HHHH  IIII  * now is 32 bit remainder
000024C6                          4839  * d1              xxxx  DDDD        * 16 bit result
000024C6                          4840  
000024C6  4E75                    4841      rts
000024C8                          4842  
000024C8                          4843  * unpack memory (a0) into FAC1
000024C8                          4844  
000024C8                          4845  lab_ufac
000024C8  2010                    4846      move.l  (a0),d0         * get packed value
000024CA  4840                    4847      swap    d0          * exponent and sign into least significant word
000024CC  33C0 00040598           4848      move.w  d0,fac1_e       * save exponent and sign
000024D2  807C 0080               4849      or.w    #$80,d0         * set MSb
000024D6  4840                    4850      swap    d0          * byte order back to normal
000024D8                          4851  
000024D8  E180                    4852      asl.l   #8,d0           * shift exponent & clear guard byte
000024DA  23C0 00040594           4853      move.l  d0,fac1_m       * move into FAC1
000024E0                          4854  
000024E0  1039 00040598           4855      move.b  fac1_e,d0       * get FAC1 exponent
000024E6  4E75                    4856      rts
000024E8                          4857  
000024E8                          4858  * set numeric variable, pack FAC1 into Lvarpl
000024E8                          4859  
000024E8                          4860  lab_pfac
000024E8  2F08                    4861      move.l  a0,-(sp)        * save pointer
000024EA  2079 00040476           4862      movea.l lvarpl,a0       * get destination pointer
000024F0  0839 0006 000405BD      4863      btst    #6,dtypef       * test data type
000024F8  670C                    4864      beq.s   lab_277c        * branch if floating
000024FA                          4865  
000024FA  6100 00F8               4866      bsr lab_2831        * convert FAC1 floating-to-fixed
000024FE                          4867                      * result in d0 and Itemp
000024FE  2080                    4868      move.l  d0,(a0)         * save in var
00002500  205F                    4869      move.l  (sp)+,a0        * restore pointer
00002502  4E75                    4870      rts
00002504                          4871  
00002504                          4872  * normalise round and pack FAC1 into (a0)
00002504                          4873  
00002504                          4874  lab_2778
00002504  2F08                    4875      move.l  a0,-(sp)        * save pointer
00002506                          4876  lab_277c
00002506  6100 FC7A               4877      bsr lab_24d5        * normalise FAC1
0000250A  613A                    4878      bsr.s   lab_27ba        * round FAC1
0000250C  2039 00040594           4879      move.l  fac1_m,d0       * get FAC1 mantissa
00002512  E098                    4880      ror.l   #8,d0           * align 24/32 bit mantissa
00002514  4840                    4881      swap    d0          * exponent/sign into 0-15
00002516  C07C 007F               4882      and.w   #$7f,d0         * clear exponent and sign bit
0000251A  0239 0080 00040599      4883      andi.b  #$80,fac1_s     * clear non sign bits in sign
00002522  8079 00040598           4884      or.w    fac1_e,d0       * OR in exponent and sign
00002528  4840                    4885      swap    d0          * move exponent and sign  back to 16-31
0000252A  2080                    4886      move.l  d0,(a0)         * store in destination
0000252C  205F                    4887      move.l  (sp)+,a0        * restore pointer
0000252E  4E75                    4888      rts
00002530                          4889  
00002530                          4890  * copy FAC2 to FAC1
00002530                          4891  
00002530                          4892  lab_279b
00002530  33F9 000405A0 00040598  4893      move.w  fac2_e,fac1_e       * copy exponent & sign
0000253A  23F9 0004059C 00040594  4894      move.l  fac2_m,fac1_m       * copy mantissa
00002544  4E75                    4895      rts
00002546                          4896  
00002546                          4897  * round FAC1
00002546                          4898  
00002546                          4899  lab_27ba
00002546  1039 00040598           4900      move.b  fac1_e,d0       * get FAC1 exponent
0000254C  6726                    4901      beq.s   lab_27c4        * branch if zero
0000254E                          4902  
0000254E  2039 00040594           4903      move.l  fac1_m,d0       * get FAC1
00002554  0680 00000080           4904      add.l   #$80,d0         * round to 24 bit
0000255A  640C                    4905      bcc.s   lab_27c3        * branch if no overflow
0000255C                          4906  
0000255C  E290                    4907      roxr.l  #1,d0           * shift FAC1 mantissa
0000255E  5239 00040598           4908      addq.b  #1,fac1_e       * correct exponent
00002564  6500 E25A               4909      bcs lab_ofer        * if carry do overflow error & warm start
00002568                          4910  
00002568                          4911  lab_27c3
00002568  C03C 0000               4912      and.b   #$00,d0         * clear guard byte
0000256C  23C0 00040594           4913      move.l  d0,fac1_m       * save back to FAC1
00002572  4E75                    4914      rts
00002574                          4915  
00002574                          4916  lab_27c4
00002574  13C0 00040599           4917      move.b  d0,fac1_s       * make zero always +ve
0000257A                          4918  rts_017
0000257A  4E75                    4919      rts
0000257C                          4920  
0000257C                          4921  * get FAC1 sign
0000257C                          4922  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
0000257C                          4923  
0000257C                          4924  lab_27ca
0000257C  7000                    4925      moveq   #0,d0           * clear d0
0000257E  1039 00040598           4926      move.b  fac1_e,d0       * get FAC1 exponent
00002584  67F4                    4927      beq.s   rts_017         * exit if zero (already correct SGN(0)=0)
00002586                          4928  
00002586                          4929  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00002586                          4930  * no = 0 check
00002586                          4931  
00002586                          4932  lab_27ce
00002586  1039 00040599           4933      move.b  fac1_s,d0       * else get FAC1 sign (b7)
0000258C                          4934  
0000258C                          4935  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
0000258C                          4936  * no = 0 check, sign in d0
0000258C                          4937  
0000258C                          4938  lab_27d0
0000258C  4880                    4939      ext.w   d0          * make word
0000258E  48C0                    4940      ext.l   d0          * make longword
00002590  E080                    4941      asr.l   #8,d0           * move sign bit through byte to carry
00002592  65E6                    4942      bcs.s   rts_017         * exit if carry set
00002594                          4943  
00002594  7001                    4944      moveq   #1,d0           * set result for +ve sign
00002596  4E75                    4945      rts
00002598                          4946  
00002598                          4947  * perform SGN()
00002598                          4948  
00002598                          4949  lab_sgn
00002598  61E2                    4950      bsr.s   lab_27ca        * get FAC1 sign
0000259A                          4951                      * return d0=-1/-ve d0=+1/+ve
0000259A                          4952  
0000259A                          4953  * save d0 as integer longword
0000259A                          4954  
0000259A                          4955  lab_27db
0000259A  23C0 00040594           4956      move.l  d0,fac1_m       * save FAC1 mantissa
000025A0  33FC A000 00040598      4957      move.w  #$a000,fac1_e       * set FAC1 exponent & sign
000025A8  D080                    4958      add.l   d0,d0           * top bit into carry
000025AA  6000 FBC6               4959      bra lab_24d0        * do +/- (carry is sign) & normalise FAC1
000025AE                          4960  
000025AE                          4961  * perform ABS()
000025AE                          4962  
000025AE                          4963  lab_abs
000025AE  13FC 0000 00040599      4964      move.b  #0,fac1_s       * clear FAC1 sign
000025B6  4E75                    4965      rts
000025B8                          4966  
000025B8                          4967  * compare FAC1 with (a0)
000025B8                          4968  * returns d0=+1 if FAC1 > FAC2
000025B8                          4969  * returns d0= 0 if FAC1 = FAC2
000025B8                          4970  * returns d0=-1 if FAC1 < FAC2
000025B8                          4971  
000025B8                          4972  lab_27f8
000025B8  6100 FDD6               4973      bsr lab_264d        * unpack memory (a0) into FAC2, trashes d0
000025BC                          4974  
000025BC                          4975  * compare FAC1 with FAC2
000025BC                          4976  * returns d0=+1 if FAC1 > FAC2
000025BC                          4977  * returns d0= 0 if FAC1 = FAC2
000025BC                          4978  * returns d0=-1 if FAC1 < FAC2
000025BC                          4979  
000025BC                          4980  lab_27fa
000025BC  1239 000405A0           4981      move.b  fac2_e,d1       * get FAC2 exponent
000025C2  67B8                    4982      beq.s   lab_27ca        * branch if FAC2 exponent=0 & get FAC1 sign
000025C4                          4983                      * d0=-1,C=1/-ve d0=+1,C=0/+ve
000025C4                          4984  
000025C4  1039 000405A2           4985      move.b  fac_sc,d0       * get FAC sign compare
000025CA  6BBA                    4986      bmi.s   lab_27ce        * if signs <> do return d0=-1,C=1/-ve
000025CC                          4987                      * d0=+1,C=0/+ve & return
000025CC                          4988  
000025CC  1039 00040599           4989      move.b  fac1_s,d0       * get FAC1 sign
000025D2  B239 00040598           4990      cmp.b   fac1_e,d1       * compare FAC1 exponent with FAC2 exponent
000025D8  660E                    4991      bne.s   lab_2828        * branch if different
000025DA                          4992  
000025DA  2239 0004059C           4993      move.l  fac2_m,d1       * get FAC2 mantissa
000025E0  B2B9 00040594           4994      cmp.l   fac1_m,d1       * compare mantissas
000025E6  6708                    4995      beq.s   lab_282f        * exit if mantissas equal
000025E8                          4996  
000025E8                          4997  * gets here if number <> FAC1
000025E8                          4998  
000025E8                          4999  lab_2828
000025E8  6504                    5000      bcs.s   lab_282e        * branch if FAC1 > FAC2
000025EA                          5001  
000025EA  0A00 0080               5002      eori.b  #$80,d0         * else toggle FAC1 sign
000025EE                          5003  lab_282e
000025EE  609C                    5004      bra.s   lab_27d0        * return d0=-1,C=1/-ve d0=+1,C=0/+ve
000025F0                          5005  
000025F0                          5006  lab_282f
000025F0  7000                    5007      moveq   #0,d0           * clear result
000025F2                          5008  rts_018
000025F2  4E75                    5009      rts
000025F4                          5010  
000025F4                          5011  * convert FAC1 floating-to-fixed
000025F4                          5012  * result in d0 and Itemp
000025F4                          5013  
000025F4                          5014  lab_2831
000025F4  2F01                    5015      move.l  d1,-(sp)        * save d1
000025F6  2039 00040594           5016      move.l  fac1_m,d0       * copy mantissa
000025FC  1239 00040598           5017      move.b  fac1_e,d1       * get FAC1 exponent
00002602  B23C 0081               5018      cmp.b   #$81,d1         * compare with min
00002606  6532                    5019      bcs.s   lab_287f        * if <1 go clear FAC1 & return
00002608                          5020  
00002608  0401 00A0               5021      sub.b   #$a0,d1         * compare maximum integer range exponent
0000260C  6610                    5022      bne.s   lab_2844        * if not $A0, go test is less
0000260E                          5023  
0000260E  4A39 00040599           5024      tst.b   fac1_s          * test FAC1 sign
00002614  6A0C                    5025      bpl.s   lab_2845        * branch if FAC1 +ve
00002616                          5026  
00002616                          5027                      * FAC1 was -ve and exponent is $A0
00002616  B0BC 80000000           5028      cmp.l   #$80000000,d0       * compare with max -ve
0000261C  6704                    5029      beq.s   lab_2845        * branch if max -ve
0000261E                          5030  
0000261E                          5031  lab_2844
0000261E  6400 E1A0               5032      bcc lab_ofer        * do overflow if too big
00002622                          5033  
00002622                          5034  lab_2845
00002622  4401                    5035      neg.b   d1          * convert -ve to +ve
00002624  E2A8                    5036      lsr.l   d1,d0           * shift integer
00002626                          5037  
00002626  4A39 00040599           5038      tst.b   fac1_s          * test FAC1 sign (b7)
0000262C  6A02                    5039      bpl.s   lab_2846        * branch if FAC1 +ve
0000262E                          5040  
0000262E  4480                    5041      neg.l   d0          * negate integer value
00002630                          5042  lab_2846
00002630  23C0 0004042E           5043      move.l  d0,itemp
00002636  221F                    5044      move.l  (sp)+,d1        * restore d1
00002638  4E75                    5045      rts
0000263A                          5046                      * set zero result
0000263A                          5047  lab_287f
0000263A  7000                    5048      moveq   #0,d0           * clear result
0000263C  60F2                    5049      bra.s   lab_2846        * go save & exit
0000263E                          5050  
0000263E                          5051  * perform INT()
0000263E                          5052  
0000263E                          5053  lab_int
0000263E  0C39 00A0 00040598      5054      cmp.b   #$a0,fac1_e     * compare FAC1 exponent with max int
00002646  64AA                    5055      bcc.s   rts_018         * exit if >= (too big for fractional part!)
00002648                          5056  
00002648  363C A000               5057      move.w  #$a000,d3       * set exponent for result
0000264C  1639 00040599           5058      move.b  fac1_s,d3       * get FAC1 sign
00002652  13FC 0000 00040599      5059      move.b  #0,fac1_s       * make +ve
0000265A  6198                    5060      bsr.s   lab_2831        * convert FAC1 floating-to-fixed
0000265C                          5061                      * result in d0 and Itemp
0000265C  33C3 00040598           5062      move.w  d3,fac1_e       * set sign and exponent
00002662  23C0 00040594           5063      move.l  d0,fac1_m       * set mantissa
00002668  6000 FB18               5064      bra lab_24d5        * normalise FAC1 & return
0000266C                          5065  
0000266C                          5066  * print " in line [LINE #]"
0000266C                          5067  
0000266C                          5068  lab_2953
0000266C  41FA 1665               5069      lea (lab_lmsg,pc),a0    * point to " in line " message
00002670  6100 EA12               5070      bsr lab_18c3        * print null terminated string
00002674                          5071  
00002674                          5072                      * Print Basic line #
00002674  2039 00040456           5073      move.l  clinel,d0       * get current line
0000267A                          5074  
0000267A                          5075  * print d0 as unsigned integer
0000267A                          5076  
0000267A                          5077  lab_295e
0000267A  6104                    5078      bsr.s   lab_2966        * convert 32 bit d0 to unsigned string (a0)
0000267C  6000 EA06               5079      bra lab_18c3        * print null terminated string from memory & RET
00002680                          5080  
00002680                          5081  * convert d0 to unsigned ASCII string result in (a0)
00002680                          5082  
00002680                          5083  lab_2966
00002680  227C 0000328E           5084      movea.l #bin2dec,a1     * get table address
00002686  7200                    5085      moveq   #0,d1           * table index
00002688  207C 000405D4           5086      movea.l #usdss,a0       * output string start
0000268E  2401                    5087      move.l  d1,d2           * output string index
00002690                          5088  lab_2967
00002690  2631 1000               5089      move.l  (a1,d1.w),d3        * get table value
00002694  6714                    5090      beq.s   lab_2969        * exit if end marker
00002696                          5091  
00002696  782F                    5092      moveq   #'0'-1,d4       * set character to "0"-1
00002698                          5093  lab_2968
00002698  5244                    5094      addq.w  #1,d4           * next numeric character
0000269A  9083                    5095      sub.l   d3,d0           * subtract table value
0000269C  6AFA                    5096      bpl.s   lab_2968        * not overdone so loop
0000269E                          5097  
0000269E  D083                    5098      add.l   d3,d0           * correct value
000026A0  1184 2000               5099      move.b  d4,(a0,d2.w)        * character out to string
000026A4  5841                    5100      addq.w  #4,d1           * increment table pointer
000026A6  5242                    5101      addq.w  #1,d2           * increment output string pointer
000026A8  60E6                    5102      bra.s   lab_2967        * loop
000026AA                          5103  
000026AA                          5104  lab_2969
000026AA  0600 0030               5105      add.b   #'0',d0         * make last character
000026AE  1180 2000               5106      move.b  d0,(a0,d2.w)        * character out to string
000026B2  5348                    5107      subq.w  #1,a0           * decrement a0 (allow simple loop)
000026B4                          5108  
000026B4                          5109                      * now find non zero start of string
000026B4                          5110  lab_296a
000026B4  5248                    5111      addq.w  #1,a0           * increment a0 (we know this will never carry to b16)
000026B6  B1FC 000405DD           5112      cmpa.l  #(bhsend-1),a0      * are we at end
000026BC  6706                    5113      beq.s   rts_019         * branch if so
000026BE                          5114  
000026BE  0C10 0030               5115      cmpi.b  #'0',(a0)       * is character "0" ?
000026C2  67F0                    5116      beq.s   lab_296a        * loop if so
000026C4                          5117  
000026C4                          5118  rts_019
000026C4  4E75                    5119      rts
000026C6                          5120  
000026C6                          5121  **lab_xxxx  ##
000026C6                          5122  **  bsr.s   lab_2831        * convert FAC1 floating-to-fixed
000026C6                          5123                      * result in d0 and Itemp
000026C6                          5124  ** now check not 0 and go print it ...
000026C6                          5125  
000026C6                          5126  * convert FAC1 to ASCII string result in (a0)
000026C6                          5127  * STR$() function enters here
000026C6                          5128  
000026C6                          5129  * d0 is character out
000026C6                          5130  * d1 is save index
000026C6                          5131  * d2 is gash
000026C6                          5132  
000026C6                          5133  * a0 is output pointer
000026C6                          5134  
000026C6                          5135  lab_2970
000026C6  6100 FE7E               5136      bsr lab_27ba        * round FAC1
000026CA  227C 000405CE           5137      movea.l #decss,a1       * set output string start
000026D0                          5138  
000026D0                          5139  ** insert code here to test the numeric type and do integer if needed ##
000026D0                          5140  **  btst    #6,d0           * test the integer bit
000026D0                          5141  **  bne.s   lab_xxxx        * branch if integer
000026D0                          5142  
000026D0  12BC 0020               5143      move.b  #' ',(a1)       * character = " " (assume +ve)
000026D4  08B9 0007 00040599      5144      bclr.b  #7,fac1_s       * test and clear FAC1 sign (b7)
000026DC  6704                    5145      beq.s   lab_2978        * branch if +ve
000026DE                          5146  
000026DE  12BC 002D               5147      move.b  #$2d,(a1)       * else character = "-"
000026E2                          5148  lab_2978
000026E2  1439 00040598           5149      move.b  fac1_e,d2       * get FAC1 exponent
000026E8  6608                    5150      bne.s   lab_2989        * branch if FAC1<>0
000026EA                          5151  
000026EA                          5152                      * exponent was $00 so FAC1 is 0
000026EA  7030                    5153      moveq   #'0',d0         * set character = "0"
000026EC  7201                    5154      moveq   #1,d1           * set output string index
000026EE  6000 0194               5155      bra lab_2a89        * save last character, [EOT] & exit
000026F2                          5156  
000026F2                          5157                      * FAC1 is some non zero value
000026F2                          5158  lab_2989
000026F2  13FC 0000 000405B4      5159      move.b  #0,numexp       * clear number exponent count
000026FA  B43C 0081               5160      cmp.b   #$81,d2         * compare FAC1 exponent with $81 (>1.00000)
000026FE                          5161  
000026FE  6428                    5162      bcc.s   lab_299c        * branch if FAC1=>1
00002700                          5163  
00002700  23FC F4240000 0004059C  5164      move.l  #$f4240000,fac2_m   * 1000000 mantissa
0000270A  33FC 9400 000405A0      5165      move.w  #$9400,fac2_e       * 1000000 exponent & sign
00002712  13F9 00040599 000405A2  5166      move.b  fac1_s,fac_sc       * make FAC1 sign sign compare
0000271C  6100 FBC8               5167      bsr lab_multiply        * do FAC2*FAC1
00002720                          5168  
00002720  13FC 00FA 000405B4      5169      move.b  #$fa,numexp     * set number exponent count (-6)
00002728                          5170  lab_299c
00002728  41FA 1064               5171      lea (lab_294b,pc),a0    * set pointer to 999999.4375
0000272C                          5172                      * (max before scientific notation)
0000272C  6100 FE8A               5173      bsr lab_27f8        * compare FAC1 with (a0)
00002730                          5174                      * returns d0=+1 if FAC1 > FAC2
00002730                          5175                      * returns d0= 0 if FAC1 = FAC2
00002730                          5176                      * returns d0=-1 if FAC1 < FAC2
00002730  675A                    5177      beq.s   lab_29c3        * exit if FAC1 = (a0)
00002732                          5178  
00002732  6A18                    5179      bpl.s   lab_29b9        * go do /10 if FAC1 > (a0)
00002734                          5180  
00002734                          5181                      * FAC1 < (a0)
00002734                          5182  lab_29a7
00002734  41FA 1054               5183      lea (lab_2947,pc),a0    * set pointer to 99999.9375
00002738  6100 FE7E               5184      bsr lab_27f8        * compare FAC1 with (a0)
0000273C                          5185                      * returns d0=+1 if FAC1 > FAC2
0000273C                          5186                      * returns d0= 0 if FAC1 = FAC2
0000273C                          5187                      * returns d0=-1 if FAC1 < FAC2
0000273C  6702                    5188      beq.s   lab_29b2        * branch if FAC1 = (a0) (allow decimal places)
0000273E                          5189  
0000273E  6A48                    5190      bpl.s   lab_29c0        * branch if FAC1 > (a0) (no decimal places)
00002740                          5191  
00002740                          5192                      * FAC1 <= (a0)
00002740                          5193  lab_29b2
00002740  6100 FC7A               5194      bsr lab_269e        * multiply FAC1 by 10
00002744  5339 000405B4           5195      subq.b  #1,numexp       * decrement number exponent count
0000274A  60E8                    5196      bra.s   lab_29a7        * go test again
0000274C                          5197  
0000274C                          5198  lab_29b9
0000274C  33F9 00040598 000405A0  5199      move.w  fac1_e,fac2_e       * copy exponent & sign from FAC1 to FAC2
00002756  23F9 00040594 0004059C  5200      move.l  fac1_m,fac2_m       * copy FAC1 mantissa to FAC2 mantissa
00002760  13F9 00040599 000405A2  5201      move.b  fac1_s,fac_sc       * save FAC1_s as sign compare
0000276A                          5202  
0000276A  23FC CCCCCCCD 00040594  5203      move.l  #$cccccccd,fac1_m   * 1/10 mantissa
00002774  33FC 7D00 00040598      5204      move.w  #$7d00,fac1_e       * 1/10 exponent & sign
0000277C  6100 FB68               5205      bsr lab_multiply        * do FAC2*FAC1, effectively divide by 10 but faster
00002780                          5206  
00002780  5239 000405B4           5207      addq.b  #1,numexp       * increment number exponent count
00002786  60A0                    5208      bra.s   lab_299c        * go test again (branch always)
00002788                          5209  
00002788                          5210                      * now we have just the digits to do
00002788                          5211  lab_29c0
00002788  6100 F954               5212      bsr lab_244e        * add 0.5 to FAC1 (round FAC1)
0000278C                          5213  lab_29c3
0000278C  6100 FE66               5214      bsr lab_2831        * convert FAC1 floating-to-fixed
00002790                          5215                      * result in d0 and Itemp
00002790  7401                    5216      moveq   #$01,d2         * set default digits before dp = 1
00002792  1039 000405B4           5217      move.b  numexp,d0       * get number exponent count
00002798  5E00                    5218      add.b   #7,d0           * allow 6 digits before point
0000279A  6B0C                    5219      bmi.s   lab_29d9        * if -ve then 1 digit before dp
0000279C                          5220  
0000279C  B03C 0008               5221      cmp.b   #$08,d0         * d0>=8 if n>=1E6
000027A0  6406                    5222      bcc.s   lab_29d9        * branch if >= $08
000027A2                          5223  
000027A2                          5224                      * < $08
000027A2  5300                    5225      subq.b  #1,d0           * take 1 from digit count
000027A4  1400                    5226      move.b  d0,d2           * copy byte
000027A6  7002                    5227      moveq   #$02,d0         * set exponent adjust
000027A8                          5228  lab_29d9
000027A8  7200                    5229      moveq   #0,d1           * set output string index
000027AA  5500                    5230      subq.b  #2,d0           * -2
000027AC  13C0 000405B5           5231      move.b  d0,expcnt       * save exponent adjust
000027B2  13C2 000405B4           5232      move.b  d2,numexp       * save digits before dp count
000027B8  1002                    5233      move.b  d2,d0           * copy digits before dp count
000027BA  6702                    5234      beq.s   lab_29e4        * branch if no digits before dp
000027BC                          5235  
000027BC  6A14                    5236      bpl.s   lab_29f7        * branch if digits before dp
000027BE                          5237  
000027BE                          5238  lab_29e4
000027BE  5281                    5239      addq.l  #1,d1           * increment index
000027C0  13BC 002E 1000          5240      move.b  #'.',(a1,d1.w)      * save to output string
000027C6                          5241  
000027C6  4A02                    5242      tst.b   d2          * test digits before dp count
000027C8  6708                    5243      beq.s   lab_29f7        * branch if no digits before dp
000027CA                          5244  
000027CA  5281                    5245      addq.l  #1,d1           * increment index
000027CC  13BC 0030 1000          5246      move.b  #'0',(a1,d1.w)      * save to output string
000027D2                          5247  lab_29f7
000027D2  7400                    5248      moveq   #0,d2           * clear index (point to 100,000)
000027D4  7080                    5249      moveq   #$80-$100,d0        * set output character
000027D6                          5250  lab_29fb
000027D6  41FA 0FC2               5251      lea (lab_2a9a,pc),a0    * get base of table
000027DA  2630 2000               5252      move.l  (a0,d2.w),d3        * get table value
000027DE                          5253  lab_29fd
000027DE  5200                    5254      addq.b  #1,d0           * increment output character
000027E0  D7B9 0004042E           5255      add.l   d3,itemp        * add to (now fixed) mantissa
000027E6  0800 0007               5256      btst    #7,d0           * set test sense (z flag only)
000027EA  6504                    5257      bcs.s   lab_2a18        * did carry so has wrapped past zero
000027EC                          5258  
000027EC  67F0                    5259      beq.s   lab_29fd        * no wrap and +ve test so try again
000027EE                          5260  
000027EE  6002                    5261      bra.s   lab_2a1a        * found this digit
000027F0                          5262  
000027F0                          5263  lab_2a18
000027F0  66EC                    5264      bne.s   lab_29fd        * wrap and -ve test so try again
000027F2                          5265  
000027F2                          5266  lab_2a1a
000027F2  6406                    5267      bcc.s   lab_2a21        * branch if +ve test result
000027F4                          5268  
000027F4  4400                    5269      neg.b   d0          * negate number
000027F6  0600 000B               5270      add.b   #$0b,d0         * and effectively subtract from 11d
000027FA                          5271  lab_2a21
000027FA  0600 002F               5272      add.b   #$2f,d0         * add "0"-1 to result
000027FE  5842                    5273      addq.w  #4,d2           * increment index to next less power of ten
00002800  5241                    5274      addq.w  #1,d1           * increment output string index
00002802  1600                    5275      move.b  d0,d3           * copy character to d3
00002804  C63C 007F               5276      and.b   #$7f,d3         * mask out top bit
00002808  1383 1000               5277      move.b  d3,(a1,d1.w)        * save to output string
0000280C  5339 000405B4           5278      sub.b   #1,numexp       * decrement # of characters before the dp
00002812  6608                    5279      bne.s   lab_2a3b        * branch if still characters to do
00002814                          5280  
00002814                          5281                      * else output the point
00002814  5281                    5282      addq.l  #1,d1           * increment index
00002816  13BC 002E 1000          5283      move.b  #'.',(a1,d1.w)      * save to output string
0000281C                          5284  lab_2a3b
0000281C  C03C 0080               5285      and.b   #$80,d0         * mask test sense bit
00002820  0A00 0080               5286      eori.b  #$80,d0         * invert it
00002824  B43C 0018               5287      cmp.b   #$18,d2         * compare table index with max+4
00002828  66AC                    5288      bne.s   lab_29fb        * loop if not max
0000282A                          5289  
0000282A                          5290                      * now remove trailing zeroes
0000282A                          5291  lab_2a4b
0000282A  1031 1000               5292      move.b  (a1,d1.w),d0        * get character from output string
0000282E  5381                    5293      subq.l  #1,d1           * decrement output string index
00002830  B03C 0030               5294      cmp.b   #'0',d0         * compare with "0"
00002834  67F4                    5295      beq.s   lab_2a4b        * loop until non "0" character found
00002836                          5296  
00002836  B03C 002E               5297      cmp.b   #'.',d0         * compare with "."
0000283A  6702                    5298      beq.s   lab_2a58        * branch if was dp
0000283C                          5299  
0000283C                          5300                      * else restore last character
0000283C  5281                    5301      addq.l  #1,d1           * increment output string index
0000283E                          5302  lab_2a58
0000283E  13BC 002B 1002          5303      move.b  #'+',2(a1,d1.w)     * save character "+" to output string
00002844  4A39 000405B5           5304      tst.b   expcnt          * test exponent count
0000284A  673C                    5305      beq.s   lab_2a8c        * if zero go set null terminator & exit
0000284C                          5306  
0000284C                          5307                      * exponent isn't zero so write exponent
0000284C  6A0C                    5308      bpl.s   lab_2a68        * branch if exponent count +ve
0000284E                          5309  
0000284E  13BC 002D 1002          5310      move.b  #'-',2(a1,d1.w)     * save character "-" to output string
00002854  4439 000405B5           5311      neg.b   expcnt          * convert -ve to +ve
0000285A                          5312  lab_2a68
0000285A  13BC 0045 1001          5313      move.b  #'E',1(a1,d1.w)     * save character "E" to output string
00002860  1439 000405B5           5314      move.b  expcnt,d2       * get exponent count
00002866  702F                    5315      moveq   #$2f,d0         * one less than "0" character
00002868                          5316  lab_2a74
00002868  5200                    5317      addq.b  #1,d0           * increment 10's character
0000286A  0402 000A               5318      sub.b   #$0a,d2         * subtract 10 from exponent count
0000286E  64F8                    5319      bcc.s   lab_2a74        * loop while still >= 0
00002870                          5320  
00002870  0602 003A               5321      add.b   #$3a,d2         * add character ":" ($30+$0A, result is 10-value)
00002874  1380 1003               5322      move.b  d0,3(a1,d1.w)       * save 10's character to output string
00002878  1382 1004               5323      move.b  d2,4(a1,d1.w)       * save 1's character to output string
0000287C  13BC 0000 1005          5324      move.b  #0,5(a1,d1.w)       * save null terminator after last character
00002882  600A                    5325      bra.s   lab_2a91        * go set string pointer (a0) and exit
00002884                          5326  
00002884                          5327  lab_2a89
00002884  1380 1000               5328      move.b  d0,(a1,d1.w)        * save last character to output string
00002888                          5329  lab_2a8c
00002888  13BC 0000 1001          5330      move.b  #0,1(a1,d1.w)       * save null terminator after last character
0000288E                          5331  lab_2a91
0000288E  2049                    5332      movea.l a1,a0           * set result string pointer (a0)
00002890  4E75                    5333      rts
00002892                          5334  
00002892                          5335  lab_poon
00002892  23FC 80000000 00040594  5336      move.l  #$80000000,fac1_m   * 1 mantissa
0000289C  33FC 8100 00040598      5337      move.w  #$8100,fac1_e       * 1 exonent & sign
000028A4  4E75                    5338      rts
000028A6                          5339  
000028A6                          5340  lab_poze
000028A6  7000                    5341      moveq   #0,d0           * clear longword
000028A8  23C0 00040594           5342      move.l  d0,fac1_m       * 0 mantissa
000028AE  33C0 00040598           5343      move.w  d0,fac1_e       * 0 exonent & sign
000028B4  4E75                    5344      rts
000028B6                          5345  
000028B6                          5346  * Perform power function
000028B6                          5347  * The number is in FAC2, the power is in FAC1
000028B6                          5348  * no longer trashes Itemp
000028B6                          5349  
000028B6                          5350  lab_power
000028B6  4A39 00040598           5351      tst.b   fac1_e          * test power
000028BC  67D4                    5352      beq.s   lab_poon        * if zero go return 1
000028BE                          5353  
000028BE  4A39 000405A0           5354      tst.b   fac2_e          * test number
000028C4  67E0                    5355      beq.s   lab_poze        * if zero go return 0
000028C6                          5356  
000028C6  1F39 000405A1           5357      move.b  fac2_s,-(sp)        * save number sign
000028CC  6A26                    5358      bpl.s   lab_powp        * power of positive number
000028CE                          5359  
000028CE  7200                    5360      moveq   #0,d1           * clear d1
000028D0  13C1 000405A1           5361      move.b  d1,fac2_s       * make sign +ve
000028D6                          5362  
000028D6                          5363                      * number sign was -ve, must have integer power
000028D6                          5364                      * or do 'function call' error
000028D6  1239 00040598           5365      move.b  fac1_e,d1       * get power exponent
000028DC  0441 0080               5366      sub.w   #$80,d1         * normalise to .5
000028E0  6300 DEE2               5367      bls lab_fcer        * if 0<power<1 then do 'function call' error
000028E4                          5368  
000028E4                          5369                      * now shift all the integer bits out
000028E4  2039 00040594           5370      move.l  fac1_m,d0       * get power mantissa
000028EA  E3A0                    5371      asl.l   d1,d0           * shift mantissa
000028EC  6600 DED6               5372      bne lab_fcer        * if power<>INT(power) then do 'function call' error
000028F0                          5373  
000028F0  6502                    5374      bcs.s   lab_powp        * if integer value odd then leave result -ve
000028F2                          5375  
000028F2  1E80                    5376      move.b  d0,(sp)         * save result sign +ve
000028F4                          5377  lab_powp
000028F4  2F39 00040594           5378      move.l  fac1_m,-(sp)        * save power mantissa
000028FA  3F39 00040598           5379      move.w  fac1_e,-(sp)        * save power sign & exponent
00002900                          5380  
00002900  6100 FC2E               5381      bsr lab_279b        * copy number to FAC1
00002904  6100 F8BC               5382      bsr lab_log         * find log of number
00002908                          5383  
00002908  301F                    5384      move.w  (sp)+,d0        * get power sign & exponent
0000290A  23DF 0004059C           5385      move.l  (sp)+,fac2_m        * get power mantissa
00002910  33C0 000405A0           5386      move.w  d0,fac2_e       * save sign & exponent to FAC2
00002916  13C0 000405A2           5387      move.b  d0,fac_sc       * save sign as sign compare
0000291C  1039 00040599           5388      move.b  fac1_s,d0       * get FAC1 sign
00002922  B139 000405A2           5389      eor.b   d0,fac_sc       * make sign compare (FAC1_s EOR FAC2_s)
00002928                          5390  
00002928  6100 F9BC               5391      bsr lab_multiply        * multiply by power
0000292C  616E                    5392      bsr.s   lab_exp         * find exponential
0000292E  13DF 00040599           5393      move.b  (sp)+,fac1_s        * restore number sign
00002934  4E75                    5394      rts
00002936                          5395  
00002936                          5396  * Ffp ABS/NEG - make absolute or -ve equivalent of FAC1
00002936                          5397  
00002936  4A39 00040599           5398      tst.b   fac1_s          * test sign byte
0000293C  6710                    5399      beq.s   rts_020         * exit if +ve
0000293E                          5400  
0000293E                          5401  * do - FAC1
0000293E                          5402  
0000293E                          5403  lab_gthan
0000293E  4A39 00040598           5404      tst.b   fac1_e          * test for non zero FAC1
00002944  6708                    5405      beq.s   rts_020         * branch if null
00002946                          5406  
00002946  0A39 0080 00040599      5407      eori.b  #$80,fac1_s     * (else) toggle FAC1 sign bit
0000294E                          5408  rts_020
0000294E  4E75                    5409      rts
00002950                          5410  
00002950                          5411                      * return +1
00002950                          5412  lab_ex1
00002950  23FC 80000000 00040594  5413      move.l  #$80000000,fac1_m   * +1 mantissa
0000295A  33FC 8100 00040598      5414      move.w  #$8100,fac1_e       * +1 sign & exponent
00002962  4E75                    5415      rts
00002964                          5416                      * do over/under flow
00002964                          5417  lab_exou
00002964  4A39 00040599           5418      tst.b   fac1_s          * test sign
0000296A  6A00 DE54               5419      bpl lab_ofer        * was +ve so do overflow error
0000296E                          5420  
0000296E                          5421                      * else underflow so return zero
0000296E  7000                    5422      moveq   #0,d0           * clear longword
00002970  23C0 00040594           5423      move.l  d0,fac1_m       * 0 mantissa
00002976  33C0 00040598           5424      move.w  d0,fac1_e       * 0 sign & exponent
0000297C  4E75                    5425      rts
0000297E                          5426                      * fraction was zero so do 2^n
0000297E                          5427  lab_exof
0000297E  23FC 80000000 00040594  5428      move.l  #$80000000,fac1_m   * +n mantissa
00002988  13FC 0000 00040599      5429      move.b  #0,fac1_s       * clear sign
00002990  0601 0080               5430      add.b   #$80,d1         * adjust exponent
00002994  13C1 00040598           5431      move.b  d1,fac1_e       * save exponent
0000299A  4E75                    5432      rts
0000299C                          5433  
0000299C                          5434  * perform EXP()   (x^e)
0000299C                          5435  * valid input range is -88 to +88
0000299C                          5436  
0000299C                          5437  lab_exp
0000299C  1039 00040598           5438      move.b  fac1_e,d0       * get exponent
000029A2  67AC                    5439      beq.s   lab_ex1         * return 1 for zero in
000029A4                          5440  
000029A4  B03C 0064               5441      cmp.b   #$64,d0         * compare exponent with min
000029A8  65A6                    5442      bcs.s   lab_ex1         * if smaller just return 1
000029AA                          5443  
000029AA                          5444  **  movem.l d1-d6/a0,-(sp)      * save the registers
000029AA  13FC 0000 000405BC      5445      move.b  #0,cosout       * flag +ve number
000029B2  2239 00040594           5446      move.l  fac1_m,d1       * get mantissa
000029B8  B03C 0087               5447      cmp.b   #$87,d0         * compare exponent with max
000029BC  62A6                    5448      bhi.s   lab_exou        * go do over/under flow if greater
000029BE                          5449  
000029BE  6608                    5450      bne.s   lab_excm        * branch if less
000029C0                          5451  
000029C0                          5452                      * else is 2^7
000029C0  B2BC B00F33C7           5453      cmp.l   #$b00f33c7,d1       * compare mantissa with n*2^7 max
000029C6  649C                    5454      bcc.s   lab_exou        * if => go over/underflow
000029C8                          5455  
000029C8                          5456  lab_excm
000029C8  4A39 00040599           5457      tst.b   fac1_s          * test sign
000029CE  6A10                    5458      bpl.s   lab_exps        * branch if arg +ve
000029D0                          5459  
000029D0  13FC 00FF 000405BC      5460      move.b  #$ff,cosout     * flag +ve number
000029D8  13FC 0000 00040599      5461      move.b  #0,fac1_s       * take absolute value
000029E0                          5462  lab_exps
000029E0                          5463                      * now do n/LOG(2)
000029E0  23FC B8AA3B29 0004059C  5464      move.l  #$b8aa3b29,fac2_m   * 1/LOG(2) mantissa
000029EA  33FC 8100 000405A0      5465      move.w  #$8100,fac2_e       * 1/LOG(2) exponent & sign
000029F2  13FC 0000 000405A2      5466      move.b  #0,fac_sc       * we know they're both +ve
000029FA  6100 F8EA               5467      bsr lab_multiply        * effectively divide by log(2)
000029FE                          5468  
000029FE                          5469                      * max here is +/- 127
000029FE                          5470                      * now separate integer and fraction
000029FE  13FC 0000 000405E1      5471      move.b  #0,tpower       * clear exponent add byte
00002A06  1A39 00040598           5472      move.b  fac1_e,d5       * get exponent
00002A0C  0405 0080               5473      sub.b   #$80,d5         * normalise
00002A10  632C                    5474      bls.s   lab_esml        * branch if < 1 (d5 is 0 or -ve)
00002A12                          5475  
00002A12                          5476                      * result is > 1
00002A12  2039 00040594           5477      move.l  fac1_m,d0       * get mantissa
00002A18  2200                    5478      move.l  d0,d1           * copy it
00002A1A  2C05                    5479      move.l  d5,d6           * copy normalised exponent
00002A1C                          5480  
00002A1C  4446                    5481      neg.w   d6          * make -ve
00002A1E  0646 0020               5482      add.w   #32,d6          * is now 32-d6
00002A22  ECA9                    5483      lsr.l   d6,d1           * just integer bits
00002A24  13C1 000405E1           5484      move.b  d1,tpower       * set exponent add byte
00002A2A                          5485  
00002A2A  EBA8                    5486      lsl.l   d5,d0           * shift out integer bits
00002A2C  6700 FF50               5487      beq lab_exof        * fraction is zero so do 2^n
00002A30                          5488  
00002A30  23C0 00040594           5489      move.l  d0,fac1_m       * fraction to FAC1
00002A36  33FC 8000 00040598      5490      move.w  #$8000,fac1_e       * set exponent & sign
00002A3E                          5491  
00002A3E                          5492                      * multiple was < 1
00002A3E                          5493  lab_esml
00002A3E  23FC B17217F8 0004059C  5494      move.l  #$b17217f8,fac2_m   * LOG(2) mantissa
00002A48  33FC 8000 000405A0      5495      move.w  #$8000,fac2_e       * LOG(2) exponent & sign
00002A50  13FC 0000 000405A2      5496      move.b  #0,fac_sc       * clear sign compare
00002A58  6100 F88C               5497      bsr lab_multiply        * multiply by log(2)
00002A5C                          5498  
00002A5C  2039 00040594           5499      move.l  fac1_m,d0       * get mantissa
00002A62  1A39 00040598           5500      move.b  fac1_e,d5       * get exponent
00002A68  0445 0082               5501      sub.w   #$82,d5         * normalise and -2 (result is -1 to -30)
00002A6C  4445                    5502      neg.w   d5          * make +ve
00002A6E  EAA8                    5503      lsr.l   d5,d0           * shift for 2 integer bits
00002A70                          5504  
00002A70                          5505  * d0 = arg
00002A70                          5506  * d6 = x, d1 = y
00002A70                          5507  * d2 = x1, d3 = y1
00002A70                          5508  * d4 = shift count
00002A70                          5509  * d5 = loop count
00002A70                          5510                      * now do cordic set-up
00002A70  7200                    5511      moveq   #0,d1           * y = 0
00002A72  2C3C 26A3D110           5512      move.l  #kfctseed,d6        * x = 1 with jkh inverse factored out
00002A78  207C 0000358C           5513      movea.l #tab_hthet,a0       * pointer to hyperbolic arctan table
00002A7E  7800                    5514      moveq   #0,d4           * clear shift count
00002A80                          5515  
00002A80                          5516                      * cordic loop, shifts 4 and 13 (and 39
00002A80                          5517                      * if it went that far) need to be repeated
00002A80  7A03                    5518      moveq   #3,d5           * 4 loops
00002A82  6140                    5519      bsr.s   lab_excc        * do loops 1 through 4
00002A84  5948                    5520      subq.w  #4,a0           * do table entry again
00002A86  5384                    5521      subq.l  #1,d4           * do shift count again
00002A88  7A09                    5522      moveq   #9,d5           * 10 loops
00002A8A  6138                    5523      bsr.s   lab_excc        * do loops 4 (again) through 13
00002A8C  5948                    5524      subq.w  #4,a0           * do table entry again
00002A8E  5384                    5525      subq.l  #1,d4           * do shift count again
00002A90  7A12                    5526      moveq   #18,d5          * 19 loops
00002A92  6130                    5527      bsr.s   lab_excc        * do loops 13 (again) through 31
00002A94                          5528  
00002A94                          5529                      * now get the result
00002A94  4A39 000405BC           5530      tst.b   cosout          * test sign flag
00002A9A  6A08                    5531      bpl.s   lab_expl        * branch if +ve
00002A9C                          5532  
00002A9C  4481                    5533      neg.l   d1          * do -y
00002A9E  4439 000405E1           5534      neg.b   tpower          * do -exp
00002AA4                          5535  lab_expl
00002AA4  7083                    5536      moveq   #$83-$100,d0        * set exponent
00002AA6  DC81                    5537      add.l   d1,d6           * y = y +/- x
00002AA8  6B06                    5538      bmi.s   lab_exrn        * branch if result normal
00002AAA                          5539  
00002AAA                          5540  lab_exnn
00002AAA  5380                    5541      subq.l  #1,d0           * decrement exponent
00002AAC  DC86                    5542      add.l   d6,d6           * shift mantissa
00002AAE  6AFA                    5543      bpl.s   lab_exnn        * loop if not normal
00002AB0                          5544  
00002AB0                          5545  lab_exrn
00002AB0  23C6 00040594           5546      move.l  d6,fac1_m       * save exponent result
00002AB6  D039 000405E1           5547      add.b   tpower,d0       * add integer part
00002ABC  13C0 00040598           5548      move.b  d0,fac1_e       * save exponent
00002AC2                          5549  **  movem.l (sp)+,d1-d6/a0      * restore registers
00002AC2  4E75                    5550      rts
00002AC4                          5551  
00002AC4                          5552                      * cordic loop
00002AC4                          5553  lab_excc
00002AC4  5284                    5554      addq.l  #1,d4           * increment shift count
00002AC6  2406                    5555      move.l  d6,d2           * x1 = x
00002AC8  E8A2                    5556      asr.l   d4,d2           * x1 >> n
00002ACA  2601                    5557      move.l  d1,d3           * y1 = y
00002ACC  E8A3                    5558      asr.l   d4,d3           * y1 >> n
00002ACE  4A80                    5559      tst.l   d0          * test arg
00002AD0  6B0C                    5560      bmi.s   lab_exad        * branch if -ve
00002AD2                          5561  
00002AD2  D282                    5562      add.l   d2,d1           * y = y + x1
00002AD4  DC83                    5563      add.l   d3,d6           * x = x + y1
00002AD6  9098                    5564      sub.l   (a0)+,d0        * arg = arg - atnh(a0)
00002AD8  51CD FFEA               5565      dbf d5,lab_excc     * decrement and loop if not done
00002ADC                          5566  
00002ADC  4E75                    5567      rts
00002ADE                          5568  
00002ADE                          5569  lab_exad
00002ADE  9282                    5570      sub.l   d2,d1           * y = y - x1
00002AE0  9C83                    5571      sub.l   d3,d6           * x = x + y1
00002AE2  D098                    5572      add.l   (a0)+,d0        * arg = arg + atnh(a0)
00002AE4  51CD FFDE               5573      dbf d5,lab_excc     * decrement and loop if not done
00002AE8                          5574  
00002AE8  4E75                    5575      rts
00002AEA                          5576  
00002AEA                          5577  * RND(n), 31 bit version. make n=0 for 5th next number in sequence or n<>0 to get
00002AEA                          5578  * 5th next number in sequence after seed n. Taking the 5th next number is slower
00002AEA                          5579  * but helps hide the shift & add nature of this generator.
00002AEA                          5580  
00002AEA                          5581  lab_rnd
00002AEA  1039 00040598           5582      move.b  fac1_e,d0       * get FAC1 exponent
00002AF0  670A                    5583      beq.s   nextprn         * do next random # if zero
00002AF2                          5584  
00002AF2                          5585                      * else get seed into random number store
00002AF2  207C 000405A4           5586      movea.l #prnlword,a0        * set PRNG pointer
00002AF8  6100 FA0A               5587      bsr lab_2778        * pack FAC1 into (a0)
00002AFC                          5588  
00002AFC                          5589  nextprn
00002AFC  7404                    5590      moveq   #4,d2           * do this 5 times
00002AFE  2039 000405A4           5591      move.l  prnlword,d0     * get current
00002B04                          5592  ninc0
00002B04  7200                    5593      moveq   #0,d1           * clear bit count
00002B06  E498                    5594      ror.l   #2,d0           * bit 31 -> carry
00002B08  6402                    5595      bcc.s   ninc1           * skip increment if =0
00002B0A                          5596  
00002B0A  5201                    5597      addq.b  #1,d1           * else increment bit count
00002B0C                          5598  ninc1
00002B0C  E698                    5599      ror.l   #3,d0           * bit 28 -> carry
00002B0E  6402                    5600      bcc.s   ninc2           * skip increment if =0
00002B10                          5601  
00002B10  5201                    5602      addq.b  #1,d1           * else increment bit count
00002B12                          5603  ninc2
00002B12  EB98                    5604      rol.l   #5,d0           * restore PRNG longword
00002B14  E211                    5605      roxr.b  #1,d1           * EOR bit into Xb
00002B16  E290                    5606      roxr.l  #1,d0           * shift bit to most significant
00002B18  51CA FFEA               5607      dbf d2,ninc0        * loop 5 times
00002B1C                          5608  
00002B1C  23C0 000405A4           5609      move.l  d0,prnlword     * save back to seed word
00002B22  23C0 00040594           5610      move.l  d0,fac1_m       * save to FAC1
00002B28                          5611  
00002B28  33FC 8000 00040598      5612      move.w  #$8000,fac1_e       * set the exponent and clear the sign
00002B30  6000 F650               5613      bra lab_24d5        * normalise FAC1 & return
00002B34                          5614  
00002B34                          5615  * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
00002B34                          5616  * x = angle in radians
00002B34                          5617  
00002B34                          5618  lab_tan
00002B34  6156                    5619      bsr.s   lab_sccc        * go do SIN/COS cordic compute
00002B36  6100 F64A               5620      bsr lab_24d5        * normalise FAC1
00002B3A  33F9 00040598 000405A0  5621      move.w  fac1_e,fac2_e       * copy exponent & sign from FAC1 to FAC2
00002B44  23F9 00040594 0004059C  5622      move.l  fac1_m,fac2_m       * copy FAC1 mantissa to FAC2 mantissa
00002B4E  23C1 00040594           5623      move.l  d1,fac1_m       * get COS(x) mantissa
00002B54  13C3 00040598           5624      move.b  d3,fac1_e       * get COS(x) exponent
00002B5A  6700 DC64               5625      beq lab_ofer        * do overflow if COS = 0
00002B5E                          5626  
00002B5E  6100 F622               5627      bsr lab_24d5        * normalise FAC1
00002B62  6000 F898               5628      bra lab_divide      * do FAC2/FAC1 & return (FAC_sc set by SIN COS calc)
00002B66                          5629  
00002B66                          5630  * cordic SIN(x), COS(x) routine
00002B66                          5631  * x = angle in radians
00002B66                          5632  
00002B66                          5633  lab_cos
00002B66  23FC C90FDAA3 0004059C  5634      move.l  #$c90fdaa3,fac2_m   * pi/2 mantissa (b2 is set so COS(PI/2)=0)
00002B70  33FC 8100 000405A0      5635      move.w  #$8100,fac2_e       * pi/2 exponent and sign
00002B78  13F9 00040599 000405A2  5636      move.b  fac1_s,fac_sc       * sign = FAC1 sign (b7)
00002B82  6100 F562               5637      bsr lab_add         * add FAC2 to FAC1, adjust for COS(x)
00002B86                          5638  lab_sin
00002B86  6104                    5639      bsr.s   lab_sccc        * go do SIN/COS cordic compute
00002B88  6000 F5F8               5640      bra lab_24d5        * normalise FAC1 & return
00002B8C                          5641  
00002B8C                          5642  * SIN/COS cordic calculator
00002B8C                          5643  
00002B8C                          5644  lab_sccc
00002B8C  13FC 0000 000405BC      5645      move.b  #0,cosout       * set needed result
00002B94                          5646  
00002B94  23FC A2F9836F 0004059C  5647      move.l  #$a2f9836f,fac2_m   * 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
00002B9E  33FC 7F00 000405A0      5648      move.w  #$7f00,fac2_e       * 1/pi exponent & sign
00002BA6  13F9 00040599 000405A2  5649      move.b  fac1_s,fac_sc       * sign = FAC1 sign (b7)
00002BB0  6100 F734               5650      bsr lab_multiply        * multiply by 1/pi
00002BB4                          5651  
00002BB4  1039 00040598           5652      move.b  fac1_e,d0       * get FAC1 exponent
00002BBA  6700 00B0               5653      beq lab_scze        * branch if zero
00002BBE                          5654  
00002BBE  207C 0000348C           5655      movea.l #tab_snco,a0        * point to constants table
00002BC4  2C39 00040594           5656      move.l  fac1_m,d6       * get FAC1 mantissa
00002BCA  5300                    5657      subq.b  #1,d0           * 2 radians in 360 degrees so /2
00002BCC  6700 009E               5658      beq lab_scze        * branch if zero
00002BD0                          5659  
00002BD0  0400 0080               5660      sub.b   #$80,d0         * normalise exponent
00002BD4  6B10                    5661      bmi.s   lab_scl0        * branch if < 1
00002BD6                          5662  
00002BD6                          5663                      * X is > 1
00002BD6  B03C 0020               5664      cmp.b   #$20,d0         * is it >= 2^32
00002BDA  6400 0090               5665      bcc lab_scze        * may as well do zero
00002BDE                          5666  
00002BDE  E1AE                    5667      lsl.l   d0,d6           * shift out integer part bits
00002BE0  6700 008A               5668      beq lab_scze        * no fraction so go do zero
00002BE4                          5669  
00002BE4  600A                    5670      bra.s   lab_cord        * go test quadrant and adjust
00002BE6                          5671  
00002BE6                          5672                      * x is < 1
00002BE6                          5673  lab_scl0
00002BE6  4400                    5674      neg.b   d0          * make +ve
00002BE8  B03C 001E               5675      cmp.b   #$1e,d0         * is it <= 2^-30
00002BEC  647E                    5676      bcc.s   lab_scze        * may as well do zero
00002BEE                          5677  
00002BEE  E0AE                    5678      lsr.l   d0,d6           * shift out <= 2^-32 bits
00002BF0                          5679  
00002BF0                          5680  * cordic calculator, arguament in d6
00002BF0                          5681  * table pointer in a0, returns in d0-d3
00002BF0                          5682  
00002BF0                          5683  lab_cord
00002BF0  13F9 00040599 000405A2  5684      move.b  fac1_s,fac_sc       * copy as sign compare for TAN
00002BFA  DC86                    5685      add.l   d6,d6           * shift 0.5 bit into carry
00002BFC  6408                    5686      bcc.s   lab_ltpf        * branch if less than 0.5
00002BFE                          5687  
00002BFE  0A39 00FF 00040599      5688      eori.b  #$ff,fac1_s     * toggle result sign
00002C06                          5689  lab_ltpf
00002C06  DC86                    5690      add.l   d6,d6           * shift 0.25 bit into carry
00002C08  6410                    5691      bcc.s   lab_ltpt        * branch if less than 0.25
00002C0A                          5692  
00002C0A  0A39 00FF 000405BC      5693      eori.b  #$ff,cosout     * toggle needed result
00002C12  0A39 00FF 000405A2      5694      eori.b  #$ff,fac_sc     * toggle sign compare for TAN
00002C1A                          5695  
00002C1A                          5696  lab_ltpt
00002C1A  E48E                    5697      lsr.l   #2,d6           * shift the bits back (clear integer bits)
00002C1C  674E                    5698      beq.s   lab_scze        * no fraction so go do zero
00002C1E                          5699  
00002C1E                          5700                      * set start values
00002C1E  7A01                    5701      moveq   #1,d5           * set bit count
00002C20  2028 FFFC               5702      move.l  -4(a0),d0       * get multiply constant (1st itteration d0)
00002C24  2200                    5703      move.l  d0,d1           * 1st itteration d1
00002C26  9C98                    5704      sub.l   (a0)+,d6        * 1st always +ve so do 1st step
00002C28  6008                    5705      bra.s   mainloop        * jump into routine
00002C2A                          5706  
00002C2A                          5707  subloop
00002C2A  9C98                    5708      sub.l   (a0)+,d6        * z = z - arctan(i)/2pi
00002C2C  9083                    5709      sub.l   d3,d0           * x = x - y1
00002C2E  D282                    5710      add.l   d2,d1           * y = y + x1
00002C30  6012                    5711      bra.s   nexta           * back to main loop
00002C32                          5712  
00002C32                          5713  mainloop
00002C32  2400                    5714      move.l  d0,d2           * x1 = x
00002C34  EAA2                    5715      asr.l   d5,d2           * / (2 ^ i)
00002C36  2601                    5716      move.l  d1,d3           * y1 = y
00002C38  EAA3                    5717      asr.l   d5,d3           * / (2 ^ i)
00002C3A  4A86                    5718      tst.l   d6          * test sign (is 2^0 bit)
00002C3C  6AEC                    5719      bpl.s   subloop         * go do subtract if > 1
00002C3E                          5720  
00002C3E  DC98                    5721      add.l   (a0)+,d6        * z = z + arctan(i)/2pi
00002C40  D083                    5722      add.l   d3,d0           * x = x + y1
00002C42  9282                    5723      sub.l   d2,d1           * y = y + x1
00002C44                          5724  nexta
00002C44  5285                    5725      addq.l  #1,d5           * i = i + 1
00002C46  BABC 0000001E           5726      cmp.l   #$1e,d5         * check end condition
00002C4C  66E4                    5727      bne.s   mainloop        * loop if not all done
00002C4E                          5728  
00002C4E                          5729                      * now untangle output value
00002C4E  7481                    5730      moveq   #$81-$100,d2        * set exponent for 0 to .99 rec.
00002C50  2602                    5731      move.l  d2,d3           * copy it for cos output
00002C52                          5732  outloop
00002C52  4A39 000405BC           5733      tst.b   cosout          * did we want cos output?
00002C58  6B04                    5734      bmi.s   subexit         * if so skip
00002C5A                          5735  
00002C5A  C141                    5736      exg d0,d1           * swap SIN and COS mantissas
00002C5C  C543                    5737      exg d2,d3           * swap SIN and COS exponents
00002C5E                          5738  subexit
00002C5E  23C0 00040594           5739      move.l  d0,fac1_m       * set result mantissa
00002C64  13C2 00040598           5740      move.b  d2,fac1_e       * set result exponent
00002C6A                          5741  rts_021
00002C6A  4E75                    5742      rts
00002C6C                          5743  
00002C6C                          5744                      * set values for 0/1
00002C6C                          5745  lab_scze
00002C6C  7481                    5746      moveq   #$81-$100,d2        * set exponent for 1.0
00002C6E  7600                    5747      moveq   #0,d3           * set exponent for 0.0
00002C70  203C 80000000           5748      move.l  #$80000000,d0       * mantissa for 1.0
00002C76  2203                    5749      move.l  d3,d1           * mantissa for 0.0
00002C78  60D8                    5750      bra.s   outloop         * go output it
00002C7A                          5751  
00002C7A                          5752  * perform ATN()
00002C7A                          5753  
00002C7A                          5754  lab_atn
00002C7A  13FC 0000 000405BC      5755      move.b  #0,cosout       * set needed result
00002C82  1039 00040598           5756      move.b  fac1_e,d0       * get FAC1 exponent
00002C88  B03C 0081               5757      cmp.b   #$81,d0         * compare exponent with 1
00002C8C  6510                    5758      bcs.s   lab_atlo        * branch if FAC1<1
00002C8E                          5759  
00002C8E  41FA 0B02               5760      lea (lab_259c,pc),a0    * set 1 pointer
00002C92  6100 F766               5761      bsr lab_26ca        * convert a0 and do (a0)/FAC1
00002C96  13FC 00FF 000405BC      5762      move.b  #$ff,cosout     * set needed result
00002C9E                          5763  lab_atlo
00002C9E  2039 00040594           5764      move.l  fac1_m,d0       * get FAC1 mantissa
00002CA4  D239 00040598           5765      add.b   fac1_e,d1       * get FAC1 exponent (always <= 1)
00002CAA  4881                    5766      ext.w   d1          * make word
00002CAC  48C1                    5767      ext.l   d1          * make word
00002CAE  4481                    5768      neg.l   d1          * change to +ve
00002CB0  5481                    5769      addq.l  #2,d1           * +2
00002CB2  B23C 000B               5770      cmp.b   #11,d1          * compare with 2^-11
00002CB6  64B2                    5771      bcc.s   rts_021         * x = ATN(x) so skip calc
00002CB8                          5772  
00002CB8  E2A8                    5773      lsr.l   d1,d0           * shift in two integer part bits
00002CBA  67B0                    5774      beq.s   lab_scze        * zero so go do zero
00002CBC                          5775  
00002CBC  207C 0000350C           5776      movea.l #tab_atnc,a0        * pointer to arctan table
00002CC2  7C00                    5777      moveq   #0,d6           * Z = 0
00002CC4  223C 40000000           5778      move.l  #1<<30,d1       * y = 1
00002CCA  7A1D                    5779      moveq   #29,d5          * loop 30 times
00002CCC  7801                    5780      moveq   #1,d4           * shift counter
00002CCE  6006                    5781      bra.s   lab_atcd        * enter loop
00002CD0                          5782  
00002CD0                          5783  lab_atnp
00002CD0  E8A2                    5784      asr.l   d4,d2           * x1 / 2^i
00002CD2  D282                    5785      add.l   d2,d1           * y = y + x1
00002CD4  DC90                    5786      add.l   (a0),d6         * z = z + atn(i)
00002CD6                          5787  lab_atcd
00002CD6  2400                    5788      move.l  d0,d2           * x1 = x
00002CD8  2601                    5789      move.l  d1,d3           * y1 = y
00002CDA  E8A3                    5790      asr.l   d4,d3           * y1 / 2^i
00002CDC                          5791  lab_catn
00002CDC  9083                    5792      sub.l   d3,d0           * x = x - y1
00002CDE  6AF0                    5793      bpl.s   lab_atnp        * branch if x >= 0
00002CE0                          5794  
00002CE0  2002                    5795      move.l  d2,d0           * else get x back
00002CE2  5848                    5796      addq.w  #4,a0           * increment pointer
00002CE4  5284                    5797      addq.l  #1,d4           * increment i
00002CE6  E283                    5798      asr.l   #1,d3           * y1 / 2^i
00002CE8  51CD FFF2               5799      dbf d5,lab_catn     * decrement and loop if not done
00002CEC                          5800  
00002CEC  13FC 0082 00040598      5801      move.b  #$82,fac1_e     * set new exponent
00002CF4  23C6 00040594           5802      move.l  d6,fac1_m       * save mantissa
00002CFA  6100 F486               5803      bsr lab_24d5        * normalise FAC1
00002CFE                          5804  
00002CFE  4A39 000405BC           5805      tst.b   cosout          * was it > 1 ?
00002D04  6A00 FF64               5806      bpl rts_021         * branch if not
00002D08                          5807  
00002D08  1E39 00040599           5808      move.b  fac1_s,d7       * get sign
00002D0E  13FC 0000 00040599      5809      move.b  #0,fac1_s       * clear sign
00002D16  23FC C90FDAA2 0004059C  5810      move.l  #$c90fdaa2,fac2_m   * set -(pi/2)
00002D20  33FC 8180 000405A0      5811      move.w  #$8180,fac2_e       * set exponent and sign
00002D28  13FC 00FF 000405A2      5812      move.b  #$ff,fac_sc     * set sign compare
00002D30  6100 F3B4               5813      bsr lab_add         * perform addition, FAC2 to FAC1
00002D34  13C7 00040599           5814      move.b  d7,fac1_s       * restore sign
00002D3A  4E75                    5815      rts
00002D3C                          5816  
00002D3C                          5817  * perform BITSET
00002D3C                          5818  
00002D3C                          5819  lab_bitset
00002D3C  6100 F272               5820      bsr lab_gadb        * get two parameters for POKE or WAIT
00002D40                          5821                      * first parameter in a0, second in d0
00002D40  B03C 0008               5822      cmp.b   #$08,d0         * only 0 to 7 are allowed
00002D44  6400 DA7E               5823      bcc lab_fcer        * branch if > 7
00002D48                          5824  
00002D48  7202                    5825      moveq   #$02,d1         * set value
00002D4A  E201                    5826      asr.b   #1,d1           * set Xb and value
00002D4C  E131                    5827      roxl.b  d0,d1           * move set bit
00002D4E  8210                    5828      or.b    (a0),d1         * OR with byte
00002D50  1081                    5829      move.b  d1,(a0)         * save byte
00002D52  4E75                    5830      rts
00002D54                          5831  
00002D54                          5832  * perform BITCLR
00002D54                          5833  
00002D54                          5834  lab_bitclr
00002D54  6100 F25A               5835      bsr lab_gadb        * get two parameters for POKE or WAIT
00002D58                          5836                      * first parameter in a0, second in d0
00002D58  B03C 0008               5837      cmp.b   #$08,d0         * only 0 to 7 are allowed
00002D5C  6400 DA66               5838      bcc lab_fcer        * branch if > 7
00002D60                          5839  
00002D60  72FF                    5840      moveq   #$ff-$100,d1        * set value
00002D62  E301                    5841      asl.b   #1,d1           * set Xb and value
00002D64  E131                    5842      roxl.b  d0,d1           * move cleared bit
00002D66  C210                    5843      and.b   (a0),d1         * AND with byte
00002D68  1081                    5844      move.b  d1,(a0)         * save byte
00002D6A  4E75                    5845      rts
00002D6C                          5846  
00002D6C                          5847  * perform BITTST()
00002D6C                          5848  
00002D6C                          5849  lab_btst
00002D6C  6100 E788               5850      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
00002D70  6100 F23E               5851      bsr lab_gadb        * get two parameters for POKE or WAIT
00002D74                          5852                      * first parameter in a0, second in d0
00002D74  B03C 0008               5853      cmp.b   #$08,d0         * only 0 to 7 are allowed
00002D78  6400 DA4A               5854      bcc lab_fcer        * branch if > 7
00002D7C                          5855  
00002D7C  2200                    5856      move.l  d0,d1           * copy bit # to test
00002D7E  6100 E784               5857      bsr lab_gbyt        * get next BASIC byte
00002D82  B03C 0029               5858      cmp.b   #')',d0         * is next character ")"
00002D86  6600 DA48               5859      bne lab_sner        * if not ")" go do syntax error, then warm start
00002D8A                          5860  
00002D8A  6100 E776               5861      bsr lab_igby        * update execute pointer (to character past ")")
00002D8E  7000                    5862      moveq   #0,d0           * set the result as zero
00002D90  0310                    5863      btst    d1,(a0)         * test bit
00002D92  6700 F806               5864      beq lab_27db        * branch if zero (already correct)
00002D96                          5865  
00002D96  70FF                    5866      moveq   #-1,d0          * set for -1 result
00002D98  6000 F800               5867      bra lab_27db        * go do SGN tail
00002D9C                          5868  
00002D9C                          5869  * perform BIN$()
00002D9C                          5870  * # of leading 0s is in d1, the number is in Itemp
00002D9C                          5871  
00002D9C                          5872  lab_bins
00002D9C  B23C 0021               5873      cmp.b   #$21,d1         * max + 1
00002DA0  6400 DA22               5874      bcc lab_fcer        * exit if too big ( > or = )
00002DA4                          5875  
00002DA4  2039 0004042E           5876      move.l  itemp,d0        * get number back
00002DAA  741F                    5877      moveq   #$1f,d2         * bit count-1
00002DAC  207C 000405BE           5878      movea.l #binss,a0       * point to string
00002DB2  7830                    5879      moveq   #$30,d4         * "0" character for ADDX
00002DB4                          5880  nextb1
00002DB4  7600                    5881      moveq   #0,d3           * clear byte
00002DB6  E288                    5882      lsr.l   #1,d0           * shift bit into Xb
00002DB8  D704                    5883      addx.b  d4,d3           * add carry and character to zero
00002DBA  1183 2000               5884      move.b  d3,(a0,d2.w)        * save character to string
00002DBE  51CA FFF4               5885      dbf d2,nextb1       * decrement and loop if not done
00002DC2                          5886  
00002DC2                          5887  * this is the exit code and is also used by HEX$()
00002DC2                          5888  
00002DC2                          5889  endbhs
00002DC2  13FC 0000 000405DE      5890      move.b  #0,bhsend       * null terminate the string
00002DCA  4A01                    5891      tst.b   d1          * test # of characters
00002DCC  670C                    5892      beq.s   nextb2          * go truncate string
00002DCE                          5893  
00002DCE  4481                    5894      neg.l   d1          * make -ve
00002DD0  0681 000405DE           5895      add.l   #bhsend,d1      * effectively (end-length)
00002DD6  2041                    5896      movea.l d1,a0           * move to pointer
00002DD8  600E                    5897      bra.s   binpr           * go print string
00002DDA                          5898  
00002DDA                          5899  * truncate string to remove leading "0"s
00002DDA                          5900  
00002DDA                          5901  nextb2
00002DDA  1010                    5902      move.b  (a0),d0         * get byte
00002DDC  670A                    5903      beq.s   binpr           * if null then end of string so add 1 and print it
00002DDE                          5904  
00002DDE  B03C 0030               5905      cmp.b   #'0',d0         * compare with "0"
00002DE2  660E                    5906      bne.s   gopr            * if not "0" then go print string from here
00002DE4                          5907  
00002DE4  5248                    5908      addq.w  #1,a0           * else increment pointer
00002DE6  60F2                    5909      bra.s   nextb2          * loop always
00002DE8                          5910  
00002DE8                          5911  * make fixed length output string - ignore overflows!
00002DE8                          5912  
00002DE8                          5913  binpr
00002DE8  B1FC 000405DE           5914      cmpa.l  #bhsend,a0      * are we at the string end
00002DEE  6602                    5915      bne.s   gopr            * branch if not
00002DF0                          5916  
00002DF0  5348                    5917      subq.w  #1,a0           * else need at least one zero
00002DF2                          5918  gopr
00002DF2  6100 E70E               5919      bsr lab_igby        * update execute pointer (to character past ")")
00002DF6  584F                    5920      addq.w  #4,sp           * bypass type check on exit
00002DF8  6000 EDEC               5921      bra lab_20ae        * print " terminated string to FAC1, stack & RET
00002DFC                          5922  
00002DFC                          5923  * perform HEX$()
00002DFC                          5924  
00002DFC                          5925  lab_hexs
00002DFC  B23C 0009               5926      cmp.b   #$09,d1         * max + 1
00002E00  6400 D9C2               5927      bcc lab_fcer        * exit if too big ( > or = )
00002E04                          5928  
00002E04  2039 0004042E           5929      move.l  itemp,d0        * get number back
00002E0A  7407                    5930      moveq   #$07,d2         * nibble count-1
00002E0C  207C 000405D6           5931      movea.l #hexss,a0       * point to string
00002E12  7830                    5932      moveq   #$30,d4         * "0" character for ABCD
00002E14                          5933  nexth1
00002E14  1600                    5934      move.b  d0,d3           * copy lowest byte
00002E16  E898                    5935      ror.l   #4,d0           * shift nibble into 0-3
00002E18  C63C 000F               5936      and.b   #$0f,d3         * just this nibble
00002E1C  1A03                    5937      move.b  d3,d5           * copy it
00002E1E  0605 00F6               5938      add.b   #$f6,d5         * set extend bit
00002E22  C704                    5939      abcd    d4,d3           * decimal add extend and character to zero
00002E24  1183 2000               5940      move.b  d3,(a0,d2.w)        * save character to string
00002E28  51CA FFEA               5941      dbf d2,nexth1       * decrement and loop if not done
00002E2C                          5942  
00002E2C  6094                    5943      bra.s   endbhs          * go process string
00002E2E                          5944  
00002E2E                          5945  * ctrl-c check routine. includes limited "life" byte save for INGET routine
00002E2E                          5946  * now also the code that checks to see if an interrupt has occurred
00002E2E                          5947  
00002E2E                          5948  vec_cc
00002E2E  4A39 000405F1           5949      tst.b   ccflag          * check [CTRL-C] check flag
00002E34  6628                    5950      bne.s   rts_022         * exit if inhibited
00002E36                          5951  
00002E36  4EB9 0004040C           5952      jsr v_inpt          * scan input device
00002E3C  6412                    5953      bcc.s   lab_fba0        * exit if buffer empty
00002E3E                          5954  
00002E3E  13C0 000405F2           5955      move.b  d0,ccbyte       * save received byte
00002E44  13FC 0020 000405F3      5956      move.b  #$20,ccnull     * set "life" timer for bytes countdown
00002E4C  6000 DE02               5957      bra lab_1636        * return to BASIC
00002E50                          5958  
00002E50                          5959  lab_fba0
00002E50  4A39 000405F3           5960      tst.b   ccnull          * get countdown byte
00002E56  6706                    5961      beq.s   rts_022         * exit if finished
00002E58                          5962  
00002E58  5339 000405F3           5963      subq.b  #1,ccnull       * else decrement countdown
00002E5E                          5964  rts_022
00002E5E  4E75                    5965      rts
00002E60                          5966  
00002E60                          5967  * get byte from input device, no waiting
00002E60                          5968  * returns with carry set if byte in A
00002E60                          5969  
00002E60                          5970  inget
00002E60  4EB9 0004040C           5971      jsr v_inpt          * call scan input device
00002E66  650E                    5972      bcs.s   lab_fb95        * if byte go reset timer
00002E68                          5973  
00002E68  1039 000405F3           5974      move.b  ccnull,d0       * get countdown
00002E6E  67EE                    5975      beq.s   rts_022         * exit if empty
00002E70                          5976  
00002E70  1039 000405F2           5977      move.b  ccbyte,d0       * get last received byte
00002E76                          5978  lab_fb95
00002E76  13FC 0000 000405F3      5979      move.b  #$00,ccnull     * clear timer because we got a byte
00002E7E  003C 0001               5980      ori.b   #1,ccr          * set carry, flag we got a byte
00002E82  4E75                    5981      rts
00002E84                          5982  
00002E84                          5983  * perform MAX()
00002E84                          5984  
00002E84                          5985  lab_max
00002E84  6100 E670               5986      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
00002E88  6100 E49A               5987      bsr lab_evnm        * evaluate expression & check is numeric,
00002E8C                          5988                      * else do type mismatch error/warm start
00002E8C                          5989  lab_maxn
00002E8C  612C                    5990      bsr.s   lab_phfa        * push FAC1, evaluate expression,
00002E8E                          5991                      * pull FAC2 & compare with FAC1
00002E8E  6AFC                    5992      bpl.s   lab_maxn        * branch if no swap to do
00002E90                          5993  
00002E90  6100 F69E               5994      bsr lab_279b        * copy FAC2 to FAC1
00002E94  60F6                    5995      bra.s   lab_maxn        * go do next
00002E96                          5996  
00002E96                          5997  * perform MIN()
00002E96                          5998  
00002E96                          5999  lab_min
00002E96  6100 E65E               6000      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
00002E9A  6100 E488               6001      bsr lab_evnm        * evaluate expression & check is numeric,
00002E9E                          6002                      * else do type mismatch
00002E9E                          6003  lab_minn
00002E9E  611A                    6004      bsr.s   lab_phfa        * push FAC1, evaluate expression,
00002EA0                          6005                      * pull FAC2 & compare with FAC1
00002EA0  6BFC                    6006      bmi.s   lab_minn        * branch if no swap to do
00002EA2                          6007  
00002EA2  67FA                    6008      beq.s   lab_minn        * branch if no swap to do
00002EA4                          6009  
00002EA4  6100 F68A               6010      bsr lab_279b        * copy FAC2 to FAC1
00002EA8  60F4                    6011      bra.s   lab_minn        * go do next (branch always)
00002EAA                          6012  
00002EAA                          6013  * exit routine. don't bother returning to the loop code
00002EAA                          6014  * check for correct exit, else so syntax error
00002EAA                          6015  
00002EAA                          6016  lab_mmec
00002EAA  B03C 0029               6017      cmp.b   #')',d0         * is it end of function?
00002EAE  6600 D920               6018      bne lab_sner        * if not do MAX MIN syntax error
00002EB2                          6019  
00002EB2  584F                    6020      addq.w  #4,sp           * dump return address
00002EB4  6100 E64C               6021      bsr lab_igby        * update BASIC execute pointer (to chr past ")")
00002EB8  4E75                    6022      rts
00002EBA                          6023  
00002EBA                          6024  * check for next, evaluate & return or exit
00002EBA                          6025  * this is the routine that does most of the work
00002EBA                          6026  
00002EBA                          6027  lab_phfa
00002EBA  6100 E648               6028      bsr lab_gbyt        * get next BASIC byte
00002EBE  B03C 002C               6029      cmp.b   #',',d0         * is there more ?
00002EC2  66E6                    6030      bne.s   lab_mmec        * if not go do end check
00002EC4                          6031  
00002EC4  3F39 00040598           6032      move.w  fac1_e,-(sp)        * push exponent and sign
00002ECA  2F39 00040594           6033      move.l  fac1_m,-(sp)        * push mantissa
00002ED0                          6034  
00002ED0  6100 E630               6035      bsr lab_igby        * scan & get next BASIC byte (after ",")
00002ED4  6100 E44E               6036      bsr lab_evnm        * evaluate expression & check is numeric,
00002ED8                          6037                      * else do type mismatch
00002ED8                          6038  
00002ED8                          6039                      * pop FAC2 (MAX/MIN expression so far)
00002ED8  23DF 0004059C           6040      move.l  (sp)+,fac2_m        * pop mantissa
00002EDE  33DF 000405A0           6041      move.w  (sp)+,fac2_e        * pop exponent and sign
00002EE4                          6042  
00002EE4  13F9 000405A1 000405A2  6043      move.b  fac2_s,fac_sc       * save FAC2 sign as sign compare
00002EEE  1039 00040599           6044      move.b  fac1_s,d0       * get FAC1 sign
00002EF4  B139 000405A2           6045      eor.b   d0,fac_sc       * EOR to create sign compare
00002EFA                          6046  
00002EFA  6000 F6C0               6047      bra lab_27fa        * compare FAC1 with FAC2 & return
00002EFE                          6048                      * returns d0=+1 if FAC1 > FAC2
00002EFE                          6049                      * returns d0= 0 if FAC1 = FAC2
00002EFE                          6050                      * returns d0=-1 if FAC1 < FAC2
00002EFE                          6051  
00002EFE                          6052  * perform WIDTH
00002EFE                          6053  
00002EFE                          6054  lab_wdth
00002EFE  B03C 002C               6055      cmp.b   #',',d0         * is next byte ","
00002F02  6732                    6056      beq.s   lab_tbsz        * if so do tab size
00002F04                          6057  
00002F04  6100 F04E               6058      bsr lab_gtby        * get byte parameter, result in d0 and Itemp
00002F08  4A00                    6059      tst.b   d0          * test result
00002F0A  6716                    6060      beq.s   lab_nstt        * branch if set for infinite line
00002F0C                          6061  
00002F0C  B03C 0010               6062      cmp.b   #$10,d0         * else make min width = 16d
00002F10  6500 D8B2               6063      bcs lab_fcer        * if less do function call error & exit
00002F14                          6064  
00002F14                          6065  * this next compare ensures that we can't exit WIDTH via an error leaving the
00002F14                          6066  * tab size greater than the line length.
00002F14                          6067  
00002F14  B039 000405EA           6068      cmp.b   tabsiz,d0       * compare with tab size
00002F1A  6406                    6069      bcc.s   lab_nstt        * branch if >= tab size
00002F1C                          6070  
00002F1C  13C0 000405EA           6071      move.b  d0,tabsiz       * else make tab size = terminal width
00002F22                          6072  lab_nstt
00002F22  13C0 000405EF           6073      move.b  d0,twidth       * set the terminal width
00002F28  6100 E5DA               6074      bsr lab_gbyt        * get BASIC byte back
00002F2C  6732                    6075      beq.s   wexit           * exit if no following
00002F2E                          6076  
00002F2E  B03C 002C               6077      cmp.b   #',',d0         * else is it ","
00002F32  6600 D89C               6078      bne lab_sner        * if not do syntax error
00002F36                          6079  
00002F36                          6080  lab_tbsz
00002F36  6100 F018               6081      bsr lab_sgby        * increment and get byte, result in d0 and Itemp
00002F3A  4A00                    6082      tst.b   d0          * test TAB size
00002F3C  6B00 D886               6083      bmi lab_fcer        * if >127 do function call error & exit
00002F40                          6084  
00002F40  B03C 0001               6085      cmp.b   #1,d0           * compare with min-1
00002F44  6500 D87E               6086      bcs lab_fcer        * if <=1 do function call error & exit
00002F48                          6087  
00002F48  1239 000405EF           6088      move.b  twidth,d1       * set flags for width
00002F4E  670A                    6089      beq.s   lab_svtb        * skip check if infinite line
00002F50                          6090  
00002F50  B039 000405EF           6091      cmp.b   twidth,d0       * compare TAB with width
00002F56  6E00 D86C               6092      bgt lab_fcer        * branch if too big
00002F5A                          6093  
00002F5A                          6094  lab_svtb
00002F5A  13C0 000405EA           6095      move.b  d0,tabsiz       * save TAB size
00002F60                          6096  
00002F60                          6097  * calculate tab column limit from TAB size. The Iclim is set to the last tab
00002F60                          6098  * position on a line that still has at least one whole tab width between it
00002F60                          6099  * and the end of the line.
00002F60                          6100  
00002F60                          6101  wexit
00002F60  1039 000405EF           6102      move.b  twidth,d0       * get width
00002F66  670E                    6103      beq.s   lab_wdlp        * branch if infinite line
00002F68                          6104  
00002F68  B039 000405EA           6105      cmp.b   tabsiz,d0       * compare with tab size
00002F6E  6406                    6106      bcc.s   lab_wdlp        * branch if >= tab size
00002F70                          6107  
00002F70  13C0 000405EA           6108      move.b  d0,tabsiz       * else make tab size = terminal width
00002F76                          6109  lab_wdlp
00002F76  9039 000405EA           6110      sub.b   tabsiz,d0       * subtract tab size
00002F7C  64F8                    6111      bcc.s   lab_wdlp        * loop while no borrow
00002F7E                          6112  
00002F7E  D039 000405EA           6113      add.b   tabsiz,d0       * add tab size back
00002F84  D039 000405EA           6114      add.b   tabsiz,d0       * add tab size back again
00002F8A                          6115  
00002F8A  4400                    6116      neg.b   d0          * make -ve
00002F8C  D039 000405EF           6117      add.b   twidth,d0       * subtract remainder from width
00002F92  13C0 000405F0           6118      move.b  d0,iclim        * save tab column limit
00002F98                          6119  rts_023
00002F98  4E75                    6120      rts
00002F9A                          6121  
00002F9A                          6122  * perform SQR()
00002F9A                          6123  
00002F9A                          6124  * d0 is number to find the root of
00002F9A                          6125  * d1 is the root result
00002F9A                          6126  * d2 is the remainder
00002F9A                          6127  * d3 is a counter
00002F9A                          6128  * d4 is temp
00002F9A                          6129  
00002F9A                          6130  lab_sqr
00002F9A  4A39 00040599           6131      tst.b   fac1_s          * test FAC1 sign
00002FA0  6B00 D822               6132      bmi lab_fcer        * if -ve do function call error
00002FA4                          6133  
00002FA4  4A39 00040598           6134      tst.b   fac1_e          * test exponent
00002FAA  67EC                    6135      beq.s   rts_023         * exit if zero
00002FAC                          6136  
00002FAC  48E7 7800               6137      movem.l d1-d4,-(sp)     * save registers
00002FB0  2039 00040594           6138      move.l  fac1_m,d0       * copy FAC1
00002FB6  7400                    6139      moveq   #0,d2           * clear remainder
00002FB8  2202                    6140      move.l  d2,d1           * clear root
00002FBA                          6141  
00002FBA  761F                    6142      moveq   #$1f,d3         * $1F for DBF, 64 pairs of bits to
00002FBC                          6143                      * do for a 32 bit result
00002FBC  0839 0000 00040598      6144      btst    #0,fac1_e       * test exponent odd/even
00002FC4  6606                    6145      bne.s   lab_sqe2        * if odd only 1 shift first time
00002FC6                          6146  
00002FC6                          6147  lab_sqe1
00002FC6  D080                    6148      add.l   d0,d0           * shift highest bit of number ..
00002FC8  D582                    6149      addx.l  d2,d2           * .. into remainder .. never overflows
00002FCA  D281                    6150      add.l   d1,d1           * root = root * 2 .. never overflows
00002FCC                          6151  lab_sqe2
00002FCC  D080                    6152      add.l   d0,d0           * shift highest bit of number ..
00002FCE  D582                    6153      addx.l  d2,d2           * .. into remainder .. never overflows
00002FD0                          6154  
00002FD0  2801                    6155      move.l  d1,d4           * copy root
00002FD2  D884                    6156      add.l   d4,d4           * 2n
00002FD4  5284                    6157      addq.l  #1,d4           * 2n+1
00002FD6                          6158  
00002FD6  B484                    6159      cmp.l   d4,d2           * compare 2n+1 to remainder
00002FD8  6504                    6160      bcs.s   lab_sqns        * skip sub if remainder smaller
00002FDA                          6161  
00002FDA  9484                    6162      sub.l   d4,d2           * subtract temp from remainder
00002FDC  5281                    6163      addq.l  #1,d1           * increment root
00002FDE                          6164  lab_sqns
00002FDE  51CB FFE6               6165      dbf d3,lab_sqe1     * loop if not all done
00002FE2                          6166  
00002FE2  23C1 00040594           6167      move.l  d1,fac1_m       * save result mantissa
00002FE8  1039 00040598           6168      move.b  fac1_e,d0       * get exponent (d0 is clear here)
00002FEE  0440 0080               6169      sub.w   #$80,d0         * normalise
00002FF2  E248                    6170      lsr.w   #1,d0           * /2
00002FF4  6402                    6171      bcc.s   lab_sqna        * skip increment if carry clear
00002FF6                          6172  
00002FF6  5240                    6173      addq.w  #1,d0           * add bit zero back in (allow for half shift)
00002FF8                          6174  lab_sqna
00002FF8  0640 0080               6175      add.w   #$80,d0         * re-bias to $80
00002FFC  13C0 00040598           6176      move.b  d0,fac1_e       * save it
00003002  4CDF 001E               6177      movem.l (sp)+,d1-d4     * restore registers
00003006  6000 F17A               6178      bra lab_24d5        * normalise FAC1 & return
0000300A                          6179  
0000300A                          6180  * perform VARPTR()
0000300A                          6181  
0000300A                          6182  lab_varptr
0000300A  6100 E4EA               6183      bsr lab_1bfe        * scan for "(" , else do syntax error/warm start
0000300E  6100 E70C               6184      bsr lab_gvar        * get var address
00003012                          6185                      * return pointer to variable in Cvaral and a0
00003012  6100 E4DE               6186      bsr lab_1bfb        * scan for ")" , else do syntax error/warm start
00003016  2039 00040472           6187      move.l  cvaral,d0       * get var address
0000301C  6000 EA76               6188      bra lab_ayfc        * convert d0 to signed longword in FAC1 & return
00003020                          6189  
00003020                          6190  * perform PI
00003020                          6191  
00003020                          6192  lab_pi
00003020  13FC 0000 000405BD      6193      move.b  #$00,dtypef     * clear data type flag, $00=float
00003028  23FC C90FDAA2 00040594  6194      move.l  #$c90fdaa2,fac1_m   * pi mantissa (32 bit)
00003032  33FC 8200 00040598      6195      move.w  #$8200,fac1_e       * pi exponent and sign
0000303A  4E75                    6196      rts
0000303C                          6197  
0000303C                          6198  * perform TWOPI
0000303C                          6199  
0000303C                          6200  lab_twopi
0000303C  13FC 0000 000405BD      6201      move.b  #$00,dtypef     * clear data type flag, $00=float
00003044  23FC C90FDAA2 00040594  6202      move.l  #$c90fdaa2,fac1_m   * 2pi mantissa (32 bit)
0000304E  33FC 8300 00040598      6203      move.w  #$8300,fac1_e       * 2pi exponent and sign
00003056  4E75                    6204      rts
00003058                          6205  
00003058                          6206  * get ASCII string equivalent into FAC1 as integer32 or float
00003058                          6207  
00003058                          6208  * entry is with a5 pointing to the first character of the string
00003058                          6209  * exit with a5 pointing to the first character after the string
00003058                          6210  
00003058                          6211  * d0 is character
00003058                          6212  * d1 is mantissa
00003058                          6213  * d2 is partial and table mantissa
00003058                          6214  * d3 is mantissa exponent (decimal & binary)
00003058                          6215  * d4 is decimal exponent
00003058                          6216  
00003058                          6217  * get FAC1 from string
00003058                          6218  * this routine now handles hex and binary values from strings
00003058                          6219  * starting with "$" and "%" respectively
00003058                          6220  
00003058                          6221  lab_2887
00003058  48E7 7C00               6222      movem.l d1-d5,-(sp)     * save registers
0000305C  7200                    6223      moveq   #$00,d1         * clear temp accumulator
0000305E  2601                    6224      move.l  d1,d3           * set mantissa decimal exponent count
00003060  2801                    6225      move.l  d1,d4           * clear decimal exponent
00003062  13C1 00040599           6226      move.b  d1,fac1_s       * clear sign byte
00003068  13C1 000405BD           6227      move.b  d1,dtypef       * set float data type
0000306E  13C1 000405B7           6228      move.b  d1,expneg       * clear exponent sign
00003074  6100 E48E               6229      bsr lab_gbyt        * get first byte back
00003078  653E                    6230      bcs.s   lab_28fe        * go get floating if 1st character numeric
0000307A                          6231  
0000307A  B03C 002D               6232      cmp.b   #'-',d0         * or is it -ve number
0000307E  660A                    6233      bne.s   lab_289a        * branch if not
00003080                          6234  
00003080  13FC 00FF 00040599      6235      move.b  #$ff,fac1_s     * set sign byte
00003088  6006                    6236      bra.s   lab_289c        * now go scan & check for hex/bin/int
0000308A                          6237  
0000308A                          6238  lab_289a
0000308A                          6239                      * first character wasn't numeric or -
0000308A  B03C 002B               6240      cmp.b   #'+',d0         * compare with '+'
0000308E  6606                    6241      bne.s   lab_289d        * branch if not '+' (go check for '.'/hex/bin/int)
00003090                          6242  
00003090                          6243  lab_289c
00003090                          6244                      * was "+" or "-" to start, so get next character
00003090  6100 E470               6245      bsr lab_igby        * increment & scan memory
00003094  6522                    6246      bcs.s   lab_28fe        * branch if numeric character
00003096                          6247  
00003096                          6248  lab_289d
00003096  B03C 002E               6249      cmp.b   #'.',d0         * else compare with '.'
0000309A  6700 0094               6250      beq lab_2904        * branch if '.'
0000309E                          6251  
0000309E                          6252                      * code here for hex/binary/integer numbers
0000309E  B03C 0024               6253      cmp.b   #'$',d0         * compare with '$'
000030A2  6700 011E               6254      beq lab_chex        * branch if '$'
000030A6                          6255  
000030A6  B03C 0025               6256      cmp.b   #'%',d0         * else compare with '%'
000030AA  6700 017E               6257      beq lab_cbin        * branch if '%'
000030AE                          6258  
000030AE                          6259  **  cmp.b   #'&',d0         * else compare with '&'
000030AE                          6260  **  beq.s   lab_cint        * branch if '&' go do integer get ##
000030AE                          6261  
000030AE                          6262  * ##    bra lab_sner        * not #.$%& so do error
000030AE  6000 008E               6263      bra lab_2y01        * not #.$%& so return 0
000030B2                          6264  
000030B2                          6265  lab_28fd
000030B2  6100 E44E               6266      bsr lab_igby        * get next character
000030B6  646E                    6267      bcc.s   lab_2902        * exit loop if not a digit
000030B8                          6268  
000030B8                          6269  lab_28fe
000030B8  6100 01C4               6270      bsr d1x10           * multiply d1 by 10 and add character
000030BC  64F4                    6271      bcc.s   lab_28fd        * loop for more if no overflow
000030BE                          6272  
000030BE                          6273  lab_28ff
000030BE                          6274                      * overflowed mantissa, count 10s exponent
000030BE  5283                    6275      addq.l  #1,d3           * increment mantissa decimal exponent count
000030C0  6100 E440               6276      bsr lab_igby        * get next character
000030C4  65F8                    6277      bcs.s   lab_28ff        * loop while numeric character
000030C6                          6278  
000030C6                          6279                      * done overflow, now flush fraction or do E
000030C6  B03C 002E               6280      cmp.b   #'.',d0         * else compare with '.'
000030CA  6606                    6281      bne.s   lab_2901        * branch if not '.'
000030CC                          6282  
000030CC                          6283  lab_2900
000030CC                          6284                      * flush remaining fractional digits
000030CC  6100 E434               6285      bsr lab_igby        * get next character
000030D0  65FA                    6286      bcs lab_2900        * loop while numeric character
000030D2                          6287  
000030D2                          6288  lab_2901
000030D2                          6289                      * done number, only (possible) exponent remains
000030D2  B03C 0045               6290      cmp.b   #'E',d0         * else compare with 'E'
000030D6  6666                    6291      bne.s   lab_2y01        * if not 'E' all done, go evaluate
000030D8                          6292  
000030D8                          6293                      * process exponent
000030D8  6100 E428               6294      bsr lab_igby        * get next character
000030DC  652A                    6295      bcs.s   lab_2x04        * branch if digit
000030DE                          6296  
000030DE  B03C 002D               6297      cmp.b   #'-',d0         * or is it -ve number
000030E2  6706                    6298      beq.s   lab_2x01        * branch if so
000030E4                          6299  
000030E4  B03C 00B2               6300      cmp.b   #tk_minus,d0        * or is it -ve number
000030E8  660A                    6301      bne.s   lab_2x02        * branch if not
000030EA                          6302  
000030EA                          6303  lab_2x01
000030EA  13FC 00FF 000405B7      6304      move.b  #$ff,expneg     * set exponent sign
000030F2  600E                    6305      bra.s   lab_2x03        * now go scan & check exponent
000030F4                          6306  
000030F4                          6307  lab_2x02
000030F4  B03C 002B               6308      cmp.b   #'+',d0         * or is it +ve number
000030F8  6708                    6309      beq.s   lab_2x03        * branch if so
000030FA                          6310  
000030FA  B03C 00B1               6311      cmp.b   #tk_plus,d0     * or is it +ve number
000030FE  6600 D6D0               6312      bne lab_sner        * wasn't - + TK_MINUS TK_PLUS or # so do error
00003102                          6313  
00003102                          6314  lab_2x03
00003102  6100 E3FE               6315      bsr lab_igby        * get next character
00003106  6436                    6316      bcc.s   lab_2y01        * if not digit all done, go evaluate
00003108                          6317  lab_2x04
00003108  C8FC 000A               6318      mulu    #10,d4          * multiply decimal exponent by 10
0000310C  C0BC 000000FF           6319      and.l   #$ff,d0         * mask character
00003112  0400 0030               6320      sub.b   #'0',d0         * convert to value
00003116  D880                    6321      add.l   d0,d4           * add to decimal exponent
00003118  B83C 0030               6322      cmp.b   #48,d4          * compare with decimal exponent limit+10
0000311C  6FE4                    6323      ble.s   lab_2x03        * loop if no overflow/underflow
0000311E                          6324  
0000311E                          6325  lab_2x05
0000311E                          6326                      * exponent value has overflowed
0000311E  6100 E3E2               6327      bsr lab_igby        * get next character
00003122  65FA                    6328      bcs.s   lab_2x05        * loop while numeric digit
00003124                          6329  
00003124  6018                    6330      bra.s   lab_2y01        * all done, go evaluate
00003126                          6331  
00003126                          6332  lab_2902
00003126  B03C 002E               6333      cmp.b   #'.',d0         * else compare with '.'
0000312A  6704                    6334      beq.s   lab_2904        * branch if was '.'
0000312C                          6335  
0000312C  60A4                    6336      bra.s   lab_2901        * branch if not '.' (go check/do 'E')
0000312E                          6337  
0000312E                          6338  lab_2903
0000312E  5383                    6339      subq.l  #1,d3           * decrement mantissa decimal exponent
00003130                          6340  lab_2904
00003130                          6341                      * was dp so get fractional part
00003130  6100 E3D0               6342      bsr lab_igby        * get next character
00003134  649C                    6343      bcc.s   lab_2901        * exit loop if not a digit (go check/do 'E')
00003136                          6344  
00003136  6100 0146               6345      bsr d1x10           * multiply d1 by 10 and add character
0000313A  64F2                    6346      bcc.s   lab_2903        * loop for more if no overflow
0000313C                          6347  
0000313C  608E                    6348      bra.s   lab_2900        * else go flush remaining fractional part
0000313E                          6349  
0000313E                          6350  lab_2y01
0000313E                          6351                      * now evaluate result
0000313E  4A39 000405B7           6352      tst.b   expneg          * test exponent sign
00003144  6A02                    6353      bpl.s   lab_2y02        * branch if sign positive
00003146                          6354  
00003146  4484                    6355      neg.l   d4          * negate decimal exponent
00003148                          6356  lab_2y02
00003148  D883                    6357      add.l   d3,d4           * add mantissa decimal exponent
0000314A  7620                    6358      moveq   #32,d3          * set up max binary exponent
0000314C  4A81                    6359      tst.l   d1          * test mantissa
0000314E  675E                    6360      beq.s   lab_rtn0        * if mantissa=0 return 0
00003150                          6361  
00003150  6B08                    6362      bmi.s   lab_2y04        * branch if already mormalised
00003152                          6363  
00003152  5383                    6364      subq.l  #1,d3           * decrement bianry exponent for DBMI loop
00003154                          6365  lab_2y03
00003154  D281                    6366      add.l   d1,d1           * shift mantissa
00003156  5BCB FFFC               6367      dbmi    d3,lab_2y03     * decrement & loop if not normalised
0000315A                          6368  
0000315A                          6369                      * ensure not too big or small
0000315A                          6370  lab_2y04
0000315A  B8BC 00000026           6371      cmp.l   #38,d4          * compare decimal exponent with max exponent
00003160  6E00 D65E               6372      bgt lab_ofer        * if greater do overflow error and warm start
00003164                          6373  
00003164  B8BC FFFFFFDA           6374      cmp.l   #-38,d4         * compare decimal exponent with min exponent
0000316A  6D40                    6375      blt.s   lab_ret0        * if less just return zero
0000316C                          6376  
0000316C  4484                    6377      neg.l   d4          * negate decimal exponent to go right way
0000316E  C9FC 0006               6378      muls    #6,d4           * 6 bytes per entry
00003172  2F08                    6379      move.l  a0,-(sp)        * save register
00003174  41FA 0228               6380      lea (lab_p_10,pc),a0    * point to table
00003178  13F0 4001 000405A0      6381      move.b  1(a0,d4.w),fac2_e   * copy exponent for multiply
00003180  23F0 4002 0004059C      6382      move.l  2(a0,d4.w),fac2_m   * copy table mantissa
00003188  205F                    6383      move.l  (sp)+,a0        * restore register
0000318A                          6384  
0000318A  0A03 0080               6385      eori.b  #$80,d3         * normalise input exponent
0000318E  23C1 00040594           6386      move.l  d1,fac1_m       * save input mantissa
00003194  13C3 00040598           6387      move.b  d3,fac1_e       * save input exponent
0000319A  13F9 00040599 000405A2  6388      move.b  fac1_s,fac_sc       * set sign as sign compare
000031A4                          6389  
000031A4  4CDF 003E               6390      movem.l (sp)+,d1-d5     * restore registers
000031A8  6000 F13C               6391      bra lab_multiply        * go multiply input by table
000031AC                          6392  
000031AC                          6393  lab_ret0
000031AC  7200                    6394      moveq   #0,d1           * clear mantissa
000031AE                          6395  lab_rtn0
000031AE  2601                    6396      move.l  d1,d3           * clear exponent
000031B0  13C3 00040598           6397      move.b  d3,fac1_e       * save exponent
000031B6  23C1 00040594           6398      move.l  d1,fac1_m       * save mantissa
000031BC  4CDF 003E               6399      movem.l (sp)+,d1-d5     * restore registers
000031C0  4E75                    6400      rts
000031C2                          6401  
000031C2                          6402  * $ for hex add-on
000031C2                          6403  
000031C2                          6404  * gets here if the first character was "$" for hex
000031C2                          6405  * get hex number
000031C2                          6406  
000031C2                          6407  lab_chex
000031C2  13FC 0040 000405BD      6408      move.b  #$40,dtypef     * set integer numeric data type
000031CA  7620                    6409      moveq   #32,d3          * set up max binary exponent
000031CC                          6410  lab_chxx
000031CC  6100 E334               6411      bsr lab_igby        * increment & scan memory
000031D0  6514                    6412      bcs.s   lab_ishn        * branch if numeric character
000031D2                          6413  
000031D2  803C 0020               6414      or.b    #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
000031D6  0400 0061               6415      sub.b   #'a',d0         * subtract "a"
000031DA  652A                    6416      bcs.s   lab_chx3        * exit if <"a"
000031DC                          6417  
000031DC  B03C 0006               6418      cmp.b   #$06,d0         * compare normalised with $06 (max+1)
000031E0  6424                    6419      bcc.s   lab_chx3        * exit if >"f"
000031E2                          6420  
000031E2  0600 003A               6421      add.b   #$3a,d0         * convert to nibble+"0"
000031E6                          6422  lab_ishn
000031E6  6172                    6423      bsr.s   d1x16           * multiply d1 by 16 and add character
000031E8  64E2                    6424      bcc.s   lab_chxx        * loop for more if no overflow
000031EA                          6425  
000031EA                          6426                      * overflowed mantissa, count 16s exponent
000031EA                          6427  lab_chx1
000031EA  5883                    6428      addq.l  #4,d3           * increment mantissa exponent count
000031EC  6900 D5D2               6429      bvs lab_ofer        * do overflow error if overflowed
000031F0                          6430  
000031F0  6100 E310               6431      bsr lab_igby        * get next character
000031F4  65F4                    6432      bcs.s   lab_chx1        * loop while numeric character
000031F6                          6433  
000031F6  803C 0020               6434      or.b    #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
000031FA  0400 0061               6435      sub.b   #'a',d0         * subtract "a"
000031FE  6506                    6436      bcs.s   lab_chx3        * exit if <"a"
00003200                          6437  
00003200  B03C 0006               6438      cmp.b   #$06,d0         * compare normalised with $06 (max+1)
00003204  65E4                    6439      bcs.s   lab_chx1        * loop if <="f"
00003206                          6440  
00003206                          6441                      * now return value
00003206                          6442  lab_chx3
00003206  4A81                    6443      tst.l   d1          * test mantissa
00003208  67A4                    6444      beq.s   lab_rtn0        * if mantissa=0 return 0
0000320A                          6445  
0000320A  6B08                    6446      bmi.s   lab_exxf        * branch if already mormalised
0000320C                          6447  
0000320C  5383                    6448      subq.l  #1,d3           * decrement bianry exponent for DBMI loop
0000320E                          6449  lab_chx2
0000320E  D281                    6450      add.l   d1,d1           * shift mantissa
00003210  5BCB FFFC               6451      dbmi    d3,lab_chx2     * decrement & loop if not normalised
00003214                          6452  
00003214                          6453  lab_exxf
00003214  0A03 0080               6454      eori.b  #$80,d3         * normalise exponent
00003218  13C3 00040598           6455      move.b  d3,fac1_e       * save exponent
0000321E  23C1 00040594           6456      move.l  d1,fac1_m       * save mantissa
00003224  4CDF 003E               6457      movem.l (sp)+,d1-d5     * restore registers
00003228                          6458  rts_024
00003228  4E75                    6459      rts
0000322A                          6460  
0000322A                          6461  * % for binary add-on
0000322A                          6462  
0000322A                          6463  * gets here if the first character was  "%" for binary
0000322A                          6464  * get binary number
0000322A                          6465  
0000322A                          6466  lab_cbin
0000322A  13FC 0040 000405BD      6467      move.b  #$40,dtypef     * set integer numeric data type
00003232  7620                    6468      moveq   #32,d3          * set up max binary exponent
00003234                          6469  lab_cbxn
00003234  6100 E2CC               6470      bsr lab_igby        * increment & scan memory
00003238  64CC                    6471      bcc.s   lab_chx3        * if not numeric character go return value
0000323A                          6472  
0000323A  B03C 0032               6473      cmp.b   #'2',d0         * compare with "2" (max+1)
0000323E  64C6                    6474      bcc.s   lab_chx3        * if >="2" go return value
00003240                          6475  
00003240  2401                    6476      move.l  d1,d2           * copy value
00003242  6124                    6477      bsr.s   d1x02           * multiply d1 by 2 and add character
00003244  64EE                    6478      bcc.s   lab_cbxn        * loop for more if no overflow
00003246                          6479  
00003246                          6480                      * overflowed mantissa, count 2s exponent
00003246                          6481  lab_cbx1
00003246  5283                    6482      addq.l  #1,d3           * increment mantissa exponent count
00003248  6900 D576               6483      bvs lab_ofer        * do overflow error if overflowed
0000324C                          6484  
0000324C  6100 E2B4               6485      bsr lab_igby        * get next character
00003250  64B4                    6486      bcc.s   lab_chx3        * if not numeric character go return value
00003252                          6487  
00003252  B03C 0032               6488      cmp.b   #'2',d0         * compare with "2" (max+1)
00003256  65EE                    6489      bcs.s   lab_cbx1        * loop if <"2"
00003258                          6490  
00003258  60AC                    6491      bra.s   lab_chx3        * if not numeric character go return value
0000325A                          6492  
0000325A                          6493  * half way decent times 16 and times 2 with overflow checks
0000325A                          6494  
0000325A                          6495  d1x16
0000325A  2401                    6496      move.l  d1,d2           * copy value
0000325C  D482                    6497      add.l   d2,d2           * times two
0000325E  65C8                    6498      bcs.s   rts_024         * return if overflow
00003260                          6499  
00003260  D482                    6500      add.l   d2,d2           * times four
00003262  65C4                    6501      bcs.s   rts_024         * return if overflow
00003264                          6502  
00003264  D482                    6503      add.l   d2,d2           * times eight
00003266  65C0                    6504      bcs.s   rts_024         * return if overflow
00003268                          6505  
00003268                          6506  d1x02
00003268  D482                    6507      add.l   d2,d2           * times sixteen (ten/two)
0000326A  65BC                    6508      bcs.s   rts_024         * return if overflow
0000326C                          6509  
0000326C                          6510  * now add in new digit
0000326C                          6511  
0000326C  C0BC 000000FF           6512      and.l   #$ff,d0         * mask character
00003272  0400 0030               6513      sub.b   #'0',d0         * convert to value
00003276  D480                    6514      add.l   d0,d2           * add to result
00003278  65AE                    6515      bcs.s   rts_024         * return if overflow (should never ever do this ##)
0000327A                          6516  
0000327A  2202                    6517      move.l  d2,d1           * copy result
0000327C  4E75                    6518      rts
0000327E                          6519  
0000327E                          6520  * half way decent times 10 with overflow checks
0000327E                          6521  
0000327E                          6522  d1x10
0000327E  2401                    6523      move.l  d1,d2           * copy value
00003280  D482                    6524      add.l   d2,d2           * times two
00003282  6508                    6525      bcs.s   rts_025         * return if overflow
00003284                          6526  
00003284  D482                    6527      add.l   d2,d2           * times four
00003286  6504                    6528      bcs.s   rts_025         * return if overflow
00003288                          6529  
00003288  D481                    6530      add.l   d1,d2           * times five
0000328A  64DC                    6531      bcc.s   d1x02           * do times two and add in new digit if ok
0000328C                          6532  
0000328C                          6533  rts_025
0000328C  4E75                    6534      rts
0000328E                          6535  
0000328E                          6536  *************************************************************************************
0000328E                          6537  
0000328E                          6538  * token values needed for BASIC
0000328E                          6539  
0000328E  =00000080               6540  tk_end      equ $80
0000328E  =00000081               6541  tk_for      equ tk_end+1    * $81 * FOR token
0000328E  =00000082               6542  tk_next     equ tk_for+1    * $82
0000328E  =00000083               6543  tk_data     equ tk_next+1   * $83 * DATA token
0000328E  =00000084               6544  tk_input    equ tk_data+1   * $84
0000328E  =00000085               6545  tk_dim      equ tk_input+1  * $85
0000328E  =00000086               6546  tk_read     equ tk_dim+1    * $86
0000328E  =00000087               6547  tk_let      equ tk_read+1   * $87
0000328E  =00000088               6548  tk_dec      equ tk_let+1    * $88
0000328E  =00000089               6549  tk_goto     equ tk_dec+1    * $89 * GOTO token
0000328E  =0000008A               6550  tk_run      equ tk_goto+1   * $8A
0000328E  =0000008B               6551  tk_if       equ tk_run+1    * $8B
0000328E  =0000008C               6552  tk_restore  equ tk_if+1     * $8C
0000328E  =0000008D               6553  tk_gosub    equ tk_restore+1    * $8D * GOSUB token
0000328E  =0000008E               6554  tk_return   equ tk_gosub+1  * $8E
0000328E  =0000008F               6555  tk_rem      equ tk_return+1 * $8F * REM token
0000328E  =00000090               6556  tk_stop     equ tk_rem+1    * $90
0000328E  =00000091               6557  tk_on       equ tk_stop+1   * $91 * ON token
0000328E  =00000092               6558  tk_null     equ tk_on+1     * $92
0000328E  =00000093               6559  tk_inc      equ tk_null+1   * $93
0000328E  =00000094               6560  tk_wait     equ tk_inc+1    * $94
0000328E  =00000095               6561  tk_load     equ tk_wait+1   * $95
0000328E  =00000096               6562  tk_save     equ tk_load+1   * $96
0000328E  =00000097               6563  tk_def      equ tk_save+1   * $97
0000328E  =00000098               6564  tk_poke     equ tk_def+1    * $98
0000328E  =00000099               6565  tk_doke     equ tk_poke+1   * $99
0000328E  =0000009A               6566  tk_loke     equ tk_doke+1   * $9A
0000328E  =0000009B               6567  tk_call     equ tk_loke+1   * $9B
0000328E  =0000009C               6568  tk_do       equ tk_call+1   * $9C * DO token
0000328E  =0000009D               6569  tk_loop     equ tk_do+1     * $9D
0000328E  =0000009E               6570  tk_print    equ tk_loop+1   * $9E * PRINT token
0000328E  =0000009F               6571  tk_cont     equ tk_print+1  * $9F
0000328E  =000000A0               6572  tk_list     equ tk_cont+1   * $A0
0000328E  =000000A1               6573  tk_clear    equ tk_list+1   * $A1 * CLEAR token
0000328E  =000000A2               6574  tk_new      equ tk_clear+1  * $A2
0000328E  =000000A3               6575  tk_width    equ tk_new+1    * $A3
0000328E  =000000A4               6576  tk_get      equ tk_width+1  * $A4
0000328E  =000000A5               6577  tk_swap     equ tk_get+1    * $A5
0000328E  =000000A6               6578  tk_bitset   equ tk_swap+1   * $A6
0000328E  =000000A7               6579  tk_bitclr   equ tk_bitset+1 * $A7
0000328E  =000000A8               6580  tk_tab      equ tk_bitclr+1 * $A8 * TAB token
0000328E  =000000A9               6581  tk_to       equ tk_tab+1    * $A9 * TO token
0000328E  =000000AA               6582  tk_fn       equ tk_to+1     * $AA * FN token
0000328E  =000000AB               6583  tk_spc      equ tk_fn+1     * $AB * SPC token
0000328E  =000000AC               6584  tk_then     equ tk_spc+1    * $AC * THEN token
0000328E  =000000AD               6585  tk_not      equ tk_then+1   * $AD * NOT token
0000328E  =000000AE               6586  tk_step     equ tk_not+1    * $AE * STEP token
0000328E  =000000AF               6587  tk_until    equ tk_step+1   * $AF * UNTIL token
0000328E  =000000B0               6588  tk_while    equ tk_until+1  * $B0
0000328E  =000000B1               6589  tk_plus     equ tk_while+1  * $B1 * + token
0000328E  =000000B2               6590  tk_minus    equ tk_plus+1   * $B2 * - token
0000328E  =000000B3               6591  tk_mult     equ tk_minus+1  * $B3
0000328E  =000000B4               6592  tk_div      equ tk_mult+1   * $B4
0000328E  =000000B5               6593  tk_power    equ tk_div+1    * $B5
0000328E  =000000B6               6594  tk_and      equ tk_power+1  * $B6
0000328E  =000000B7               6595  tk_eor      equ tk_and+1    * $B7
0000328E  =000000B8               6596  tk_or       equ tk_eor+1    * $B8
0000328E  =000000B9               6597  tk_rshift   equ tk_or+1     * $B9
0000328E  =000000BA               6598  tk_lshift   equ tk_rshift+1 * $BA
0000328E  =000000BB               6599  tk_gt       equ tk_lshift+1 * $BB * > token
0000328E  =000000BC               6600  tk_equal    equ tk_gt+1     * $BC * = token
0000328E  =000000BD               6601  tk_lt       equ tk_equal+1  * $BD * < token
0000328E  =000000BE               6602  tk_sgn      equ tk_lt+1     * $BE * SGN token
0000328E  =000000BF               6603  tk_int      equ tk_sgn+1    * $BF
0000328E  =000000C0               6604  tk_abs      equ tk_int+1    * $C0
0000328E  =000000C1               6605  tk_usr      equ tk_abs+1    * $C1
0000328E  =000000C2               6606  tk_fre      equ tk_usr+1    * $C2
0000328E  =000000C3               6607  tk_pos      equ tk_fre+1    * $C3
0000328E  =000000C4               6608  tk_sqr      equ tk_pos+1    * $C4
0000328E  =000000C5               6609  tk_rnd      equ tk_sqr+1    * $C5
0000328E  =000000C6               6610  tk_log      equ tk_rnd+1    * $C6
0000328E  =000000C7               6611  tk_exp      equ tk_log+1    * $C7
0000328E  =000000C8               6612  tk_cos      equ tk_exp+1    * $C8
0000328E  =000000C9               6613  tk_sin      equ tk_cos+1    * $C9
0000328E  =000000CA               6614  tk_tan      equ tk_sin+1    * $CA
0000328E  =000000CB               6615  tk_atn      equ tk_tan+1    * $CB
0000328E  =000000CC               6616  tk_peek     equ tk_atn+1    * $CC
0000328E  =000000CD               6617  tk_deek     equ tk_peek+1   * $CD
0000328E  =000000CE               6618  tk_leek     equ tk_deek+1   * $CE
0000328E  =000000CF               6619  tk_sadd     equ tk_leek+1   * $CF
0000328E  =000000D0               6620  tk_len      equ tk_sadd+1   * $D0
0000328E  =000000D1               6621  tk_strs     equ tk_len+1    * $D1
0000328E  =000000D2               6622  tk_val      equ tk_strs+1   * $D2
0000328E  =000000D3               6623  tk_asc      equ tk_val+1    * $D3
0000328E  =000000D4               6624  tk_ucases   equ tk_asc+1    * $D4
0000328E  =000000D5               6625  tk_lcases   equ tk_ucases+1 * $D5
0000328E  =000000D6               6626  tk_chrs     equ tk_lcases+1 * $D6 * CHR$ token
0000328E  =000000D7               6627  tk_hexs     equ tk_chrs+1   * $D7
0000328E  =000000D8               6628  tk_bins     equ tk_hexs+1   * $D8 * BIN$ token
0000328E  =000000D9               6629  tk_bittst   equ tk_bins+1   * $D9
0000328E  =000000DA               6630  tk_max      equ tk_bittst+1 * $DA
0000328E  =000000DB               6631  tk_min      equ tk_max+1    * $DB
0000328E  =000000DC               6632  tk_pi       equ tk_min+1    * $DC
0000328E  =000000DD               6633  tk_twopi    equ tk_pi+1     * $DD
0000328E  =000000DE               6634  tk_vptr     equ tk_twopi+1  * $DE * VARPTR token
0000328E  =000000DF               6635  tk_lefts    equ tk_vptr+1   * $DF
0000328E  =000000E0               6636  tk_rights   equ tk_lefts+1  * $E0
0000328E  =000000E1               6637  tk_mids     equ tk_rights+1 * $E1
0000328E                          6638  
0000328E                          6639  ************************************************************************************
0000328E                          6640  
0000328E                          6641  * binary to unsigned decimal table
0000328E                          6642  
0000328E                          6643  bin2dec
0000328E= 3B9ACA00                6644      dc.l    $3b9aca00       * 1000000000
00003292= 05F5E100                6645      dc.l    $05f5e100       * 100000000
00003296= 00989680                6646      dc.l    $00989680       * 10000000
0000329A= 000F4240                6647      dc.l    $000f4240       * 1000000
0000329E= 000186A0                6648      dc.l    $000186a0       * 100000
000032A2= 00002710                6649      dc.l    $00002710       * 10000
000032A6= 000003E8                6650      dc.l    $000003e8       * 1000
000032AA= 00000064                6651      dc.l    $00000064       * 100
000032AE= 0000000A                6652      dc.l    $0000000a       * 10
000032B2                          6653  lab_1d96
000032B2= 00000000                6654      dc.l    $00000000       * 0 end marker
000032B6                          6655  
000032B6                          6656  lab_rsed
000032B6= 312E3130                6657      dc.l    $312e3130       * 825110832
000032BA                          6658  
000032BA= 00FF                    6659      dc.w    255         * 10**38
000032BC= 96769951                6660      dc.l    $96769951
000032C0= 00FB                    6661      dc.w    251         * 10**37
000032C2= F0BDC21B                6662      dc.l    $f0bdc21b
000032C6= 00F8                    6663      dc.w    248         * 10**36
000032C8= C097CE7C                6664      dc.l    $c097ce7c
000032CC= 00F5                    6665      dc.w    245         * 10**35
000032CE= 9A130B96                6666      dc.l    $9a130b96
000032D2= 00F1                    6667      dc.w    241         * 10**34
000032D4= F684DF57                6668      dc.l    $f684df57
000032D8= 00EE                    6669      dc.w    238         * 10**33
000032DA= C5371912                6670      dc.l    $c5371912
000032DE= 00EB                    6671      dc.w    235         * 10**32
000032E0= 9DC5ADA8                6672      dc.l    $9dc5ada8
000032E4= 00E7                    6673      dc.w    231         * 10**31
000032E6= FC6F7C40                6674      dc.l    $fc6f7c40
000032EA= 00E4                    6675      dc.w    228         * 10**30
000032EC= C9F2C9CD                6676      dc.l    $c9f2c9cd
000032F0= 00E1                    6677      dc.w    225         * 10**29
000032F2= A18F07D7                6678      dc.l    $a18f07d7
000032F6= 00DE                    6679      dc.w    222         * 10**28
000032F8= 813F3979                6680      dc.l    $813f3979
000032FC= 00DA                    6681      dc.w    218         * 10**27
000032FE= CECB8F28                6682      dc.l    $cecb8f28
00003302= 00D7                    6683      dc.w    215         * 10**26
00003304= A56FA5BA                6684      dc.l    $a56fa5ba
00003308= 00D4                    6685      dc.w    212         * 10**25
0000330A= 84595161                6686      dc.l    $84595161
0000330E= 00D0                    6687      dc.w    208         * 10**24
00003310= D3C21BCF                6688      dc.l    $d3c21bcf
00003314= 00CD                    6689      dc.w    205         * 10**23
00003316= A968163F                6690      dc.l    $a968163f
0000331A= 00CA                    6691      dc.w    202         * 10**22
0000331C= 87867832                6692      dc.l    $87867832
00003320= 00C6                    6693      dc.w    198         * 10**21
00003322= D8D726B7                6694      dc.l    $d8d726b7
00003326= 00C3                    6695      dc.w    195         * 10**20
00003328= AD78EBC6                6696      dc.l    $ad78ebc6
0000332C= 00C0                    6697      dc.w    192         * 10**19
0000332E= 8AC72305                6698      dc.l    $8ac72305
00003332= 00BC                    6699      dc.w    188         * 10**18
00003334= DE0B6B3A                6700      dc.l    $de0b6b3a
00003338= 00B9                    6701      dc.w    185         * 10**17
0000333A= B1A2BC2F                6702      dc.l    $b1a2bc2f
0000333E= 00B6                    6703      dc.w    182         * 10**16
00003340= 8E1BC9BF                6704      dc.l    $8e1bc9bf
00003344= 00B2                    6705      dc.w    178         * 10**15
00003346= E35FA932                6706      dc.l    $e35fa932
0000334A= 00AF                    6707      dc.w    175         * 10**14
0000334C= B5E620F5                6708      dc.l    $b5e620f5
00003350= 00AC                    6709      dc.w    172         * 10**13
00003352= 9184E72A                6710      dc.l    $9184e72a
00003356= 00A8                    6711      dc.w    168         * 10**12
00003358= E8D4A510                6712      dc.l    $e8d4a510
0000335C= 00A5                    6713      dc.w    165         * 10**11
0000335E= BA43B740                6714      dc.l    $ba43b740
00003362= 00A2                    6715      dc.w    162         * 10**10
00003364= 9502F900                6716      dc.l    $9502f900
00003368= 009E                    6717      dc.w    158         * 10**9
0000336A= EE6B2800                6718      dc.l    $ee6b2800
0000336E= 009B                    6719      dc.w    155         * 10**8
00003370= BEBC2000                6720      dc.l    $bebc2000
00003374= 0098                    6721      dc.w    152         * 10**7
00003376= 98968000                6722      dc.l    $98968000
0000337A= 0094                    6723      dc.w    148         * 10**6
0000337C= F4240000                6724      dc.l    $f4240000
00003380= 0091                    6725      dc.w    145         * 10**5
00003382= C3500000                6726      dc.l    $c3500000
00003386= 008E                    6727      dc.w    142         * 10**4
00003388= 9C400000                6728      dc.l    $9c400000
0000338C= 008A                    6729      dc.w    138         * 10**3
0000338E= FA000000                6730      dc.l    $fa000000
00003392= 0087                    6731      dc.w    135         * 10**2
00003394= C8000000                6732      dc.l    $c8000000
00003398= 0084                    6733      dc.w    132         * 10**1
0000339A= A0000000                6734      dc.l    $a0000000
0000339E                          6735  lab_p_10
0000339E= 0081                    6736      dc.w    129         * 10**0
000033A0= 80000000                6737      dc.l    $80000000
000033A4= 007D                    6738      dc.w    125         * 10**-1
000033A6= CCCCCCCD                6739      dc.l    $cccccccd
000033AA= 007A                    6740      dc.w    122         * 10**-2
000033AC= A3D70A3D                6741      dc.l    $a3d70a3d
000033B0= 0077                    6742      dc.w    119         * 10**-3
000033B2= 83126E98                6743      dc.l    $83126e98
000033B6= 0073                    6744      dc.w    115         * 10**-4
000033B8= D1B71759                6745      dc.l    $d1b71759
000033BC= 0070                    6746      dc.w    112         * 10**-5
000033BE= A7C5AC47                6747      dc.l    $a7c5ac47
000033C2= 006D                    6748      dc.w    109         * 10**-6
000033C4= 8637BD06                6749      dc.l    $8637bd06
000033C8= 0069                    6750      dc.w    105         * 10**-7
000033CA= D6BF94D6                6751      dc.l    $d6bf94d6
000033CE= 0066                    6752      dc.w    102         * 10**-8
000033D0= ABCC7712                6753      dc.l    $abcc7712
000033D4= 0063                    6754      dc.w    99          * 10**-9
000033D6= 89705F41                6755      dc.l    $89705f41
000033DA= 005F                    6756      dc.w    95          * 10**-10
000033DC= DBE6FECF                6757      dc.l    $dbe6fecf
000033E0= 005C                    6758      dc.w    92          * 10**-11
000033E2= AFEBFF0C                6759      dc.l    $afebff0c
000033E6= 0059                    6760      dc.w    89          * 10**-12
000033E8= 8CBCCC09                6761      dc.l    $8cbccc09
000033EC= 0055                    6762      dc.w    85          * 10**-13
000033EE= E12E1342                6763      dc.l    $e12e1342
000033F2= 0052                    6764      dc.w    82          * 10**-14
000033F4= B424DC35                6765      dc.l    $b424dc35
000033F8= 004F                    6766      dc.w    79          * 10**-15
000033FA= 901D7CF7                6767      dc.l    $901d7cf7
000033FE= 004B                    6768      dc.w    75          * 10**-16
00003400= E69594BF                6769      dc.l    $e69594bf
00003404= 0048                    6770      dc.w    72          * 10**-17
00003406= B877AA32                6771      dc.l    $b877aa32
0000340A= 0045                    6772      dc.w    69          * 10**-18
0000340C= 9392EE8F                6773      dc.l    $9392ee8f
00003410= 0041                    6774      dc.w    65          * 10**-19
00003412= EC1E4A7E                6775      dc.l    $ec1e4a7e
00003416= 003E                    6776      dc.w    62          * 10**-20
00003418= BCE50865                6777      dc.l    $bce50865
0000341C= 003B                    6778      dc.w    59          * 10**-21
0000341E= 971DA050                6779      dc.l    $971da050
00003422= 0037                    6780      dc.w    55          * 10**-22
00003424= F1C90081                6781      dc.l    $f1c90081
00003428= 0034                    6782      dc.w    52          * 10**-23
0000342A= C16D9A01                6783      dc.l    $c16d9a01
0000342E= 0031                    6784      dc.w    49          * 10**-24
00003430= 9ABE14CD                6785      dc.l    $9abe14cd
00003434= 002D                    6786      dc.w    45          * 10**-25
00003436= F79687AE                6787      dc.l    $f79687ae
0000343A= 002A                    6788      dc.w    42          * 10**-26
0000343C= C6120625                6789      dc.l    $c6120625
00003440= 0027                    6790      dc.w    39          * 10**-27
00003442= 9E74D1B8                6791      dc.l    $9e74d1b8
00003446= 0023                    6792      dc.w    35          * 10**-28
00003448= FD87B5F3                6793      dc.l    $fd87b5f3
0000344C= 0020                    6794      dc.w    32          * 10**-29
0000344E= CAD2F7F5                6795      dc.l    $cad2f7f5
00003452= 001D                    6796      dc.w    29          * 10**-30
00003454= A2425FF7                6797      dc.l    $a2425ff7
00003458= 001A                    6798      dc.w    26          * 10**-31
0000345A= 81CEB32C                6799      dc.l    $81ceb32c
0000345E= 0016                    6800      dc.w    22          * 10**-32
00003460= CFB11EAD                6801      dc.l    $cfb11ead
00003464= 0013                    6802      dc.w    19          * 10**-33
00003466= A6274BBE                6803      dc.l    $a6274bbe
0000346A= 0010                    6804      dc.w    16          * 10**-34
0000346C= 84EC3C98                6805      dc.l    $84ec3c98
00003470= 000C                    6806      dc.w    12          * 10**-35
00003472= D4AD2DC0                6807      dc.l    $d4ad2dc0
00003476= 0009                    6808      dc.w    9           * 10**-36
00003478= AA242499                6809      dc.l    $aa242499
0000347C= 0006                    6810      dc.w    6           * 10**-37
0000347E= 881CEA14                6811      dc.l    $881cea14
00003482= 0002                    6812      dc.w    2           * 10**-38
00003484= D9C7DCED                6813      dc.l    $d9c7dced
00003488                          6814  
00003488                          6815  * table of constants for cordic SIN/COS/TAN calculations
00003488                          6816  * constants are un normalised fractions and are atn(2^-i)/2pi
00003488                          6817  
00003488= 4DBA76D4                6818      dc.l    $4dba76d4       * SIN/COS multiply constant
0000348C                          6819  tab_snco
0000348C= 20000000                6820      dc.l    $20000000       * atn(2^0)/2pi
00003490= 12E4051E                6821      dc.l    $12e4051e       * atn(2^1)/2pi
00003494= 09FB385C                6822      dc.l    $09fb385c       * atn(2^2)/2pi
00003498= 051111D5                6823      dc.l    $051111d5       * atn(2^3)/2pi
0000349C= 028B0D44                6824      dc.l    $028b0d44       * atn(2^4)/2pi
000034A0= 0145D7E2                6825      dc.l    $0145d7e2       * atn(2^5)/2pi
000034A4= 00A2F61F                6826      dc.l    $00a2f61f       * atn(2^6)/2pi
000034A8= 00517C56                6827      dc.l    $00517c56       * atn(2^7)/2pi
000034AC= 0028BE54                6828      dc.l    $0028be54       * atn(2^8)/2pi
000034B0= 00145F2F                6829      dc.l    $00145f2f       * atn(2^9)/2pi
000034B4= 000A2F99                6830      dc.l    $000a2f99       * atn(2^10)/2pi
000034B8= 000517CD                6831      dc.l    $000517cd       * atn(2^11)/2pi
000034BC= 00028BE7                6832      dc.l    $00028be7       * atn(2^12)/2pi
000034C0= 000145F4                6833      dc.l    $000145f4       * atn(2^13)/2pi
000034C4= 0000A2FA                6834      dc.l    $0000a2fa       * atn(2^14)/2pi
000034C8= 0000517D                6835      dc.l    $0000517d       * atn(2^15)/2pi
000034CC= 000028BF                6836      dc.l    $000028bf       * atn(2^16)/2pi
000034D0= 00001460                6837      dc.l    $00001460       * atn(2^17)/2pi
000034D4= 00000A30                6838      dc.l    $00000a30       * atn(2^18)/2pi
000034D8= 00000518                6839      dc.l    $00000518       * atn(2^19)/2pi
000034DC= 0000028C                6840      dc.l    $0000028c       * atn(2^20)/2pi
000034E0= 00000146                6841      dc.l    $00000146       * atn(2^21)/2pi
000034E4= 000000A3                6842      dc.l    $000000a3       * atn(2^22)/2pi
000034E8= 00000052                6843      dc.l    $00000052       * atn(2^23)/2pi
000034EC= 00000029                6844      dc.l    $00000029       * atn(2^24)/2pi
000034F0= 00000015                6845      dc.l    $00000015       * atn(2^25)/2pi
000034F4= 0000000B                6846      dc.l    $0000000b       * atn(2^26)/2pi
000034F8= 00000006                6847      dc.l    $00000006       * atn(2^27)/2pi
000034FC= 00000003                6848      dc.l    $00000003       * atn(2^28)/2pi
00003500= 00000002                6849      dc.l    $00000002       * atn(2^29)/2pi
00003504= 00000001                6850      dc.l    $00000001       * atn(2^30)/2pi
00003508= 00000001                6851      dc.l    $00000001       * atn(2^31)/2pi
0000350C                          6852  
0000350C                          6853  * table of constants for cordic ATN calculation
0000350C                          6854  * constants are normalised to two integer bits and are atn(2^-i)
0000350C                          6855  
0000350C                          6856  *   dc.l    $3243f6a9       * atn(2^0) (not used)
0000350C                          6857  tab_atnc
0000350C= 1DAC6705                6858      dc.l    $1dac6705       * atn(2^-1)
00003510= 0FADBAFD                6859      dc.l    $0fadbafd       * atn(2^-2)
00003514= 07F56EA7                6860      dc.l    $07f56ea7       * atn(2^-3)
00003518= 03FEAB77                6861      dc.l    $03feab77       * atn(2^-4)
0000351C= 01FFD55C                6862      dc.l    $01ffd55c       * atn(2^-5)
00003520= 00FFFAAB                6863      dc.l    $00fffaab       * atn(2^-6)
00003524= 007FFF55                6864      dc.l    $007fff55       * atn(2^-7)
00003528= 003FFFEB                6865      dc.l    $003fffeb       * atn(2^-8)
0000352C= 001FFFFD                6866      dc.l    $001ffffd       * atn(2^-9)
00003530= 00100000                6867      dc.l    $00100000       * atn(2^-10)
00003534= 00080000                6868      dc.l    $00080000       * atn(2^-11)
00003538= 00040000                6869      dc.l    $00040000       * atn(2^-12)
0000353C= 00020000                6870      dc.l    $00020000       * atn(2^-13)
00003540= 00010000                6871      dc.l    $00010000       * atn(2^-14)
00003544= 00008000                6872      dc.l    $00008000       * atn(2^-15)
00003548= 00004000                6873      dc.l    $00004000       * atn(2^-16)
0000354C= 00002000                6874      dc.l    $00002000       * atn(2^-17)
00003550= 00001000                6875      dc.l    $00001000       * atn(2^-18)
00003554= 00000800                6876      dc.l    $00000800       * atn(2^-19)
00003558= 00000400                6877      dc.l    $00000400       * atn(2^-20)
0000355C= 00000200                6878      dc.l    $00000200       * atn(2^-21)
00003560= 00000100                6879      dc.l    $00000100       * atn(2^-22)
00003564= 00000080                6880      dc.l    $00000080       * atn(2^-23)
00003568= 00000040                6881      dc.l    $00000040       * atn(2^-24)
0000356C= 00000020                6882      dc.l    $00000020       * atn(2^-25)
00003570= 00000010                6883      dc.l    $00000010       * atn(2^-26)
00003574= 00000008                6884      dc.l    $00000008       * atn(2^-27)
00003578= 00000004                6885      dc.l    $00000004       * atn(2^-28)
0000357C= 00000002                6886      dc.l    $00000002       * atn(2^-29)
00003580= 00000001                6887      dc.l    $00000001       * atn(2^-30)
00003584= 00000000                6888      dc.l    $00000000       * atn(2^-31)
00003588= 00000000                6889      dc.l    $00000000       * atn(2^-32)
0000358C                          6890  
0000358C                          6891  * constants are normalised to n integer bits and are tanh(2^-i)
0000358C  =00000002               6892  n     equ   2
0000358C                          6893  tab_hthet
0000358C= 2327D4F4                6894      dc.l    $8c9f53d0>>n        * atnh(2^-1)   .549306144
00003590= 1058AEFA                6895      dc.l    $4162bbe8>>n        * atnh(2^-2)   .255412812
00003594= 080AC48E                6896      dc.l    $202b1238>>n        * atnh(2^-3)
00003598= 04015622                6897      dc.l    $10055888>>n        * atnh(2^-4)
0000359C= 02002AB0                6898      dc.l    $0800aac0>>n        * atnh(2^-5)
000035A0= 01000554                6899      dc.l    $04001550>>n        * atnh(2^-6)
000035A4= 008000AA                6900      dc.l    $020002a8>>n        * atnh(2^-7)
000035A8= 00400014                6901      dc.l    $01000050>>n        * atnh(2^-8)
000035AC= 00200002                6902      dc.l    $00800008>>n        * atnh(2^-9)
000035B0= 00100000                6903      dc.l    $00400000>>n        * atnh(2^-10)
000035B4= 00080000                6904      dc.l    $00200000>>n        * atnh(2^-11)
000035B8= 00040000                6905      dc.l    $00100000>>n        * atnh(2^-12)
000035BC= 00020000                6906      dc.l    $00080000>>n        * atnh(2^-13)
000035C0= 00010000                6907      dc.l    $00040000>>n        * atnh(2^-14)
000035C4= 00008000                6908      dc.l    $00020000>>n        * atnh(2^-15)
000035C8= 00004000                6909      dc.l    $00010000>>n        * atnh(2^-16)
000035CC= 00002000                6910      dc.l    $00008000>>n        * atnh(2^-17)
000035D0= 00001000                6911      dc.l    $00004000>>n        * atnh(2^-18)
000035D4= 00000800                6912      dc.l    $00002000>>n        * atnh(2^-19)
000035D8= 00000400                6913      dc.l    $00001000>>n        * atnh(2^-20)
000035DC= 00000200                6914      dc.l    $00000800>>n        * atnh(2^-21)
000035E0= 00000100                6915      dc.l    $00000400>>n        * atnh(2^-22)
000035E4= 00000080                6916      dc.l    $00000200>>n        * atnh(2^-23)
000035E8= 00000040                6917      dc.l    $00000100>>n        * atnh(2^-24)
000035EC= 00000020                6918      dc.l    $00000080>>n        * atnh(2^-25)
000035F0= 00000010                6919      dc.l    $00000040>>n        * atnh(2^-26)
000035F4= 00000008                6920      dc.l    $00000020>>n        * atnh(2^-27)
000035F8= 00000004                6921      dc.l    $00000010>>n        * atnh(2^-28)
000035FC= 00000002                6922      dc.l    $00000008>>n        * atnh(2^-29)
00003600= 00000001                6923      dc.l    $00000004>>n        * atnh(2^-30)
00003604= 00000000                6924      dc.l    $00000002>>n        * atnh(2^-31)
00003608= 00000000                6925      dc.l    $00000001>>n        * atnh(2^-32)
0000360C                          6926  
0000360C  =26A3D110               6927  kfctseed    equ   $9a8f4441>>n      * $26A3D110
0000360C                          6928  
0000360C                          6929  * command vector table
0000360C                          6930  
0000360C                          6931  lab_ctbl
0000360C= 00000C58                6932      dc.l    lab_end         * END
00003610= 00000B76                6933      dc.l    lab_for         * FOR
00003614= 0000125E                6934      dc.l    lab_next        * NEXT
00003618= 00000DF0                6935      dc.l    lab_data        * DATA
0000361C= 0000112E                6936      dc.l    lab_input       * INPUT
00003620= 000016AC                6937      dc.l    lab_dim         * DIM
00003624= 00001158                6938      dc.l    lab_read        * READ
00003628= 00000F24                6939      dc.l    lab_let         * LET
0000362C= 00000EB4                6940      dc.l    lab_dec         * DEC
00003630= 00000D3C                6941      dc.l    lab_goto        * GOTO
00003634= 00000CF2                6942      dc.l    lab_run         * RUN
00003638= 00000E1A                6943      dc.l    lab_if          * IF
0000363C= 00000C8C                6944      dc.l    lab_restore     * RESTORE
00003640= 00000D1E                6945      dc.l    lab_gosub       * GOSUB
00003644= 00000DD6                6946      dc.l    lab_return      * RETURN
00003648= 00000E38                6947      dc.l    lab_rem         * REM
0000364C= 00000C56                6948      dc.l    lab_stop        * STOP
00003650= 00000E40                6949      dc.l    lab_on          * ON
00003654= 00000CCA                6950      dc.l    lab_null        * NULL
00003658= 00000EBA                6951      dc.l    lab_inc         * INC
0000365C= 0000209A                6952      dc.l    lab_wait        * WAIT
00003660= 00040418                6953      dc.l    v_load          * LOAD
00003664= 0004041E                6954      dc.l    v_save          * SAVE
00003668= 00001AD2                6955      dc.l    lab_def         * DEF
0000366C= 00002008                6956      dc.l    lab_poke        * POKE
00003670= 00002038                6957      dc.l    lab_doke        * DOKE
00003674= 0000203E                6958      dc.l    lab_loke        * LOKE
00003678= 0000208A                6959      dc.l    lab_call        * CALL
0000367C= 00000D0A                6960      dc.l    lab_do          * DO
00003680= 00000D78                6961      dc.l    lab_loop        * LOOP
00003684= 00000FCE                6962      dc.l    lab_print       * PRINT
00003688= 00000CD6                6963      dc.l    lab_cont        * CONT
0000368C= 00000ABC                6964      dc.l    lab_list        * LIST
00003690= 00000AB8                6965      dc.l    lab_clear       * CLEAR
00003694= 00000A52                6966      dc.l    lab_new         * NEW
00003698= 00002EFE                6967      dc.l    lab_wdth        * WIDTH
0000369C= 00000F90                6968      dc.l    lab_get         * GET
000036A0= 00002052                6969      dc.l    lab_swap        * SWAP
000036A4= 00002D3C                6970      dc.l    lab_bitset      * BITSET
000036A8= 00002D54                6971      dc.l    lab_bitclr      * BITCLR
000036AC                          6972  
000036AC                          6973  * action addresses for functions
000036AC                          6974  
000036AC                          6975  lab_ftxx
000036AC  =000035B4               6976  lab_ftbl equ    lab_ftxx-(tk_sgn-$80)*4 * offset for table start
000036AC                          6977  
000036AC= 00002598                6978      dc.l    lab_sgn         * SGN()
000036B0= 0000263E                6979      dc.l    lab_int         * INT()
000036B4= 000025AE                6980      dc.l    lab_abs         * ABS()
000036B8= 00040406                6981      dc.l    usrjmp          * USR()
000036BC= 00001A78                6982      dc.l    lab_fre         * FRE()
000036C0= 00001AB6                6983      dc.l    lab_pos         * POS()
000036C4= 00002F9A                6984      dc.l    lab_sqr         * SQR()
000036C8= 00002AEA                6985      dc.l    lab_rnd         * RND()
000036CC= 000021C2                6986      dc.l    lab_log         * LOG()
000036D0= 0000299C                6987      dc.l    lab_exp         * EXP()
000036D4= 00002B66                6988      dc.l    lab_cos         * COS()
000036D8= 00002B86                6989      dc.l    lab_sin         * SIN()
000036DC= 00002B34                6990      dc.l    lab_tan         * TAN()
000036E0= 00002C7A                6991      dc.l    lab_atn         * ATN()
000036E4= 00001FFC                6992      dc.l    lab_peek        * PEEK()
000036E8= 0000200E                6993      dc.l    lab_deek        * DEEK()
000036EC= 00002024                6994      dc.l    lab_leek        * LEEK()
000036F0= 00001F2A                6995      dc.l    lab_sadd        * SADD()
000036F4= 00001F34                6996      dc.l    lab_lens        * LEN()
000036F8= 00001BDC                6997      dc.l    lab_strs        * STR$()
000036FC= 00001F7E                6998      dc.l    lab_val         * VAL()
00003700= 00001F3C                6999      dc.l    lab_asc         * ASC()
00003704= 00001F02                7000      dc.l    lab_ucase       * UCASE$()
00003708= 00001EDE                7001      dc.l    lab_lcase       * LCASE$()
0000370C= 00001E40                7002      dc.l    lab_chrs        * CHR$()
00003710= 00002DFC                7003      dc.l    lab_hexs        * HEX$()
00003714= 00002D9C                7004      dc.l    lab_bins        * BIN$()
00003718= 00002D6C                7005      dc.l    lab_btst        * BITTST()
0000371C= 00002E84                7006      dc.l    lab_max         * MAX()
00003720= 00002E96                7007      dc.l    lab_min         * MIN()
00003724= 00003020                7008      dc.l    lab_pi          * PI
00003728= 0000303C                7009      dc.l    lab_twopi       * TWOPI
0000372C= 0000300A                7010      dc.l    lab_varptr      * VARPTR()
00003730= 00001E52                7011      dc.l    lab_left        * LEFT$()
00003734= 00001E64                7012      dc.l    lab_right       * RIGHT$()
00003738= 00001E90                7013      dc.l    lab_mids        * MID$()
0000373C                          7014  
0000373C                          7015  * hierarchy and action addresses for operator
0000373C                          7016  
0000373C                          7017  lab_oppt
0000373C= 0079                    7018      dc.w    $0079           * +
0000373E= 000020E6                7019      dc.l    lab_add
00003742= 0079                    7020      dc.w    $0079           * -
00003744= 000020BE                7021      dc.l    lab_subtract
00003748= 007B                    7022      dc.w    $007b           * *
0000374A= 000022E6                7023      dc.l    lab_multiply
0000374E= 007B                    7024      dc.w    $007b           * /
00003750= 000023FC                7025      dc.l    lab_divide
00003754= 007F                    7026      dc.w    $007f           * ^
00003756= 000028B6                7027      dc.l    lab_power
0000375A= 0050                    7028      dc.w    $0050           * AND
0000375C= 0000161C                7029      dc.l    lab_and
00003760= 0046                    7030      dc.w    $0046           * EOR
00003762= 00001602                7031      dc.l    lab_eor
00003766= 0046                    7032      dc.w    $0046           * OR
00003768= 00001614                7033      dc.l    lab_or
0000376C= 0056                    7034      dc.w    $0056           * >>
0000376E= 000016C8                7035      dc.l    lab_rshift
00003772= 0056                    7036      dc.w    $0056           * <<
00003774= 000016B8                7037      dc.l    lab_lshift
00003778= 007D                    7038      dc.w    $007d           * >
0000377A= 0000293E                7039      dc.l    lab_gthan       * used to evaluate -n
0000377E= 005A                    7040      dc.w    $005a           * =
00003780= 00001634                7041      dc.l    lab_equal       * used to evaluate NOT
00003784= 0064                    7042      dc.w    $0064           * <
00003786= 0000163E                7043      dc.l    lab_lthan
0000378A                          7044  
0000378A                          7045                      * numeric PRINT constants
0000378A                          7046  lab_2947
0000378A= 91434FF8                7047      dc.l    $91434ff8       * 99999.9375 (max value with at least one decimal)
0000378E                          7048  lab_294b
0000378E= 947423F7                7049      dc.l    $947423f7       * 999999.4375 (max value before sci notation)
00003792                          7050                      * misc constants
00003792                          7051  
00003792                          7052  lab_259c
00003792= 81000000                7053      dc.l    $81000000       * 1.000000, used for ATN
00003796                          7054  lab_2a96
00003796= 80000000                7055      dc.l    $80000000       * 0.5, used for float rounding
0000379A                          7056  
0000379A                          7057  * This table is used in converting numbers to ASCII.
0000379A                          7058  * first four entries for expansion to 9.25 digits
0000379A                          7059  
0000379A                          7060  *   dc.l    $c4653600       * -1000000000
0000379A                          7061  *   dc.l    $05f5e100       * 100000000
0000379A                          7062  *   dc.l    $ff676980       * -10000000
0000379A                          7063  *   dc.l    $000f4240       * 1000000
0000379A                          7064  lab_2a9a
0000379A= FFFE7960                7065      dc.l    $fffe7960       * -100000
0000379E= 00002710                7066      dc.l    $00002710       * 10000
000037A2= FFFFFC18                7067      dc.l    $fffffc18       * -1000
000037A6= 00000064                7068      dc.l    $00000064       * 100
000037AA= FFFFFFF6                7069      dc.l    $fffffff6       * -10
000037AE= 00000001                7070      dc.l    $00000001       * 1
000037B2                          7071  
000037B2                          7072  * new keyword tables
000037B2                          7073  
000037B2                          7074  * offsets to keyword tables
000037B2                          7075  
000037B2                          7076  tab_chrt
000037B2= 0000                    7077      dc.w    tab_star-tab_star   * "*" $2A
000037B4= 0002                    7078      dc.w    tab_plus-tab_star   * "+" $2B
000037B6= FFFF                    7079      dc.w    -1          * "," $2C no keywords
000037B8= 0004                    7080      dc.w    tab_mnus-tab_star   * "-" $2D
000037BA= FFFF                    7081      dc.w    -1          * "." $2E no keywords
000037BC= 0006                    7082      dc.w    tab_slas-tab_star   * "/" $2F
000037BE= FFFF                    7083      dc.w    -1          * "0" $30 no keywords
000037C0= FFFF                    7084      dc.w    -1          * "1" $31 no keywords
000037C2= FFFF                    7085      dc.w    -1          * "2" $32 no keywords
000037C4= FFFF                    7086      dc.w    -1          * "3" $33 no keywords
000037C6= FFFF                    7087      dc.w    -1          * "4" $34 no keywords
000037C8= FFFF                    7088      dc.w    -1          * "5" $35 no keywords
000037CA= FFFF                    7089      dc.w    -1          * "6" $36 no keywords
000037CC= FFFF                    7090      dc.w    -1          * "7" $37 no keywords
000037CE= FFFF                    7091      dc.w    -1          * "8" $38 no keywords
000037D0= FFFF                    7092      dc.w    -1          * "9" $39 no keywords
000037D2= FFFF                    7093      dc.w    -1          * ";" $3A no keywords
000037D4= FFFF                    7094      dc.w    -1          * ":" $3B no keywords
000037D6= 0008                    7095      dc.w    tab_less-tab_star   * "<" $3C
000037D8= 000C                    7096      dc.w    tab_equl-tab_star   * "=" $3D
000037DA= 000E                    7097      dc.w    tab_more-tab_star   * ">" $3E
000037DC= 0012                    7098      dc.w    tab_qest-tab_star   * "?" $3F
000037DE= FFFF                    7099      dc.w    -1          * "@" $40 no keywords
000037E0= 0014                    7100      dc.w    tab_asca-tab_star   * "A" $41
000037E2= 0021                    7101      dc.w    tab_ascb-tab_star   * "B" $42
000037E4= 0038                    7102      dc.w    tab_ascc-tab_star   * "C" $43
000037E6= 004D                    7103      dc.w    tab_ascd-tab_star   * "D" $44
000037E8= 0065                    7104      dc.w    tab_asce-tab_star   * "E" $45
000037EA= 006F                    7105      dc.w    tab_ascf-tab_star   * "F" $46
000037EC= 0078                    7106      dc.w    tab_ascg-tab_star   * "G" $47
000037EE= 0085                    7107      dc.w    tab_asch-tab_star   * "H" $48
000037F0= 008A                    7108      dc.w    tab_asci-tab_star   * "I" $49
000037F2= FFFF                    7109      dc.w    -1          * "J" $4A no keywords
000037F4= FFFF                    7110      dc.w    -1          * "K" $4B no keywords
000037F6= 0098                    7111      dc.w    tab_ascl-tab_star   * "L" $4C
000037F8= 00C1                    7112      dc.w    tab_ascm-tab_star   * "M" $4D
000037FA= 00CC                    7113      dc.w    tab_ascn-tab_star   * "N" $4E
000037FC= 00DB                    7114      dc.w    tab_asco-tab_star   * "O" $4F
000037FE= 00E0                    7115      dc.w    tab_ascp-tab_star   * "P" $50
00003800= FFFF                    7116      dc.w    -1          * "Q" $51 no keywords
00003802= 00F3                    7117      dc.w    tab_ascr-tab_star   * "R" $52
00003804= 0114                    7118      dc.w    tab_ascs-tab_star   * "S" $53
00003806= 013A                    7119      dc.w    tab_asct-tab_star   * "T" $54
00003808= 014D                    7120      dc.w    tab_ascu-tab_star   * "U" $55
0000380A= 015C                    7121      dc.w    tab_ascv-tab_star   * "V" $56
0000380C= 0166                    7122      dc.w    tab_ascw-tab_star   * "W" $57
0000380E= FFFF                    7123      dc.w    -1          * "X" $58 no keywords
00003810= FFFF                    7124      dc.w    -1          * "Y" $59 no keywords
00003812= FFFF                    7125      dc.w    -1          * "Z" $5A no keywords
00003814= FFFF                    7126      dc.w    -1          * "[" $5B no keywords
00003816= FFFF                    7127      dc.w    -1          * "\" $5C no keywords
00003818= FFFF                    7128      dc.w    -1          * "]" $5D no keywords
0000381A= 0175                    7129      dc.w    tab_powr-tab_star   * "^" $5E
0000381C                          7130  
0000381C                          7131  * Table of Basic keywords for LIST command
0000381C                          7132  * [byte]first character,[byte]remaining length -1
0000381C                          7133  * [word]offset from table start
0000381C                          7134  
0000381C                          7135  lab_keyt
0000381C= 45 01                   7136      dc.b    'E',1
0000381E= 0065                    7137      dc.w    key_end-tab_star    * END
00003820= 46 01                   7138      dc.b    'F',1
00003822= 006F                    7139      dc.w    key_for-tab_star    * FOR
00003824= 4E 02                   7140      dc.b    'N',2
00003826= 00CF                    7141      dc.w    key_next-tab_star   * NEXT
00003828= 44 02                   7142      dc.b    'D',2
0000382A= 004D                    7143      dc.w    key_data-tab_star   * DATA
0000382C= 49 03                   7144      dc.b    'I',3
0000382E= 008F                    7145      dc.w    key_input-tab_star  * INPUT
00003830= 44 01                   7146      dc.b    'D',1
00003832= 005B                    7147      dc.w    key_dim-tab_star    * DIM
00003834= 52 02                   7148      dc.b    'R',2
00003836= 00F3                    7149      dc.w    key_read-tab_star   * READ
00003838= 4C 01                   7150      dc.b    'L',1
0000383A= 00AA                    7151      dc.w    key_let-tab_star    * LET
0000383C= 44 01                   7152      dc.b    'D',1
0000383E= 0051                    7153      dc.w    key_dec-tab_star    * DEC
00003840= 47 02                   7154      dc.b    'G',2
00003842= 007B                    7155      dc.w    key_goto-tab_star   * GOTO
00003844= 52 01                   7156      dc.b    'R',1
00003846= 0110                    7157      dc.w    key_run-tab_star    * RUN
00003848= 49 00                   7158      dc.b    'I',0
0000384A= 008A                    7159      dc.w    key_if-tab_star     * IF
0000384C= 52 05                   7160      dc.b    'R',5
0000384E= 00FA                    7161      dc.w    key_restore-tab_star    * RESTORE
00003850= 47 03                   7162      dc.b    'G',3
00003852= 007F                    7163      dc.w    key_gosub-tab_star  * GOSUB
00003854= 52 04                   7164      dc.b    'R',4
00003856= 0101                    7165      dc.w    key_return-tab_star * RETURN
00003858= 52 01                   7166      dc.b    'R',1
0000385A= 00F7                    7167      dc.w    key_rem-tab_star    * REM
0000385C= 53 02                   7168      dc.b    'S',2
0000385E= 012D                    7169      dc.w    key_stop-tab_star   * STOP
00003860= 4F 00                   7170      dc.b    'O',0
00003862= 00DB                    7171      dc.w    key_on-tab_star     * ON
00003864= 4E 02                   7172      dc.b    'N',2
00003866= 00D6                    7173      dc.w    key_null-tab_star   * NULL
00003868= 49 01                   7174      dc.b    'I',1
0000386A= 008C                    7175      dc.w    key_inc-tab_star    * INC
0000386C= 57 02                   7176      dc.b    'W',2
0000386E= 0166                    7177      dc.w    key_wait-tab_star   * WAIT
00003870= 4C 02                   7178      dc.b    'L',2
00003872= 00B1                    7179      dc.w    key_load-tab_star   * LOAD
00003874= 53 02                   7180      dc.b    'S',2
00003876= 0118                    7181      dc.w    key_save-tab_star   * SAVE
00003878= 44 01                   7182      dc.b    'D',1
0000387A= 0058                    7183      dc.w    key_def-tab_star    * DEF
0000387C= 50 02                   7184      dc.b    'P',2
0000387E= 00E6                    7185      dc.w    key_poke-tab_star   * POKE
00003880= 44 02                   7186      dc.b    'D',2
00003882= 005E                    7187      dc.w    key_doke-tab_star   * DOKE
00003884= 4C 02                   7188      dc.b    'L',2
00003886= 00B8                    7189      dc.w    key_loke-tab_star   * LOKE
00003888= 43 02                   7190      dc.b    'C',2
0000388A= 0038                    7191      dc.w    key_call-tab_star   * CALL
0000388C= 44 00                   7192      dc.b    'D',0
0000388E= 0062                    7193      dc.w    key_do-tab_star     * DO
00003890= 4C 02                   7194      dc.b    'L',2
00003892= 00BC                    7195      dc.w    key_loop-tab_star   * LOOP
00003894= 50 03                   7196      dc.b    'P',3
00003896= 00ED                    7197      dc.w    key_print-tab_star  * PRINT
00003898= 43 02                   7198      dc.b    'C',2
0000389A= 0045                    7199      dc.w    key_cont-tab_star   * CONT
0000389C= 4C 02                   7200      dc.b    'L',2
0000389E= 00AD                    7201      dc.w    key_list-tab_star   * LIST
000038A0= 43 03                   7202      dc.b    'C',3
000038A2= 0040                    7203      dc.w    key_clear-tab_star  * CLEAR
000038A4= 4E 01                   7204      dc.b    'N',1
000038A6= 00CC                    7205      dc.w    key_new-tab_star    * NEW
000038A8= 57 03                   7206      dc.b    'W',3
000038AA= 016F                    7207      dc.w    key_width-tab_star  * WIDTH
000038AC= 47 01                   7208      dc.b    'G',1
000038AE= 0078                    7209      dc.w    key_get-tab_star    * GET
000038B0= 53 03                   7210      dc.b    'S',3
000038B2= 0135                    7211      dc.w    key_swap-tab_star   * SWAP
000038B4= 42 04                   7212      dc.b    'B',4
000038B6= 002B                    7213      dc.w    key_bitset-tab_star * BITSET
000038B8= 42 04                   7214      dc.b    'B',4
000038BA= 0025                    7215      dc.w    key_bitclr-tab_star * BITCLR
000038BC= 54 02                   7216      dc.b    'T',2
000038BE= 013A                    7217      dc.w    key_tab-tab_star    * TAB(
000038C0                          7218  
000038C0= 54 00                   7219      dc.b    'T',0
000038C2= 0145                    7220      dc.w    key_to-tab_star     * TO
000038C4= 46 00                   7221      dc.b    'F',0
000038C6= 0072                    7222      dc.w    key_fn-tab_star     * FN
000038C8= 53 02                   7223      dc.b    'S',2
000038CA= 0122                    7224      dc.w    key_spc-tab_star    * SPC(
000038CC= 54 02                   7225      dc.b    'T',2
000038CE= 0141                    7226      dc.w    key_then-tab_star   * THEN
000038D0= 4E 01                   7227      dc.b    'N',1
000038D2= 00D3                    7228      dc.w    key_not-tab_star    * NOT
000038D4= 53 02                   7229      dc.b    'S',2
000038D6= 0129                    7230      dc.w    key_step-tab_star   * STEP
000038D8= 55 03                   7231      dc.b    'U',3
000038DA= 0153                    7232      dc.w    key_until-tab_star  * UNTIL
000038DC= 57 03                   7233      dc.b    'W',3
000038DE= 016A                    7234      dc.w    key_while-tab_star  * WHILE
000038E0                          7235  
000038E0= 2B FF                   7236      dc.b    '+',-1
000038E2= 0002                    7237      dc.w    key_plus-tab_star   * +
000038E4= 2D FF                   7238      dc.b    '-',-1
000038E6= 0004                    7239      dc.w    key_minus-tab_star  * -
000038E8= 2A FF                   7240        dc.b  '*',-1
000038EA= 0000                    7241      dc.w    key_mult-tab_star   * *
000038EC= 2F FF                   7242      dc.b    '/',-1
000038EE= 0006                    7243      dc.w    key_div-tab_star    * /
000038F0= 5E FF                   7244      dc.b    '^',-1
000038F2= 0175                    7245      dc.w    key_power-tab_star  * ^
000038F4= 41 01                   7246      dc.b    'A',1
000038F6= 0017                    7247      dc.w    key_and-tab_star    * AND
000038F8= 45 01                   7248      dc.b    'E',1
000038FA= 0068                    7249      dc.w    key_eor-tab_star    * EOR
000038FC= 4F 00                   7250      dc.b    'O',0
000038FE= 00DD                    7251      dc.w    key_or-tab_star     * OR
00003900= 3E 00                   7252      dc.b    '>',0
00003902= 000E                    7253      dc.w    key_rshift-tab_star * >>
00003904= 3C 00                   7254      dc.b    '<',0
00003906= 0008                    7255      dc.w    key_lshift-tab_star * <<
00003908= 3E FF                   7256      dc.b    '>',-1
0000390A= 0010                    7257      dc.w    key_gt-tab_star     * >
0000390C= 3D FF                   7258      dc.b    '=',-1
0000390E= 000C                    7259      dc.w    key_equal-tab_star  * =
00003910= 3C FF                   7260      dc.b    '<',-1
00003912= 000A                    7261      dc.w    key_lt-tab_star     * <
00003914                          7262  
00003914= 53 01                   7263      dc.b    'S',1
00003916= 011C                    7264      dc.w    key_sgn-tab_star    * SGN
00003918= 49 01                   7265      dc.b    'I',1
0000391A= 0094                    7266      dc.w    key_int-tab_star    * INT
0000391C= 41 01                   7267      dc.b    'A',1
0000391E= 0014                    7268      dc.w    key_abs-tab_star    * ABS
00003920= 55 01                   7269      dc.b    'U',1
00003922= 0158                    7270      dc.w    key_usr-tab_star    * USR
00003924= 46 01                   7271      dc.b    'F',1
00003926= 0074                    7272      dc.w    key_fre-tab_star    * FRE
00003928= 50 01                   7273      dc.b    'P',1
0000392A= 00EA                    7274      dc.w    key_pos-tab_star    * POS
0000392C= 53 01                   7275      dc.b    'S',1
0000392E= 0126                    7276      dc.w    key_sqr-tab_star    * SQR
00003930= 52 01                   7277      dc.b    'R',1
00003932= 010D                    7278      dc.w    key_rnd-tab_star    * RND
00003934= 4C 01                   7279      dc.b    'L',1
00003936= 00B5                    7280      dc.w    key_log-tab_star    * LOG
00003938= 45 01                   7281      dc.b    'E',1
0000393A= 006B                    7282      dc.w    key_exp-tab_star    * EXP
0000393C= 43 01                   7283      dc.b    'C',1
0000393E= 0049                    7284      dc.w    key_cos-tab_star    * COS
00003940= 53 01                   7285      dc.b    'S',1
00003942= 011F                    7286      dc.w    key_sin-tab_star    * SIN
00003944= 54 01                   7287      dc.b    'T',1
00003946= 013E                    7288      dc.w    key_tan-tab_star    * TAN
00003948= 41 01                   7289      dc.b    'A',1
0000394A= 001D                    7290      dc.w    key_atn-tab_star    * ATN
0000394C= 50 02                   7291      dc.b    'P',2
0000394E= 00E0                    7292      dc.w    key_peek-tab_star   * PEEK
00003950= 44 02                   7293      dc.b    'D',2
00003952= 0054                    7294      dc.w    key_deek-tab_star   * DEEK
00003954= 4C 02                   7295      dc.b    'L',2
00003956= 009E                    7296      dc.w    key_leek-tab_star   * LEEK
00003958= 53 02                   7297      dc.b    'S',2
0000395A= 0114                    7298      dc.w    key_sadd-tab_star   * SADD
0000395C= 4C 01                   7299      dc.b    'L',1
0000395E= 00A7                    7300      dc.w    key_len-tab_star    * LEN
00003960= 53 02                   7301      dc.b    'S',2
00003962= 0131                    7302      dc.w    key_strs-tab_star   * STR$
00003964= 56 01                   7303      dc.b    'V',1
00003966= 015C                    7304      dc.w    key_val-tab_star    * VAL
00003968= 41 01                   7305      dc.b    'A',1
0000396A= 001A                    7306      dc.w    key_asc-tab_star    * ASC
0000396C= 55 04                   7307      dc.b    'U',4
0000396E= 014D                    7308      dc.w    key_ucases-tab_star * UCASE$
00003970= 4C 04                   7309      dc.b    'L',4
00003972= 0098                    7310      dc.w    key_lcases-tab_star * LCASE$
00003974= 43 02                   7311      dc.b    'C',2
00003976= 003C                    7312      dc.w    key_chrs-tab_star   * CHR$
00003978= 48 02                   7313      dc.b    'H',2
0000397A= 0085                    7314      dc.w    key_hexs-tab_star   * HEX$
0000397C= 42 02                   7315      dc.b    'B',2
0000397E= 0021                    7316      dc.w    key_bins-tab_star   * BIN$
00003980= 42 04                   7317      dc.b    'B',4
00003982= 0031                    7318      dc.w    key_bittst-tab_star * BITTST
00003984= 4D 01                   7319      dc.b    'M',1
00003986= 00C1                    7320      dc.w    key_max-tab_star    * MAX
00003988= 4D 01                   7321      dc.b    'M',1
0000398A= 00C8                    7322      dc.w    key_min-tab_star    * MIN
0000398C= 50 00                   7323      dc.b    'P',0
0000398E= 00E4                    7324      dc.w    key_pi-tab_star     * PI
00003990= 54 03                   7325      dc.b    'T',3
00003992= 0147                    7326      dc.w    key_twopi-tab_star  * TWOPI
00003994= 56 04                   7327      dc.b    'V',4
00003996= 015F                    7328      dc.w    key_vptr-tab_star   * VARPTR
00003998= 4C 03                   7329      dc.b    'L',3
0000399A= 00A2                    7330      dc.w    key_lefts-tab_star  * LEFT$
0000399C= 52 04                   7331      dc.b    'R',4
0000399E= 0107                    7332      dc.w    key_rights-tab_star * RIGHT$
000039A0= 4D 02                   7333      dc.b    'M',2
000039A2= 00C4                    7334      dc.w    key_mids-tab_star   * MID$
000039A4                          7335  
000039A4                          7336  * BASIC error messages
000039A4                          7337  
000039A4                          7338  lab_baer
000039A4= 000039FC                7339      dc.l    lab_nf          * $00 NEXT without FOR
000039A8= 00003A0D                7340      dc.l    lab_sn          * $04 syntax
000039AC= 00003A14                7341      dc.l    lab_rg          * $08 RETURN without GOSUB
000039B0= 00003A29                7342      dc.l    lab_od          * $0C out of data
000039B4= 00003A35                7343      dc.l    lab_fc          * $10 function call
000039B8= 00003A43                7344      dc.l    lab_ov          * $14 overflow
000039BC= 00003A4C                7345      dc.l    lab_om          * $18 out of memory
000039C0= 00003A5A                7346      dc.l    lab_us          * $1C undefined statement
000039C4= 00003A6E                7347      dc.l    lab_bs          * $20 array bounds
000039C8= 00003A7B                7348      dc.l    lab_dd          * $24 double dimension array
000039CC= 00003A8C                7349      dc.l    lab_d0          * $28 divide by 0
000039D0= 00003A9B                7350      dc.l    lab_id          * $2C illegal direct
000039D4= 00003AAA                7351      dc.l    lab_tm          * $30 type mismatch
000039D8= 00003AB8                7352      dc.l    lab_ls          * $34 long string
000039DC= 00003AC8                7353      dc.l    lab_st          * $38 string too complex
000039E0= 00003ADB                7354      dc.l    lab_cn          * $3C continue error
000039E4= 00003AEA                7355      dc.l    lab_uf          * $40 undefined function
000039E8= 00003AFD                7356      dc.l    lab_ld          * $44 LOOP without DO
000039EC= 00003B0D                7357      dc.l    lab_uv          * $48 undefined variable
000039F0= 00003B20                7358      dc.l    lab_ua          * $4C undimensioned array
000039F4= 00003B34                7359      dc.l    lab_wd          * $50 wrong dimensions
000039F8= 00003B45                7360      dc.l    lab_ad          * $54 address
000039FC                          7361  *   dc.l    lab_it          * $58 internal
000039FC                          7362  
000039FC= 4E 45 58 54 20 77 ...   7363  lab_nf  dc.b    'NEXT without FOR',$00
00003A0D= 53 79 6E 74 61 78 00    7364  lab_sn  dc.b    'Syntax',$00
00003A14= 52 45 54 55 52 4E ...   7365  lab_rg  dc.b    'RETURN without GOSUB',$00
00003A29= 4F 75 74 20 6F 66 ...   7366  lab_od  dc.b    'Out of DATA',$00
00003A35= 46 75 6E 63 74 69 ...   7367  lab_fc  dc.b    'Function call',$00
00003A43= 4F 76 65 72 66 6C ...   7368  lab_ov  dc.b    'Overflow',$00
00003A4C= 4F 75 74 20 6F 66 ...   7369  lab_om  dc.b    'Out of memory',$00
00003A5A= 55 6E 64 65 66 69 ...   7370  lab_us  dc.b    'Undefined statement',$00
00003A6E= 41 72 72 61 79 20 ...   7371  lab_bs  dc.b    'Array bounds',$00
00003A7B= 44 6F 75 62 6C 65 ...   7372  lab_dd  dc.b    'Double dimension',$00
00003A8C= 44 69 76 69 64 65 ...   7373  lab_d0  dc.b    'Divide by zero',$00
00003A9B= 49 6C 6C 65 67 61 ...   7374  lab_id  dc.b    'Illegal direct',$00
00003AAA= 54 79 70 65 20 6D ...   7375  lab_tm  dc.b    'Type mismatch',$00
00003AB8= 53 74 72 69 6E 67 ...   7376  lab_ls  dc.b    'String too long',$00
00003AC8= 53 74 72 69 6E 67 ...   7377  lab_st  dc.b    'String too complex',$00
00003ADB= 43 61 6E 27 74 20 ...   7378  lab_cn  dc.b    'Can''t continue',$00
00003AEA= 55 6E 64 65 66 69 ...   7379  lab_uf  dc.b    'Undefined function',$00
00003AFD= 4C 4F 4F 50 20 77 ...   7380  lab_ld  dc.b    'LOOP without DO',$00
00003B0D= 55 6E 64 65 66 69 ...   7381  lab_uv  dc.b    'Undefined variable',$00
00003B20= 55 6E 64 69 6D 65 ...   7382  lab_ua  dc.b    'Undimensioned array',$00
00003B34= 57 72 6F 6E 67 20 ...   7383  lab_wd  dc.b    'Wrong dimensions',$00
00003B45= 41 64 64 72 65 73 ...   7384  lab_ad  dc.b    'Address',$00
00003B4D                          7385  *LAB_IT dc.b    'Internal',$00
00003B4D                          7386  
00003B4D                          7387  * keyword table for line (un)crunching
00003B4D                          7388  
00003B4D                          7389  * [keyword,token
00003B4D                          7390  * [keyword,token]]
00003B4D                          7391  * end marker (#$00)
00003B4D                          7392  
00003B4D                          7393  tab_star
00003B4D                          7394  key_mult
00003B4D= B3 00                   7395      dc.b    tk_mult,$00     * *
00003B4F                          7396  tab_plus
00003B4F                          7397  key_plus
00003B4F= B1 00                   7398      dc.b    tk_plus,$00     * +
00003B51                          7399  tab_mnus
00003B51                          7400  key_minus
00003B51= B2 00                   7401      dc.b    tk_minus,$00        * -
00003B53                          7402  tab_slas
00003B53                          7403  key_div
00003B53= B4 00                   7404      dc.b    tk_div,$00      * /
00003B55                          7405  tab_less
00003B55                          7406  key_lshift
00003B55= 3C BA                   7407      dc.b    '<',TK_LSHIFT       * <<
00003B57                          7408  key_lt
00003B57= BD                      7409      dc.b    tk_lt           * <
00003B58= 00                      7410      dc.b    $00
00003B59                          7411  tab_equl
00003B59                          7412  key_equal
00003B59= BC 00                   7413      dc.b    tk_equal,$00        * =
00003B5B                          7414  tab_more
00003B5B                          7415  key_rshift
00003B5B= 3E B9                   7416      dc.b    '>',TK_RSHIFT       * >>
00003B5D                          7417  key_gt
00003B5D= BB                      7418      dc.b    tk_gt           * >
00003B5E= 00                      7419      dc.b    $00
00003B5F                          7420  tab_qest
00003B5F= 9E 00                   7421      dc.b    tk_print,$00        * ?
00003B61                          7422  tab_asca
00003B61                          7423  key_abs
00003B61= 42 53 C0                7424      dc.b    'BS',TK_ABS     * ABS
00003B64                          7425  key_and
00003B64= 4E 44 B6                7426      dc.b    'ND',TK_AND     * AND
00003B67                          7427  key_asc
00003B67= 53 43 D3                7428      dc.b    'SC',TK_ASC     * ASC
00003B6A                          7429  key_atn
00003B6A= 54 4E CB                7430      dc.b    'TN',TK_ATN     * ATN
00003B6D= 00                      7431      dc.b    $00
00003B6E                          7432  tab_ascb
00003B6E                          7433  key_bins
00003B6E= 49 4E 24 D8             7434      dc.b    'IN$',TK_BINS       * BIN$IN$
00003B72                          7435  key_bitclr
00003B72= 49 54 43 4C 52 A7       7436      dc.b    'ITCLR',TK_BITCLR   * BITCLR
00003B78                          7437  key_bitset
00003B78= 49 54 53 45 54 A6       7438      dc.b    'ITSET',TK_BITSET   * BITSET
00003B7E                          7439  key_bittst
00003B7E= 49 54 54 53 54 D9       7440      dc.b    'ITTST',TK_BITTST   * BITTST
00003B84= 00                      7441      dc.b    $00
00003B85                          7442  tab_ascc
00003B85                          7443  key_call
00003B85= 41 4C 4C 9B             7444      dc.b    'ALL',TK_CALL       * CALL
00003B89                          7445  key_chrs
00003B89= 48 52 24 D6             7446      dc.b    'HR$',TK_CHRS       * CHR$
00003B8D                          7447  key_clear
00003B8D= 4C 45 41 52 A1          7448      dc.b    'LEAR',TK_CLEAR     * CLEAR
00003B92                          7449  key_cont
00003B92= 4F 4E 54 9F             7450      dc.b    'ONT',TK_CONT       * CONT
00003B96                          7451  key_cos
00003B96= 4F 53 C8                7452      dc.b    'OS',TK_COS     * COS
00003B99= 00                      7453      dc.b    $00
00003B9A                          7454  tab_ascd
00003B9A                          7455  key_data
00003B9A= 41 54 41 83             7456      dc.b    'ATA',TK_DATA       * DATA
00003B9E                          7457  key_dec
00003B9E= 45 43 88                7458      dc.b    'EC',TK_DEC     * DEC
00003BA1                          7459  key_deek
00003BA1= 45 45 4B CD             7460      dc.b    'EEK',TK_DEEK       * DEEK
00003BA5                          7461  key_def
00003BA5= 45 46 97                7462      dc.b    'EF',TK_DEF     * DEF
00003BA8                          7463  key_dim
00003BA8= 49 4D 85                7464      dc.b    'IM',TK_DIM     * DIM
00003BAB                          7465  key_doke
00003BAB= 4F 4B 45 99             7466      dc.b    'OKE',TK_DOKE       * DOKE
00003BAF                          7467  key_do
00003BAF= 4F 9C                   7468      dc.b    'O',TK_DO       * DO
00003BB1= 00                      7469      dc.b    $00
00003BB2                          7470  tab_asce
00003BB2                          7471  key_end
00003BB2= 4E 44 80                7472      dc.b    'ND',TK_END     * END
00003BB5                          7473  key_eor
00003BB5= 4F 52 B7                7474      dc.b    'OR',TK_EOR     * EOR
00003BB8                          7475  key_exp
00003BB8= 58 50 C7                7476      dc.b    'XP',TK_EXP     * EXP
00003BBB= 00                      7477      dc.b    $00
00003BBC                          7478  tab_ascf
00003BBC                          7479  key_for
00003BBC= 4F 52 81                7480      dc.b    'OR',TK_FOR     * FOR
00003BBF                          7481  key_fn
00003BBF= 4E AA                   7482      dc.b    'N',TK_FN       * FN
00003BC1                          7483  key_fre
00003BC1= 52 45 C2                7484      dc.b    'RE',TK_FRE     * FRE
00003BC4= 00                      7485      dc.b    $00
00003BC5                          7486  tab_ascg
00003BC5                          7487  key_get
00003BC5= 45 54 A4                7488      dc.b    'ET',TK_GET     * GET
00003BC8                          7489  key_goto
00003BC8= 4F 54 4F 89             7490      dc.b    'OTO',TK_GOTO       * GOTO
00003BCC                          7491  key_gosub
00003BCC= 4F 53 55 42 8D          7492      dc.b    'OSUB',TK_GOSUB     * GOSUB
00003BD1= 00                      7493      dc.b    $00
00003BD2                          7494  tab_asch
00003BD2                          7495  key_hexs
00003BD2= 45 58 24 D7 00          7496      dc.b    'EX$',TK_HEXS,$00   * HEX$
00003BD7                          7497  tab_asci
00003BD7                          7498  key_if
00003BD7= 46 8B                   7499      dc.b    'F',TK_IF       * IF
00003BD9                          7500  key_inc
00003BD9= 4E 43 93                7501      dc.b    'NC',TK_INC     * INC
00003BDC                          7502  key_input
00003BDC= 4E 50 55 54 84          7503      dc.b    'NPUT',TK_INPUT     * INPUT
00003BE1                          7504  key_int
00003BE1= 4E 54 BF                7505      dc.b    'NT',TK_INT     * INT
00003BE4= 00                      7506      dc.b    $00
00003BE5                          7507  tab_ascl
00003BE5                          7508  key_lcases
00003BE5= 43 41 53 45 24 D5       7509      dc.b    'CASE$',TK_LCASES   * LCASE$
00003BEB                          7510  key_leek
00003BEB= 45 45 4B CE             7511      dc.b    'EEK',TK_LEEK       * LEEK
00003BEF                          7512  key_lefts
00003BEF= 45 46 54 24 DF          7513      dc.b    'EFT$',TK_LEFTS     * LEFT$
00003BF4                          7514  key_len
00003BF4= 45 4E D0                7515      dc.b    'EN',TK_LEN     * LEN
00003BF7                          7516  key_let
00003BF7= 45 54 87                7517      dc.b    'ET',TK_LET     * LET
00003BFA                          7518  key_list
00003BFA= 49 53 54 A0             7519      dc.b    'IST',TK_LIST       * LIST
00003BFE                          7520  key_load
00003BFE= 4F 41 44 95             7521      dc.b    'OAD',TK_LOAD       * LOAD
00003C02                          7522  key_log
00003C02= 4F 47 C6                7523      dc.b    'OG',TK_LOG     * LOG
00003C05                          7524  key_loke
00003C05= 4F 4B 45 9A             7525      dc.b    'OKE',TK_LOKE       * LOKE
00003C09                          7526  key_loop
00003C09= 4F 4F 50 9D             7527      dc.b    'OOP',TK_LOOP       * LOOP
00003C0D= 00                      7528      dc.b    $00
00003C0E                          7529  tab_ascm
00003C0E                          7530  key_max
00003C0E= 41 58 DA                7531      dc.b    'AX',TK_MAX     * MAX
00003C11                          7532  key_mids
00003C11= 49 44 24 E1             7533      dc.b    'ID$',TK_MIDS       * MID$
00003C15                          7534  key_min
00003C15= 49 4E DB                7535      dc.b    'IN',TK_MIN     * MIN
00003C18= 00                      7536      dc.b    $00
00003C19                          7537  tab_ascn
00003C19                          7538  key_new
00003C19= 45 57 A2                7539      dc.b    'EW',TK_NEW     * NEW
00003C1C                          7540  key_next
00003C1C= 45 58 54 82             7541      dc.b    'EXT',TK_NEXT       * NEXT
00003C20                          7542  key_not
00003C20= 4F 54 AD                7543      dc.b    'OT',TK_NOT     * NUT
00003C23                          7544  key_null
00003C23= 55 4C 4C 92             7545      dc.b    'ULL',TK_NULL       * NULL
00003C27= 00                      7546      dc.b    $00
00003C28                          7547  tab_asco
00003C28                          7548  key_on
00003C28= 4E 91                   7549      dc.b    'N',TK_ON       * ON
00003C2A                          7550  key_or
00003C2A= 52 B8                   7551      dc.b    'R',TK_OR       * OR
00003C2C= 00                      7552      dc.b    $00
00003C2D                          7553  tab_ascp
00003C2D                          7554  key_peek
00003C2D= 45 45 4B CC             7555      dc.b    'EEK',TK_PEEK       * PEEK
00003C31                          7556  key_pi
00003C31= 49 DC                   7557      dc.b    'I',TK_PI       * PI
00003C33                          7558  key_poke
00003C33= 4F 4B 45 98             7559      dc.b    'OKE',TK_POKE       * POKE
00003C37                          7560  key_pos
00003C37= 4F 53 C3                7561      dc.b    'OS',TK_POS     * POS
00003C3A                          7562  key_print
00003C3A= 52 49 4E 54 9E          7563      dc.b    'RINT',TK_PRINT     * PRINT
00003C3F= 00                      7564      dc.b    $00
00003C40                          7565  tab_ascr
00003C40                          7566  key_read
00003C40= 45 41 44 86             7567      dc.b    'EAD',TK_READ       * READ
00003C44                          7568  key_rem
00003C44= 45 4D 8F                7569      dc.b    'EM',TK_REM     * REM
00003C47                          7570  key_restore
00003C47= 45 53 54 4F 52 45 8C    7571      dc.b    'ESTORE',TK_RESTORE * RESTORE
00003C4E                          7572  key_return
00003C4E= 45 54 55 52 4E 8E       7573      dc.b    'ETURN',TK_RETURN   * RETURN
00003C54                          7574  key_rights
00003C54= 49 47 48 54 24 E0       7575      dc.b    'IGHT$',TK_RIGHTS   * RIGHT$
00003C5A                          7576  key_rnd
00003C5A= 4E 44 C5                7577      dc.b    'ND',TK_RND     * RND
00003C5D                          7578  key_run
00003C5D= 55 4E 8A                7579      dc.b    'UN',TK_RUN     * RUN
00003C60= 00                      7580      dc.b    $00
00003C61                          7581  tab_ascs
00003C61                          7582  key_sadd
00003C61= 41 44 44 CF             7583      dc.b    'ADD',TK_SADD       * SADD
00003C65                          7584  key_save
00003C65= 41 56 45 96             7585      dc.b    'AVE',TK_SAVE       * SAVE
00003C69                          7586  key_sgn
00003C69= 47 4E BE                7587      dc.b    'GN',TK_SGN     * SGN
00003C6C                          7588  key_sin
00003C6C= 49 4E C9                7589      dc.b    'IN',TK_SIN     * SIN
00003C6F                          7590  key_spc
00003C6F= 50 43 28 AB             7591      dc.b    'PC(',TK_SPC        * SPC(
00003C73                          7592  key_sqr
00003C73= 51 52 C4                7593      dc.b    'QR',TK_SQR     * SQR
00003C76                          7594  key_step
00003C76= 54 45 50 AE             7595      dc.b    'TEP',TK_STEP       * STEP
00003C7A                          7596  key_stop
00003C7A= 54 4F 50 90             7597      dc.b    'TOP',TK_STOP       * STOP
00003C7E                          7598  key_strs
00003C7E= 54 52 24 D1             7599      dc.b    'TR$',TK_STRS       * STR$
00003C82                          7600  key_swap
00003C82= 57 41 50 A5             7601      dc.b    'WAP',TK_SWAP       * SWAP
00003C86= 00                      7602      dc.b    $00
00003C87                          7603  tab_asct
00003C87                          7604  key_tab
00003C87= 41 42 28 A8             7605      dc.b    'AB(',TK_TAB        * TAB(
00003C8B                          7606  key_tan
00003C8B= 41 4E CA                7607      dc.b    'AN',TK_TAN     * TAN
00003C8E                          7608  key_then
00003C8E= 48 45 4E AC             7609      dc.b    'HEN',TK_THEN       * THEN
00003C92                          7610  key_to
00003C92= 4F A9                   7611      dc.b    'O',TK_TO       * TO
00003C94                          7612  key_twopi
00003C94= 57 4F 50 49 DD          7613      dc.b    'WOPI',TK_TWOPI     * TWOPI
00003C99= 00                      7614      dc.b    $00
00003C9A                          7615  tab_ascu
00003C9A                          7616  key_ucases
00003C9A= 43 41 53 45 24 D4       7617      dc.b    'CASE$',TK_UCASES   * UCASE$
00003CA0                          7618  key_until
00003CA0= 4E 54 49 4C AF          7619      dc.b    'NTIL',TK_UNTIL     * UNTIL
00003CA5                          7620  key_usr
00003CA5= 53 52 C1                7621      dc.b    'SR',TK_USR     * USR
00003CA8= 00                      7622      dc.b    $00
00003CA9                          7623  tab_ascv
00003CA9                          7624  key_val
00003CA9= 41 4C D2                7625      dc.b    'AL',TK_VAL     * VAL
00003CAC                          7626  key_vptr
00003CAC= 41 52 50 54 52 DE       7627      dc.b    'ARPTR',TK_VPTR     * VARPTR
00003CB2= 00                      7628      dc.b    $00
00003CB3                          7629  tab_ascw
00003CB3                          7630  key_wait
00003CB3= 41 49 54 94             7631      dc.b    'AIT',TK_WAIT       * WAIT
00003CB7                          7632  key_while
00003CB7= 48 49 4C 45 B0          7633      dc.b    'HILE',TK_WHILE     * WHILE
00003CBC                          7634  key_width
00003CBC= 49 44 54 48 A3          7635      dc.b    'IDTH',TK_WIDTH     * WIDTH
00003CC1= 00                      7636      dc.b    $00
00003CC2                          7637  tab_powr
00003CC2                          7638  key_power
00003CC2= B5 00                   7639      dc.b    tk_power,$00        * ^
00003CC4                          7640  
00003CC4                          7641  * just messages
00003CC4                          7642  
00003CC4                          7643  lab_bmsg
00003CC4= 0D 0A 42 72 65 61 ...   7644      dc.b    $0d,$0a,'Break',$00
00003CCC                          7645  lab_emsg
00003CCC= 20 45 72 72 6F 72 00    7646      dc.b    ' Error',$00
00003CD3                          7647  lab_lmsg
00003CD3= 20 69 6E 20 6C 69 ...   7648      dc.b    ' in line ',$00
00003CDD                          7649  lab_imsg
00003CDD= 45 78 74 72 61 20 ...   7650      dc.b    'Extra ignored',$0D,$0A,$00
00003CED                          7651  lab_redo
00003CED= 52 65 64 6F 20 66 ...   7652      dc.b    'Redo from start',$0D,$0A,$00
00003CFF                          7653  lab_rmsg
00003CFF= 0D 0A 52 65 61 64 ...   7654      dc.b    $0d,$0a,'Ready',$0D,$0A,$00
00003D09                          7655  
00003D09                          7656  lab_mszm
00003D09= 0D 0A 4D 65 6D 6F ...   7657      dc.b    $0d,$0a,'Memory size ',$00
00003D18                          7658  
00003D18                          7659  lab_smsg
00003D18= 20 42 79 74 65 73 ...   7660      dc.b    ' Bytes free',$0D,$0A,$0A
00003D26= 45 6E 68 61 6E 63 ...   7661      dc.b    'Enhanced 68k BASIC Version 1.10',$0D,$0A,$00
00003D48                          7662  
00003D48                          7663  *************************************************************************************
00003D48                          7664  * EhBASIC keywords quick reference list                                             *
00003D48                          7665  *************************************************************************************
00003D48                          7666  
00003D48                          7667  * glossary
00003D48                          7668  
00003D48                          7669        * <.>         required
00003D48                          7670        * {.|.}       one of required
00003D48                          7671        * [.]         optional
00003D48                          7672        * ...         may repeat as last
00003D48                          7673  
00003D48                          7674        * any       = anything
00003D48                          7675        * num       = number
00003D48                          7676        * state     = statement
00003D48                          7677        * pint      = positive integer
00003D48                          7678        * str       = string
00003D48                          7679        * var       = variable
00003D48                          7680        * nvar      = numeric variable
00003D48                          7681        * svar      = string variable
00003D48                          7682        * expr      = expression
00003D48                          7683        * nexpr     = numeric expression
00003D48                          7684        * sexpr     = string expression
00003D48                          7685  
00003D48                          7686  * statement separator
00003D48                          7687  
00003D48                          7688  * :         . [state] : [state]                                   * done
00003D48                          7689  
00003D48                          7690  * number bases
00003D48                          7691  
00003D48                          7692  * %         . %<binary num>                                       * done
00003D48                          7693  * $         . $<hex num>                                          * done
00003D48                          7694  
00003D48                          7695  * commands
00003D48                          7696  
00003D48                          7697  * END       . END                                                 * done
00003D48                          7698  * FOR       . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]        * done
00003D48                          7699  * NEXT      . NEXT [<nvar>[,<nvar>]...]                           * done
00003D48                          7700  * DATA      . DATA [{num|["]str["]}[,{num|["]str["]}]...]         * done
00003D48                          7701  * INPUT     . INPUT [<">str<">;] <var>[,<var>[,<var>]...]         * done
00003D48                          7702  * DIM       . DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])              * done
00003D48                          7703  * READ      . READ <var>[,<var>[,<var>]...]                       * done
00003D48                          7704  * LET       . [LET] <var>=<expr>                                  * done
00003D48                          7705  * DEC       . DEC <nvar>[,<nvar>[,<nvar>]...]                     * done
00003D48                          7706  * GOTO      . GOTO <pint>                                         * done
00003D48                          7707  * RUN       . RUN [pint]                                          * done
00003D48                          7708  * IF        . IF <nexpr> {THEN {pint|state}|GOTO <pint>}          * done
00003D48                          7709  * RESTORE   . RESTORE [pint]                                      * done
00003D48                          7710  * GOSUB     . GOSUB <pint>                                        * done
00003D48                          7711  * REM       . REM [any]                                           * done
00003D48                          7712  * STOP      . STOP                                                * done
00003D48                          7713  * ON        . ON <nexpr> {GOTO|GOSUB} <pint>[,<pint>[,<pint>]...] * done
00003D48                          7714  * NULL      . NULL <nexpr>                                        * done
00003D48                          7715  * INC       . INC <nvar>[,<nvar>[,<nvar>]...]                     * done
00003D48                          7716  * WAIT      . WAIT <nexpr>,<nexpr>[,<nexpr>]                      * done
00003D48                          7717  * LOAD      . LOAD <sexpr>                                        * done for simulator
00003D48                          7718  * SAVE      . SAVE <sexpr>                                        * done for simulator
00003D48                          7719  * DEF       . DEF FN<var>(<var>)=<expr>                           * done
00003D48                          7720  * POKE      . POKE <nexpr>,<nexpr>                                * done
00003D48                          7721  * DOKE      . DOKE <nexpr>,<nexpr>                                * done
00003D48                          7722  * LOKE      . LOKE <nexpr>,<nexpr>                                * done
00003D48                          7723  * CALL      . CALL <nexpr>                                        * done
00003D48                          7724  * DO        . DO                                                  * done
00003D48                          7725  * LOOP      . LOOP [{WHILE|UNTIL}<nexpr>]                         * done
00003D48                          7726  * PRINT     . PRINT [{;|,}][expr][{;|,}[expr][{;|,}[expr]]...]    * done
00003D48                          7727  * CONT      . CONT                                                * done
00003D48                          7728  * LIST      . LIST [pint][-pint]                                  * done
00003D48                          7729  * CLEAR     . CLEAR                                               * done
00003D48                          7730  * NEW       . NEW                                                 * done
00003D48                          7731  * WIDTH     . WIDTH [<pint>][,<pint>]                             * done
00003D48                          7732  * GET       . GET <var>                                           * done
00003D48                          7733  * SWAP      . SWAP <var>,<var>                                    * done
00003D48                          7734  * BITSET    . BITSET <nexpr>,<nexpr>                              * done
00003D48                          7735  * BITCLR    . BITCLR <nexpr>,<nexpr>                              * done
00003D48                          7736  
00003D48                          7737  * sub commands (may not start a statement)
00003D48                          7738  
00003D48                          7739  * TAB       . TAB(<nexpr>)                                        * done
00003D48                          7740  * TO        . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]        * done
00003D48                          7741  * FN        . FN<var>(<expr>)                                     * done
00003D48                          7742  * SPC       . SPC(<nexpr>)                                        * done
00003D48                          7743  * THEN      . IF <nexpr> {THEN {pint|comm}|GOTO <pint>}           * done
00003D48                          7744  * NOT       . NOT <nexpr>                                         * done
00003D48                          7745  * STEP      . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]        * done
00003D48                          7746  * UNTIL     . LOOP [{WHILE|UNTIL}<nexpr>]                         * done
00003D48                          7747  * WHILE     . LOOP [{WHILE|UNTIL}<nexpr>]                         * done
00003D48                          7748  
00003D48                          7749  * operators
00003D48                          7750  
00003D48                          7751  * +         . [expr] + <expr>                                     * done
00003D48                          7752  * -         . [nexpr] - <nexpr>                                   * done
00003D48                          7753  * *         . <nexpr> * <nexpr>                                   * done fast hardware
00003D48                          7754  * /         . <nexpr> / <nexpr>                                   * done fast hardware
00003D48                          7755  * ^         . <nexpr> ^ <nexpr>                                   * done
00003D48                          7756  * AND       . <nexpr> AND <nexpr>                                 * done
00003D48                          7757  * EOR       . <nexpr> EOR <nexpr>                                 * done
00003D48                          7758  * OR        . <nexpr> OR <nexpr>                                  * done
00003D48                          7759  * >>        . <nexpr> >> <nexpr>                                  * done
00003D48                          7760  * <<        . <nexpr> << <nexpr>                                  * done
00003D48                          7761  
00003D48                          7762  * compare functions
00003D48                          7763  
00003D48                          7764  * <         . <expr> < <expr>                                     * done
00003D48                          7765  * =         . <expr> = <expr>                                     * done
00003D48                          7766  * >         . <expr> > <expr>                                     * done
00003D48                          7767  
00003D48                          7768  * functions
00003D48                          7769  
00003D48                          7770  * SGN       . SGN(<nexpr>)                                        * done
00003D48                          7771  * INT       . INT(<nexpr>)                                        * done
00003D48                          7772  * ABS       . ABS(<nexpr>)                                        * done
00003D48                          7773  * USR       . USR(<expr>)                                         * done
00003D48                          7774  * FRE       . FRE(<expr>)                                         * done
00003D48                          7775  * POS       . POS(<expr>)                                         * done
00003D48                          7776  * SQR       . SQR(<nexpr>)                                        * done fast shift/sub
00003D48                          7777  * RND       . RND(<nexpr>)                                        * done 31 bit PRNG
00003D48                          7778  * LOG       . LOG(<nexpr>)                                        * done fast cordic
00003D48                          7779  * EXP       . EXP(<nexpr>)                                        * done fast cordic
00003D48                          7780  * COS       . COS(<nexpr>)                                        * done fast cordic
00003D48                          7781  * SIN       . SIN(<nexpr>)                                        * done fast cordic
00003D48                          7782  * TAN       . TAN(<nexpr>)                                        * done fast cordic
00003D48                          7783  * ATN       . ATN(<nexpr>)                                        * done fast cordic
00003D48                          7784  * PEEK      . PEEK(<nexpr>)                                       * done
00003D48                          7785  * DEEK      . DEEK(<nexpr>)                                       * done
00003D48                          7786  * LEEK      . LEEK(<nexpr>)                                       * done
00003D48                          7787  * SADD      . SADD(<sexpr>)                                       * done
00003D48                          7788  * LEN       . LEN(<sexpr>)                                        * done
00003D48                          7789  * STR$      . STR$(<nexpr>)                                       * done
00003D48                          7790  * VAL       . VAL(<sexpr>)                                        * done
00003D48                          7791  * ASC       . ASC(<sexpr>)                                        * done
00003D48                          7792  * UCASE$    . UCASE$(<sexpr>)                                     * done
00003D48                          7793  * LCASE$    . LCASE$(<sexpr>)                                     * done
00003D48                          7794  * CHR$      . CHR$(<nexpr>)                                       * done
00003D48                          7795  * HEX$      . HEX$(<nexpr>)                                       * done
00003D48                          7796  * BIN$      . BIN$(<nexpr>)                                       * done
00003D48                          7797  * BTST      . BTST(<nexpr>,<nexpr>)                               * done
00003D48                          7798  * MAX       . MAX(<nexpr>[,<nexpr>[,<nexpr>]...])                 * done
00003D48                          7799  * MIN       . MIN(<nexpr>[,<nexpr>[,<nexpr>]...])                 * done
00003D48                          7800  * PI        . PI                                                  * done
00003D48                          7801  * TWOPI     . TWOPI                                               * done
00003D48                          7802  * VARPTR    . VARPTR(<var>)                                       * done
00003D48                          7803  * LEFT$     . LEFT$(<sexpr>,<nexpr>)                              * done
00003D48                          7804  * RIGHT$    . RIGHT$(<sexpr>,<nexpr>)                             * done
00003D48                          7805  * MID$      . MID$(<sexpr>,<nexpr>[,<nexpr>])                     * done
00003D48                          7806  
00003D48                          7807  * This lot is in RAM
00003D48                          7808  
00040000                          7809      org $40000
00040000                          7810  ram_strt
00040000                          7811                      * I'll allow 1K for the stack
00040000                          7812  
00040400                          7813      org $40400
00040400                          7814  ram_base
00040400                          7815  lab_warm
00040400                          7816      ds.w    1           * BASIC warm start entry point
00040402                          7817  wrmjpv  ds.l    1           * BASIC warm start jump vector
00040406                          7818  
00040406                          7819  usrjmp  ds.w    1           * USR function JMP address
00040408                          7820  usrjpv  ds.l    1           * USR function JMP vector
0004040C                          7821  
0004040C                          7822  * system dependant i/o vectors
0004040C                          7823  * these are in RAM and are set at start-up
0004040C                          7824  
0004040C                          7825  v_inpt  ds.w    1           * non halting scan input device entry point
0004040E                          7826  v_inptv ds.l    1           * non halting scan input device jump vector
00040412                          7827  
00040412                          7828  v_outp  ds.w    1           * send byte to output device entry point
00040414                          7829  v_outpv ds.l    1           * send byte to output device jump vector
00040418                          7830  
00040418                          7831  v_load  ds.w    1           * load BASIC program entry point
0004041A                          7832  v_loadv ds.l    1           * load BASIC program jump vector
0004041E                          7833  
0004041E                          7834  v_save  ds.w    1           * save BASIC program entry point
00040420                          7835  v_savev ds.l    1           * save BASIC program jump vector
00040424                          7836  
00040424                          7837  v_ctlc  ds.w    1           * save CTRL-C check entry point
00040426                          7838  v_ctlcv ds.l    1           * save CTRL-C check jump vector
0004042A                          7839  
0004042A                          7840  entry_sp
0004042A                          7841      ds.l    1           * stack value on entry to basic
0004042E                          7842  
0004042E                          7843  itemp   ds.l    1           * temporary integer (for GOTO etc)
00040432                          7844  
00040432                          7845  smeml   ds.l    1           * start of memory (start of program)
00040436                          7846  sfncl   ds.l    1           * start of functions    (end of Program)
0004043A                          7847  svarl   ds.l    1           * start of variables    (end of functions)
0004043E                          7848  sstrl   ds.l    1           * start of strings      (end of variables)
00040442                          7849  sarryl  ds.l    1           * start of arrays       (end of strings)
00040446                          7850  earryl  ds.l    1           * end of arrays         (start of free mem)
0004044A                          7851  sstorl  ds.l    1           * string storage        (moving down)
0004044E                          7852  ememl   ds.l    1           * end of memory         (upper bound of RAM)
00040452                          7853  sutill  ds.l    1           * string utility ptr
00040456                          7854  clinel  ds.l    1           * current line          (Basic line number)
0004045A                          7855  blinel  ds.l    1           * break line            (Basic line number)
0004045E                          7856  
0004045E                          7857  cpntrl  ds.l    1           * continue pointer
00040462                          7858  dlinel  ds.l    1           * current DATA line
00040466                          7859  dptrl   ds.l    1           * DATA pointer
0004046A                          7860  rdptrl  ds.l    1           * read pointer
0004046E                          7861  varname ds.l    1           * current var name
00040472                          7862  cvaral  ds.l    1           * current var address
00040476                          7863  frnxtl  ds.l    1           * var pointer for FOR/NEXT
0004047A  =00040476               7864  lvarpl  equ frnxtl          * let var pointer low byte
0004047A                          7865  
0004047A                          7866  des_sk_e
0004047A                          7867      ds.l    6           * descriptor stack end
00040492                          7868  des_sk
00040492                          7869                      * descriptor stack start address
00040492                          7870                      * use a4 for the descriptor pointer
00040492                          7871  
00040492                          7872  * Ibuffs can now be anywhere in RAM just make sure the byte before it is <> $00
00040492                          7873  
00040492                          7874      ds.w    1
00040494                          7875  ibuffs  ds.l    $40         * start of input buffer
00040594                          7876  ibuffe
00040594                          7877                      * end of input buffer
00040594                          7878  
00040594                          7879  fac1_m  ds.l    1           * FAC1 mantissa1
00040598                          7880  fac1_e  ds.w    1           * FAC1 exponent
0004059A  =00040599               7881  fac1_s  equ fac1_e+1        * FAC1 sign (b7)
0004059A                          7882      ds.w    1
0004059C                          7883  
0004059C                          7884  fac2_m  ds.l    1           * FAC2 mantissa1
000405A0                          7885  fac2_e  ds.l    1           * FAC2 exponent
000405A4  =000405A1               7886  fac2_s  equ fac2_e+1        * FAC2 sign (b7)
000405A4  =000405A2               7887  fac_sc  equ fac2_e+2        * FAC sign comparison, Acc#1 vs #2
000405A4  =000405A3               7888  flag    equ fac2_e+3        * flag byte for divide routine
000405A4                          7889  
000405A4                          7890  prnlword
000405A4                          7891      ds.l    1           * PRNG seed long word
000405A8                          7892  
000405A8                          7893  ut1_pl  ds.l    1           * utility pointer 1
000405AC                          7894  
000405AC                          7895  asptl   ds.l    1           * array size/pointer
000405B0                          7896  adatal  ds.l    1           * array data pointer
000405B4                          7897  
000405B4                          7898  astrtl  ds.l    1           * array start pointer low byte
000405B8                          7899  
000405B8  =000405B4               7900  numexp  equ astrtl          * string to float number exponent count
000405B8  =000405B5               7901  expcnt  equ astrtl+1        * string to float exponent count
000405B8                          7902  
000405B8  =000405B7               7903  expneg  equ astrtl+3        * string to float eval exponent -ve flag
000405B8                          7904  
000405B8                          7905  func_l  ds.l    1           * function pointer
000405BC                          7906  
000405BC                          7907  
000405BC                          7908                      * these two need to be a word aligned pair !
000405BC                          7909  defdim  ds.w    1           * default DIM flag
000405BE  =000405BC               7910  cosout  equ defdim          * flag which CORDIC output (re-use byte)
000405BE  =000405BD               7911  dtypef  equ defdim+1        * data type flag, $80=string, $40=integer, $00=float
000405BE                          7912  
000405BE                          7913  
000405BE                          7914  binss   ds.l    4           * number to bin string start (32 chrs)
000405CE                          7915  
000405CE                          7916  decss   ds.l    1           * number to decimal string start (16 chrs)
000405D2                          7917      ds.w    1           *
000405D4                          7918  usdss   ds.w    1           * unsigned decimal string start (10 chrs)
000405D6                          7919  
000405D6                          7920  hexss   ds.l    2           * number to hex string start (8 chrs)
000405DE                          7921  
000405DE                          7922  bhsend  ds.w    1           * bin/decimal/hex string end
000405E0                          7923  
000405E0                          7924  
000405E0                          7925  prstk   ds.b    1           * stacked function index
000405E1                          7926  
000405E1                          7927  srchc   ds.b    1           * search character
000405E2  =000405E1               7928  tpower  equ srchc           * remember CORDIC power (re-use byte)
000405E2                          7929  
000405E2                          7930  asrch   ds.b    1           * scan-between-quotes flag, alt search character
000405E3                          7931  
000405E3                          7932  dimcnt  ds.b    1           * # of dimensions
000405E4                          7933  
000405E4                          7934  breakf  ds.b    1           * break flag, $00=END else=break
000405E5                          7935  oquote  ds.b    1           * open quote flag (Flag: DATA; LIST; memory)
000405E6                          7936  gclctd  ds.b    1           * garbage collected flag
000405E7                          7937  sufnxf  ds.b    1           * subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000405E8                          7938  imode   ds.b    1           * input mode flag, $00=INPUT, $98=READ
000405E9                          7939  
000405E9                          7940  cflag   ds.b    1           * comparison evaluation flag
000405EA                          7941  
000405EA                          7942  tabsiz  ds.b    1           * TAB step size
000405EB                          7943  
000405EB                          7944  tempb   ds.b    1           * temp byte
000405EC                          7945  
000405EC                          7946  comp_f  ds.b    1           * compare function flag, bits 0,1 and 2 used
000405ED                          7947                      * bit 2 set if >
000405ED                          7948                      * bit 1 set if =
000405ED                          7949                      * bit 0 set if <
000405ED                          7950  
000405ED                          7951  nullct  ds.b    1           * nulls output after each line
000405EE                          7952  tpos    ds.b    1           * BASIC terminal position byte
000405EF                          7953  twidth  ds.b    1           * BASIC terminal width byte
000405F0                          7954  iclim   ds.b    1           * input column limit
000405F1                          7955  ccflag  ds.b    1           * CTRL-C check flag
000405F2                          7956  ccbyte  ds.b    1           * CTRL-C last received byte
000405F3                          7957  ccnull  ds.b    1           * CTRL-C last received byte 'life' timer
000405F4                          7958  
000405F4                          7959  * these variables for simulator load/save routines
000405F4                          7960  
000405F4                          7961  file_byte
000405F4                          7962      ds.b    1           * load/save data byte
000405F6                          7963  file_id ds.l    1           * load/save file ID
000405FA                          7964  
000405FA= 0000                    7965      dc.w    0           * dummy even value and zero pad byte
000405FC                          7966  
000405FC                          7967  prg_strt
000405FC  =00048000               7968  ram_top equ $48000          * last RAM byte + 1
000405FC                          7969  
000405FC                          7970      end code_start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AC1GTAC2            2444
ADATAL              405B0
ASPTL               405AC
ASRCH               405E2
ASTRTL              405B4
BHSEND              405DE
BIN2DEC             328E
BINPR               2DE8
BINSS               405BE
BLINEL              4045A
BREAKF              405E4
CCBYTE              405F2
CCFLAG              405F1
CCNULL              405F3
CFLAG               405E9
CLINEL              40456
CODE_START          5CC
COMP_F              405EC
COSOUT              405BC
CPNTRL              4045E
CVARAL              40472
D1X02               3268
D1X10               327E
D1X16               325A
DECSS               405CE
DEFDIM              405BC
DES_SK              40492
DES_SK_E            4047A
DIMCNT              405E3
DLINEL              40462
DOAGAIN             D16
DOCMP               DB6
DOREST              D9A
DPTRL               40466
DTYPEF              405BD
EARRYL              40446
EMEML               4044E
ENDBHS              2DC2
ENTRY_SP            4042A
EXPCNT              405B5
EXPNEG              405B7
FAC1_E              40598
FAC1_M              40594
FAC1_S              40599
FAC2_E              405A0
FAC2_M              4059C
FAC2_S              405A1
FAC_SC              405A2
FILE_BYTE           405F4
FILE_ID             405F6
FLAG                405A3
FRNXTL              40476
FUNC_L              405B8
GCLCTD              405E6
GETFIRST            1624
GETPAIR             16E8
GOPR                2DF2
HEXSS               405D6
IBUFFE              40594
IBUFFS              40494
ICLIM               405F0
IMODE               405E8
INGET               2E60
ITEMP               4042E
KEY_ABS             3B61
KEY_AND             3B64
KEY_ASC             3B67
KEY_ATN             3B6A
KEY_BINS            3B6E
KEY_BITCLR          3B72
KEY_BITSET          3B78
KEY_BITTST          3B7E
KEY_CALL            3B85
KEY_CHRS            3B89
KEY_CLEAR           3B8D
KEY_CONT            3B92
KEY_COS             3B96
KEY_DATA            3B9A
KEY_DEC             3B9E
KEY_DEEK            3BA1
KEY_DEF             3BA5
KEY_DIM             3BA8
KEY_DIV             3B53
KEY_DO              3BAF
KEY_DOKE            3BAB
KEY_END             3BB2
KEY_EOR             3BB5
KEY_EQUAL           3B59
KEY_EXP             3BB8
KEY_FN              3BBF
KEY_FOR             3BBC
KEY_FRE             3BC1
KEY_GET             3BC5
KEY_GOSUB           3BCC
KEY_GOTO            3BC8
KEY_GT              3B5D
KEY_HEXS            3BD2
KEY_IF              3BD7
KEY_INC             3BD9
KEY_INPUT           3BDC
KEY_INT             3BE1
KEY_LCASES          3BE5
KEY_LEEK            3BEB
KEY_LEFTS           3BEF
KEY_LEN             3BF4
KEY_LET             3BF7
KEY_LIST            3BFA
KEY_LOAD            3BFE
KEY_LOG             3C02
KEY_LOKE            3C05
KEY_LOOP            3C09
KEY_LSHIFT          3B55
KEY_LT              3B57
KEY_MAX             3C0E
KEY_MIDS            3C11
KEY_MIN             3C15
KEY_MINUS           3B51
KEY_MULT            3B4D
KEY_NEW             3C19
KEY_NEXT            3C1C
KEY_NOT             3C20
KEY_NULL            3C23
KEY_ON              3C28
KEY_OR              3C2A
KEY_PEEK            3C2D
KEY_PI              3C31
KEY_PLUS            3B4F
KEY_POKE            3C33
KEY_POS             3C37
KEY_POWER           3CC2
KEY_PRINT           3C3A
KEY_READ            3C40
KEY_REM             3C44
KEY_RESTORE         3C47
KEY_RETURN          3C4E
KEY_RIGHTS          3C54
KEY_RND             3C5A
KEY_RSHIFT          3B5B
KEY_RUN             3C5D
KEY_SADD            3C61
KEY_SAVE            3C65
KEY_SGN             3C69
KEY_SIN             3C6C
KEY_SPC             3C6F
KEY_SQR             3C73
KEY_STEP            3C76
KEY_STOP            3C7A
KEY_STRS            3C7E
KEY_SWAP            3C82
KEY_TAB             3C87
KEY_TAN             3C8B
KEY_THEN            3C8E
KEY_TO              3C92
KEY_TWOPI           3C94
KEY_UCASES          3C9A
KEY_UNTIL           3CA0
KEY_USR             3CA5
KEY_VAL             3CA9
KEY_VPTR            3CAC
KEY_WAIT            3CB3
KEY_WHILE           3CB7
KEY_WIDTH           3CBC
KFCTSEED            26A3D110
LAB_11A1            730
LAB_11A6            734
LAB_11BB            758
LAB_121F            76A
LAB_1269            7F0
LAB_1274            800
LAB_127D            808
LAB_127E            81C
LAB_1295            832
LAB_12B0            850
LAB_12E6            874
LAB_1301            8B8
LAB_1303            8D4
LAB_1325            8EC
LAB_132E            8DC
LAB_1330            8DE
LAB_134B            8FA
LAB_1357            90C
LAB_1359            914
LAB_1374            936
LAB_1378            93C
LAB_137F            948
LAB_138E            94E
LAB_13A6            952
LAB_13AC            95C
LAB_13CC            98A
LAB_13D6            9AE
LAB_13D8            9B4
LAB_13EA            9C0
LAB_13EC            9C2
LAB_13FF            9DA
LAB_1401            9E0
LAB_1408            9EE
LAB_1410            9FC
LAB_1417            A06
LAB_141B            A08
LAB_141F            A18
LAB_142A            A1E
LAB_142C            A2A
LAB_145E            A4C
LAB_145F            A3E
LAB_1463            A54
LAB_1477            A64
LAB_147A            A6C
LAB_1491            A98
LAB_14BD            AC4
LAB_14D4            AEA
LAB_14E2            B0E
LAB_150C            B1C
LAB_1519            B2E
LAB_152E            B3A
LAB_1540            B6A
LAB_1567            B84
LAB_15B3            BD6
LAB_15C2            C08
LAB_15D1            C18
LAB_15DC            BEE
LAB_15F6            C02
LAB_15FF            C26
LAB_1602            C28
LAB_161A            C8E
LAB_1624            C94
LAB_1629            C4A
LAB_1636            C50
LAB_163B            C60
LAB_1647            C6E
LAB_164F            C78
LAB_16B0            D2A
LAB_16D0            D5E
LAB_16D4            D64
LAB_1723            E10
LAB_1725            E14
LAB_172C            DFE
LAB_172D            E08
LAB_174B            E2E
LAB_1754            D34
LAB_176C            E5A
LAB_1773            E64
LAB_1785            E80
LAB_1786            EAC
LAB_17B7            EBE
LAB_17B8            F10
LAB_17D5            F54
LAB_17D6            F5A
LAB_1810            F72
LAB_1811            F84
LAB_1813            F8A
LAB_1829            FC6
LAB_182C            FCA
LAB_1831            FD0
LAB_185E            1018
LAB_1866            101C
LAB_1880            10F2
LAB_1886            10FE
LAB_188A            1104
LAB_188B            102A
LAB_1898            103C
LAB_18A2            1048
LAB_18B7            106E
LAB_18B8            1076
LAB_18BD            107C
LAB_18C3            1084
LAB_18C6            1088
LAB_18CD            1092
LAB_18E3            109C
LAB_18F0            10C4
LAB_18F7            10D4
LAB_18F9            10DA
LAB_1904            1108
LAB_1913            111E
LAB_1934            1146
LAB_1953            1160
LAB_195B            116C
LAB_1984            11A0
LAB_1985            11A4
LAB_1986            11A8
LAB_1999            11BE
LAB_19B0            11D0
LAB_19B6            11E4
LAB_19C2            11F4
LAB_19DD            120A
LAB_19F6            122C
LAB_1A03            123A
LAB_1A0E            1250
LAB_1A1B            1256
LAB_1A46            1266
LAB_1A49            126A
LAB_1A90            12FA
LAB_1A9B            130A
LAB_1ABA            133E
LAB_1ACC            134A
LAB_1ACD            134C
LAB_1ADB            135A
LAB_1ADE            135E
LAB_1AE0            1376
LAB_1AFA            139C
LAB_1B0B            13B8
LAB_1B13            13C0
LAB_1B1C            13D2
LAB_1B1D            13D4
LAB_1B2A            13E8
LAB_1B3C            140C
LAB_1B43            1418
LAB_1B56            142C
LAB_1B78            1456
LAB_1B7B            145A
LAB_1B7D            145C
LAB_1B84            1466
LAB_1B86            146C
LAB_1B9D            149E
LAB_1BA4            14AE
LAB_1BC1            14DA
LAB_1BD0            1544
LAB_1BE7            155E
LAB_1BF3            14E6
LAB_1BF7            14EE
LAB_1BFB            14F2
LAB_1BFE            14F6
LAB_1C01            14FA
LAB_1C11            151C
LAB_1C13            1520
LAB_1C18            1526
LAB_1C19            152A
LAB_1C1A            153E
LAB_1C27            156E
LAB_1C51            15EA
LAB_1C54            15F2
LAB_1C56            15F4
LAB_1CAE            164A
LAB_1CB5            166C
LAB_1CD4            1676
LAB_1CD5            167C
LAB_1CD6            167E
LAB_1CDB            168E
LAB_1CE6            1680
LAB_1CF2            1690
LAB_1CFE            16A8
LAB_1D10            1722
LAB_1D12            1728
LAB_1D2D            173E
LAB_1D2E            174A
LAB_1D44            1768
LAB_1D45            177A
LAB_1D48            1794
LAB_1D49            179C
LAB_1D4A            17A2
LAB_1D4B            17B4
LAB_1D5D            17BC
LAB_1D5E            17C2
LAB_1D82            1700
LAB_1D83            1712
LAB_1D8A            1708
LAB_1D96            32B2
LAB_1D98            17DC
LAB_1DAE            17F8
LAB_1DAF            17FE
LAB_1DB0            180E
LAB_1DB1            1814
LAB_1DB2            181A
LAB_1DD7            1834
LAB_1DD8            184C
LAB_1DD9            185A
LAB_1DE6            186A
LAB_1E17            18C2
LAB_1E1F            18CA
LAB_1E5C            1908
LAB_1E8D            192C
LAB_1EA1            194C
LAB_1EC0            1986
LAB_1ED8            19BE
LAB_1EDF            196C
LAB_1F07            19D0
LAB_1F28            19F2
LAB_1F2C            19FA
LAB_1F5A            1A08
LAB_1F6A            1A3A
LAB_1F6B            1A4A
LAB_1F7C            1A56
LAB_1FB4            1A84
LAB_1FD0            1ABC
LAB_201E            1B2E
LAB_2043            1B80
LAB_2044            1BC2
LAB_2045            1BCC
LAB_204S            1B82
LAB_204T            1BC0
LAB_20AE            1BE6
LAB_20B4            1BEA
LAB_20BE            1BF0
LAB_20C9            1C1A
LAB_20CB            1C00
LAB_20D0            1C08
LAB_20D8            1C24
LAB_20E0            1C2E
LAB_2115            1C52
LAB_2117            1C6C
LAB_2128            1C8E
LAB_2137            1C92
LAB_214B            1CB6
LAB_2161            1CCE
LAB_2176            1CD8
LAB_217E            1CE4
LAB_2183            1CFE
LAB_218B            1D06
LAB_218F            1D08
LAB_21C2            1D16
LAB_21C4            1D1A
LAB_21D1            1D52
LAB_2206            1D58
LAB_2212            1D84
LAB_2216            1D40
LAB_2240            1D48
LAB_224D            1D8C
LAB_229C            1DE2
LAB_229E            1DE8
LAB_22A0            1DF6
LAB_22B6            1E0A
LAB_22BA            1E10
LAB_22BD            1E1A
LAB_22E6            1E38
LAB_2316            1E72
LAB_231C            1E78
LAB_2358            1EA8
LAB_2368            1EC4
LAB_236F            1ECC
LAB_2441            20B0
LAB_2445            20B4
LAB_244E            20DE
LAB_2467            2124
LAB_2468            2128
LAB_246C            20E2
LAB_249C            2116
LAB_24A8            212C
LAB_24B4            2162
LAB_24D0            2172
LAB_24D5            2182
LAB_24D6            21A2
LAB_24D7            21B0
LAB_24D8            21B8
LAB_24D9            2194
LAB_24DA            21C0
LAB_24F7            214E
LAB_24F8            2156
LAB_259C            3792
LAB_264D            2390
LAB_269E            23BC
LAB_26CA            23FA
LAB_2778            2504
LAB_277C            2506
LAB_279B            2530
LAB_27BA            2546
LAB_27C3            2568
LAB_27C4            2574
LAB_27CA            257C
LAB_27CE            2586
LAB_27D0            258C
LAB_27DB            259A
LAB_27F8            25B8
LAB_27FA            25BC
LAB_2828            25E8
LAB_282E            25EE
LAB_282F            25F0
LAB_2831            25F4
LAB_2844            261E
LAB_2845            2622
LAB_2846            2630
LAB_287F            263A
LAB_2887            3058
LAB_289A            308A
LAB_289C            3090
LAB_289D            3096
LAB_28FD            30B2
LAB_28FE            30B8
LAB_28FF            30BE
LAB_2900            30CC
LAB_2901            30D2
LAB_2902            3126
LAB_2903            312E
LAB_2904            3130
LAB_2947            378A
LAB_294B            378E
LAB_2953            266C
LAB_295E            267A
LAB_2966            2680
LAB_2967            2690
LAB_2968            2698
LAB_2969            26AA
LAB_296A            26B4
LAB_2970            26C6
LAB_2978            26E2
LAB_2989            26F2
LAB_299C            2728
LAB_29A7            2734
LAB_29B2            2740
LAB_29B9            274C
LAB_29C0            2788
LAB_29C3            278C
LAB_29D9            27A8
LAB_29E4            27BE
LAB_29F7            27D2
LAB_29FB            27D6
LAB_29FD            27DE
LAB_2A18            27F0
LAB_2A1A            27F2
LAB_2A21            27FA
LAB_2A3B            281C
LAB_2A4B            282A
LAB_2A58            283E
LAB_2A68            285A
LAB_2A74            2868
LAB_2A89            2884
LAB_2A8C            2888
LAB_2A91            288E
LAB_2A96            3796
LAB_2A9A            379A
LAB_2D93            682
LAB_2DAA            696
LAB_2DAB            6C2
LAB_2DAD            6C6
LAB_2DB6            6CC
LAB_2X01            30EA
LAB_2X02            30F4
LAB_2X03            3102
LAB_2X04            3108
LAB_2X05            311E
LAB_2Y01            313E
LAB_2Y02            3148
LAB_2Y03            3154
LAB_2Y04            315A
LAB_3216            2496
LAB_32_16           2494
LAB_ABER            7B4
LAB_ABS             25AE
LAB_AD              3B45
LAB_ADD             20E6
LAB_ADER            780
LAB_AND             161C
LAB_ASC             1F3C
LAB_ATCD            2CD6
LAB_ATLO            2C9E
LAB_ATN             2C7A
LAB_ATNP            2CD0
LAB_AYFC            1A94
LAB_BAER            39A4
LAB_BHSS            15B2
LAB_BINS            2D9C
LAB_BITCLR          2D54
LAB_BITSET          2D3C
LAB_BMSG            3CC4
LAB_BS              3A6E
LAB_BTST            2D6C
LAB_CALL            208A
LAB_CASC            16FA
LAB_CATN            2CDC
LAB_CBIN            322A
LAB_CBX1            3246
LAB_CBXN            3234
LAB_CCER            798
LAB_CHEX            31C2
LAB_CHRS            1E40
LAB_CHX1            31EA
LAB_CHX2            320E
LAB_CHX3            3206
LAB_CHXX            31CC
LAB_CKRN            1AC4
LAB_CKTM            132E
LAB_CLEAR           AB8
LAB_CN              3ADB
LAB_COLD            5D2
LAB_CONT            CD6
LAB_CORD            2BF0
LAB_COS             2B66
LAB_CRLF            1022
LAB_CTBL            360C
LAB_CTNM            1326
LAB_CTST            132A
LAB_D0              3A8C
LAB_DATA            DF0
LAB_DD              3A7B
LAB_DDER            7B0
LAB_DEC             EB4
LAB_DECI            F20
LAB_DEEK            200E
LAB_DEF             1AD2
LAB_DEFV            1B0A
LAB_DIM             16AC
LAB_DIV0            248E
LAB_DIVIDE          23FC
LAB_DIVX            245E
LAB_DO              D0A
LAB_DOKE            2038
LAB_DZER            7AC
LAB_EMSG            3CCC
LAB_END             C58
LAB_EOR             1602
LAB_EQUAL           1634
LAB_ESML            2A3E
LAB_EVBY            1F58
LAB_EVEX            1344
LAB_EVIN            1880
LAB_EVIR            1892
LAB_EVIX            18BA
LAB_EVNM            1324
LAB_EVPI            1888
LAB_EVST            1E06
LAB_EX1             2950
LAB_EXAD            2ADE
LAB_EXCC            2AC4
LAB_EXCM            29C8
LAB_EXNN            2AAA
LAB_EXOF            297E
LAB_EXOU            2964
LAB_EXP             299C
LAB_EXPL            2AA4
LAB_EXPS            29E0
LAB_EXRN            2AB0
LAB_EXXF            3214
LAB_FB95            2E76
LAB_FBA0            2E50
LAB_FC              3A35
LAB_FCER            7C4
LAB_FOR             B76
LAB_FRE             1A78
LAB_FTBL            35B4
LAB_FTXX            36AC
LAB_GADB            1FB0
LAB_GADW            1FC4
LAB_GARB            1CA8
LAB_GBYT            1504
LAB_GEAD            1FE4
LAB_GET             F90
LAB_GETS            FAE
LAB_GFPN            E74
LAB_GMEM            618
LAB_GOSUB           D1E
LAB_GOTO            D3C
LAB_GOTS            D42
LAB_GSCH            CC0
LAB_GTBY            1F54
LAB_GTHAN           293E
LAB_GTWO            1F6A
LAB_GVAL            14A6
LAB_GVAR            171C
LAB_HEXS            2DFC
LAB_ID              3A9B
LAB_IDER            7A8
LAB_IF              E1A
LAB_IGBY            1502
LAB_IMSG            3CDD
LAB_INC             EBA
LAB_INCI            F16
LAB_INCT            F02
LAB_INLN            902
LAB_INPUT           112E
LAB_INT             263E
LAB_ISHN            31E6
LAB_KEYT            381C
LAB_LAAD            2256
LAB_LCASE           1EDE
LAB_LD              3AFD
LAB_LDER            790
LAB_LEEK            2024
LAB_LEFT            1E52
LAB_LENS            1F34
LAB_LET             F24
LAB_LIST            ABC
LAB_LMSG            3CD3
LAB_LOCC            225C
LAB_LOCX            2278
LAB_LOG             21C2
LAB_LOKE            203E
LAB_LOLP            2266
LAB_LONE            2296
LAB_LONN            227C
LAB_LOOP            D78
LAB_LOWZ            22E4
LAB_LOXO            229C
LAB_LOXP            228A
LAB_LS              3AB8
LAB_LSHIFT          16B8
LAB_LTHAN           163E
LAB_LTPF            2C06
LAB_LTPT            2C1A
LAB_LT_1            24A2
LAB_MADD            2322
LAB_MAN1            2488
LAB_MAX             2E84
LAB_MAXN            2E8C
LAB_MIDS            1E90
LAB_MIN             2E96
LAB_MINN            2E9E
LAB_MMEC            2EAA
LAB_MNOC            231A
LAB_MSZM            3D09
LAB_MUEX            237A
LAB_MUF1            2352
LAB_MUF2            235C
LAB_MUF3            2374
LAB_MULTIPLY        22E6
LAB_MUUF            2380
LAB_NEW             A52
LAB_NEXT            125E
LAB_NF              39FC
LAB_NFER            7D4
LAB_NOBYTE          FB8
LAB_NOST            FC0
LAB_NSCH            CBA
LAB_NSTT            2F22
LAB_NULL            CCA
LAB_OD              3A29
LAB_ODER            7C8
LAB_OFER            7C0
LAB_OM              3A4C
LAB_OMER            7BC
LAB_ON              E40
LAB_OPPT            373C
LAB_OR              1614
LAB_OV              3A43
LAB_PEEK            1FFC
LAB_PFAC            24E8
LAB_PHFA            2EBA
LAB_PI              3020
LAB_POKE            2008
LAB_POON            2892
LAB_POS             1AB6
LAB_POWER           28B6
LAB_POWP            28F4
LAB_POZE            28A6
LAB_PRINT           FCE
LAB_PRNA            109E
LAB_P_10            339E
LAB_READ            1158
LAB_REDO            3CED
LAB_REM             E38
LAB_REMM            24BA
LAB_RESN            C9E
LAB_RESS            CAC
LAB_RESTORE         C8C
LAB_RET0            31AC
LAB_RETURN          DD6
LAB_RG              3A14
LAB_RGER            7CC
LAB_RIGHT           1E64
LAB_RMSG            3CFF
LAB_RND             2AEA
LAB_RSED            32B6
LAB_RSHIFT          16C8
LAB_RTN0            31AE
LAB_RTST            1C34
LAB_RUN             CF2
LAB_RUNN            D04
LAB_SADD            1F2A
LAB_SCCA            14FC
LAB_SCCC            2B8C
LAB_SCER            79C
LAB_SCGB            1F4A
LAB_SCL0            2BE6
LAB_SCLN            A40
LAB_SCZE            2C6C
LAB_SET1            2466
LAB_SGBY            1F50
LAB_SGN             2598
LAB_SHLN            A36
LAB_SIN             2B86
LAB_SLER            7A0
LAB_SMSG            3D18
LAB_SN              3A0D
LAB_SNBS            DF8
LAB_SNER            7D0
LAB_SQE1            2FC6
LAB_SQE2            2FCC
LAB_SQNA            2FF8
LAB_SQNS            2FDE
LAB_SQR             2F9A
LAB_SSLN            A30
LAB_ST              3AC8
LAB_STOP            C56
LAB_STRS            1BDC
LAB_SUBTRACT        20BE
LAB_SVTB            2F5A
LAB_SWAP            2052
LAB_TAN             2B34
LAB_TBSZ            2F36
LAB_TBYT            150C
LAB_TM              3AAA
LAB_TMER            7A4
LAB_TWOPI           303C
LAB_UA              3B20
LAB_UCASE           1F02
LAB_UDER            788
LAB_UF              3AEA
LAB_UFAC            24C8
LAB_UFER            794
LAB_US              3A5A
LAB_USER            7B8
LAB_UV              3B0D
LAB_UVER            78C
LAB_VAL             1F7E
LAB_VALZ            1FA8
LAB_VARPTR          300A
LAB_WAIT            209A
LAB_WARM            40400
LAB_WD              3B34
LAB_WDER            784
LAB_WDLP            2F76
LAB_WDTH            2EFE
LAB_XDIV            2478
LAB_XERR            7D6
LAB_XGADW           1FDE
LC_LOOP             1EEA
LOAD_ASCII          4A4
LOAD_CLOSE          494
LOAD_EOF            4DE
LOAD_EXIT           498
LOAD_IN             4B6
LOOPALWAYS          DBE
LOOPDONE            DD0
LVARPL              40476
L_DDIV              24C2
L_DIVRND            246A
MAINLOOP            2C32
N                   2
NEXTA               2C44
NEXTB1              2DB4
NEXTB2              2DDA
NEXTH1              2E14
NEXTPRN             2AFC
NINC0               2B04
NINC1               2B0C
NINC2               2B12
NOLCASE             1F20
NOSHIFT             16C4
NOSTRING            1F24
NOT2BIG             16DC
NOUCASE             1EFC
NULLCT              405ED
NUMEXP              405B4
OQUOTE              405E5
OUTLOOP             2C52
PRG_STRT            405FC
PRNLWORD            405A4
PRSTK               405E0
RAM_BASE            40400
RAM_STRT            40000
RAM_TOP             48000
RDPTRL              4046A
RETCHR              422
RTS_001             151A
RTS_002             756
RTS_003             768
RTS_004             77E
RTS_005             AB6
RTS_006             C9C
RTS_007             DF6
RTS_007A            E0C
RTS_008             F8E
RTS_009             109A
RTS_011             1A54
RTS_012             1D56
RTS_013             1E04
RTS_015             2050
RTS_016             2154
RTS_017             257A
RTS_018             25F2
RTS_019             26C4
RTS_020             294E
RTS_021             2C6A
RTS_022             2E5E
RTS_023             2F98
RTS_024             3228
RTS_025             328C
SARRYL              40442
SAVE_BAS            56C
SAVE_CLOSE          59E
SAVE_EXIT           5A2
SAVE_OUT            5AE
SFNCL               40436
SMEML               40432
SRCHC               405E1
SSTORL              4044A
SSTRL               4043E
SUBEXIT             2C5E
SUBLOOP             2C2A
SUFNXF              405E7
SUTILL              40452
SVARL               4043A
TABSIZ              405EA
TAB_ASCA            3B61
TAB_ASCB            3B6E
TAB_ASCC            3B85
TAB_ASCD            3B9A
TAB_ASCE            3BB2
TAB_ASCF            3BBC
TAB_ASCG            3BC5
TAB_ASCH            3BD2
TAB_ASCI            3BD7
TAB_ASCL            3BE5
TAB_ASCM            3C0E
TAB_ASCN            3C19
TAB_ASCO            3C28
TAB_ASCP            3C2D
TAB_ASCR            3C40
TAB_ASCS            3C61
TAB_ASCT            3C87
TAB_ASCU            3C9A
TAB_ASCV            3CA9
TAB_ASCW            3CB3
TAB_ATNC            350C
TAB_CHRT            37B2
TAB_EQUL            3B59
TAB_HTHET           358C
TAB_LESS            3B55
TAB_MNUS            3B51
TAB_MORE            3B5B
TAB_PLUS            3B4F
TAB_POWR            3CC2
TAB_QEST            3B5F
TAB_SLAS            3B53
TAB_SNCO            348C
TAB_STAR            3B4D
TEMPB               405EB
TK_ABS              C0
TK_AND              B6
TK_ASC              D3
TK_ATN              CB
TK_BINS             D8
TK_BITCLR           A7
TK_BITSET           A6
TK_BITTST           D9
TK_CALL             9B
TK_CHRS             D6
TK_CLEAR            A1
TK_CONT             9F
TK_COS              C8
TK_DATA             83
TK_DEC              88
TK_DEEK             CD
TK_DEF              97
TK_DIM              85
TK_DIV              B4
TK_DO               9C
TK_DOKE             99
TK_END              80
TK_EOR              B7
TK_EQUAL            BC
TK_EXP              C7
TK_FN               AA
TK_FOR              81
TK_FRE              C2
TK_GET              A4
TK_GOSUB            8D
TK_GOTO             89
TK_GT               BB
TK_HEXS             D7
TK_IF               8B
TK_INC              93
TK_INPUT            84
TK_INT              BF
TK_LCASES           D5
TK_LEEK             CE
TK_LEFTS            DF
TK_LEN              D0
TK_LET              87
TK_LIST             A0
TK_LOAD             95
TK_LOG              C6
TK_LOKE             9A
TK_LOOP             9D
TK_LSHIFT           BA
TK_LT               BD
TK_MAX              DA
TK_MIDS             E1
TK_MIN              DB
TK_MINUS            B2
TK_MULT             B3
TK_NEW              A2
TK_NEXT             82
TK_NOT              AD
TK_NULL             92
TK_ON               91
TK_OR               B8
TK_PEEK             CC
TK_PI               DC
TK_PLUS             B1
TK_POKE             98
TK_POS              C3
TK_POWER            B5
TK_PRINT            9E
TK_READ             86
TK_REM              8F
TK_RESTORE          8C
TK_RETURN           8E
TK_RIGHTS           E0
TK_RND              C5
TK_RSHIFT           B9
TK_RUN              8A
TK_SADD             CF
TK_SAVE             96
TK_SGN              BE
TK_SIN              C9
TK_SPC              AB
TK_SQR              C4
TK_STEP             AE
TK_STOP             90
TK_STRS             D1
TK_SWAP             A5
TK_TAB              A8
TK_TAN              CA
TK_THEN             AC
TK_TO               A9
TK_TWOPI            DD
TK_UCASES           D4
TK_UNTIL            AF
TK_USR              C1
TK_VAL              D2
TK_VPTR             DE
TK_WAIT             94
TK_WHILE            B0
TK_WIDTH            A3
TOOBIG              16E2
TPOS                405EE
TPOWER              405E1
TWIDTH              405EF
UC_LOOP             1F0E
USDSS               405D4
USRJMP              40406
USRJPV              40408
UT1_PL              405A8
VARNAME             4046E
VEC_CC              2E2E
VEC_IN              410
VEC_LD              434
VEC_OUT             400
VEC_SV              4FA
V_CTLC              40424
V_CTLCV             40426
V_INPT              4040C
V_INPTV             4040E
V_LOAD              40418
V_LOADV             4041A
V_OUTP              40412
V_OUTPV             40414
V_SAVE              4041E
V_SAVEV             40420
WEXIT               2F60
WRMJPV              40402
X10EXIT             23F8
X10EXP              23E6
X10NORND            23D2
